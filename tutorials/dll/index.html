<h1>Using DLLs for Extensibility</h1>

<h2>Using DLLs</h2>

<p>XSplit Broadcaster allows you to use DLLs for your plugins. Because DLLs might contain potentially harmful functions, our security protocols may be used to classify DLLs through the following categories:</p>

<ol>
  <li><strong>Signed, auto-loaded DLLs</strong>: this is a very small subset of DLLs that are automatically loaded for use by any plugins. Hence, these do not require developers to call <code>Dll.load()</code> to be used. Auto-loaded DLLs are also not subject to our DLL security; thus, all their methods may be called without asking the user to grant permission. An example of this is <code>Xjs.dll</code> (functions are outlined in the tables below).</li>
  <li><strong>Other signed DLLs</strong>: this comprises most of the DLLs that will be used by plugins. <code>XjsEx.dll</code> is an example. These need to be loaded by the plugin first, and access then needs to be granted by the XBC user as part of the security protocols. (Access can automatically be granted if a user has disabled DLL security in the Tools > General Settings > Advanced.</li>
  <li><strong>Unsigned DLLs</strong>: these DLLs will never be loaded by the application even if <code>Dll.load()</code> is called, unless Developer Mode is activated (Tools > General Settings > Advanced). Developer mode is disabled by default as it is not intended for production use. (Information on creating your own DLLs will be provided soon.)</li>
</ol>

<p>We are currently exposing a number of our internal DLLs for you to use. All functions may return a <code>string</code> value. Occasionally, DLL functions may invoke callbacks defined on the global object.</p>

<p><i>Important note:</i> This feature of XSplit Broadcaster and the framework is likely to change in the future. This may mean changes on the framework side or on the application side. <strong>If your plugin makes use of DLL calls for its main functionality, please take note of any changes related to DLLs on every new version of the framework we release.</strong> (Our changelog will always be found at our <a href="https://github.com/xjsframework/xjs/wiki" target="_blank">Github wiki</a>.) You may want to subscribe to the developers' newsletter as well; check the <a href="https://developers.xsplit.com" target="_blank">XSplit Developers website.</a></p>

<h4>Loading DLLs</h4>
<p>The first thing plugin developers should do is to load the DLLs they need on initialization. This is done using <code>Dll.load()</code>. (This is not necessary if auto-loaded DLLs are used.)</p>

<h4>Checking for access</h4>
<p>The next thing to do is to check if the user has granted DLL access to the plugin. (If the plugin only uses auto-loaded DLLs, you may skip this step.) By calling <code>Dll.isAccessGranted()</code>, you can determine if the user has granted access, or alternatively, if the user has disabled DLL security altogether. In both cases, DLL functions should work. Based on the result of the access check, this will determine what the plugin should do.

<h4>When access is granted</h4>
<p>If step 2 returns true, then you can safely call any function call. Otherwise, you can add an event listener for the DLL class <code>access-granted</code> event.</p>

<h4>Calling functions</h4>
<p>Simply use the DLL module's <code>callFunction()</code> call. The first parameter is the function name, and you may supply any number of additional parameters for the DLL function call. Note that if the DLL call is inaccessible at the time of execution, the promise rejects with an error instead of resolving with a value. Sample code follows:</p>
<p><pre class="language-javascript"><code>Dll.callFunction('xsplit.EnumProcesses').then(function(value) {console.log(value);});
// sample return value: "0,4,456,608,724,856,864,940,972,620,1012"</code></pre></p>

<h4>Callback usage</h4>
<p>Some functions can call functions defined on the global scope. Consult your DLL documentation for these functions and the callbacks they may call.</p>
<p><pre class="language-javascript"><code>// handle values from xsplit.HookSubscribe DLL call
window.OnInputHookEvent = function(msg, wparam, lparam) { }</code></pre>

<h4>When access is revoked</h4>
<p>Developers can choose to subscribe to the <code>access-revoked</code> event. If step 2 returns false, or when users revoke access to DLLs, it is highly suggested that plugins show some visual feedback that either explicitly requests for DLL access, or explains that features of the plugin may not work.</p>

<h4>Sample code</h4>
<p>This is sample code for an imaginary plugin that continuously updates the UI as to whether a file exists or not.</p>

<pre class="language-javascript"><code>var xjs = require('xjs');
var dll = xjs.Dll;

xjs.ready().then(function() {
  dll.load('Scriptdlls\\SplitMediaLabs\\XjsEx.dll'); // path for loading is relative to the application folder
  var statusLabel = document.getElementById('statusLabel');
  var updateLabel = function(status) {
    if (status === 'exist') statusLabel.textContent = 'File exists!';
    else if (status === 'not-exist') statusLabel.textContent = 'File does not exist';
    // we update label if we cannot call DLL function properly
    else if (status === 'unknown') statusLabel.textContent = 'File status unknown. Please allow DLL access for the plugin.';
  };

  // a function for checking existence of a file
  var checkStatus = function() {
    dll.call('xsplit.Exists', 'C:\\test.mp4').then(function(val) {
      if (val === '1') updateLabel('exist');
      else if (val === '0') updateLabel('not-exist');
    });
  };

  var updateInterval;
  dll.on('access-granted', function() {
    // begin file status polling when access is granted
    updateInterval = setInterval(checkStatus, 5000);
  });
  dll.on('access-revoked', function() {
    // we should stop polling when access is revoked
    clearInterval(updateInterval);
    // but we want to update label to inform users
    updateLabel('unknown');
  });

  // initial check for access
  dll.isAccessGranted().then(function(isAccessGranted) {
    if (isAccessGranted) {
      dll.emit('access-granted'); // manually trigger event so that polling can begin
    } else {
      dll.emit('access-revoked'); // manually trigger event so we can update information label
    }
  });
});
</pre>


<h2>Existing XSplit DLL documentation</h2>

<p>We are currently exposing the following two DLLs for developers. Note that DLL call return types will always be <code>string</code>. <em>If you find any bugs with the XSplit DLLs, please file an issue at the framework's <a href='https://github.com/xjsframework/xjs/issues/new' target='_new'>Github page.</a></em></p>

<p><i>Important note:</i> For security purposes, only <code>Xjs.dll</code> is automatically loaded. In order to access the functionality of <code>XjsEx.dll</code>, you will need to load it using <code>Dll.load()</code> as in the sample code above.</p>

<table>
  <caption>Xjs.dll (auto-loaded)</caption>
  <thead>
    <tr>
      <th>Function name</th>
      <th>Parameters</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>xsplit.EnumParentWindows</code></td>
      <td></td>
      <td>list all window handles of visible, non-transparent, non-minimized windows for all processes</td>
    </tr>

    <tr>
      <td><code>xsplit.EnumProcesses</code></td>
      <td></td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.GetForegroundWindow</code></td>
      <td></td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.GetWindowState</code></td>
      <td>windowHandle</td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.GetWindowProcessId</code></td>
      <td>windowHandle</td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.GetProcessDetails</code></td>
      <td>processId</td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.GetProcessModules</code></td>
      <td>processId</td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.GetProcessWindowsList</code></td>
      <td>processId</td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.GetWindowTitle</code></td>
      <td>windowHandle</td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.GetWindowClassName</code></td>
      <td>windowHandle</td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.GetSysCpuUsage</code></td>
      <td>string of the format <code>&lt;idleTime&gt;,&lt;kernelTime&gt;,&lt;userTime&gt;</code>.<br /><br />
        Pass 0 for above values on initial call. On succeeding calls, use values returned from previous call.
      </td>
      <td>Get CPU Usage for system. Returns a string of the format <code>&lt;usage&gt;|&lt;idleTime&gt;,&lt;kernelTime&gt;,&lt;userTime&gt;</code></td>
    </tr>

    <tr>
      <td><code>xsplit.GetProcCpuUsage</code></td>
      <td>string of the format <code>&lt;processId&gt;,&lt;idleTime&gt;,&lt;kernelTime&gt;,&lt;userTime&gt;</code>.<br /><br />
        Pass 0 for non-<code>processId</code> values on initial call. On succeeding calls, use values returned from previous call.
      </td>
      <td>Get CPU Usage for process identified by <code>processId</code>. Returns a string of the format <code>&lt;usage&gt;|&lt;processId&gt;,&lt;idleTime&gt;,&lt;kernelTime&gt;,&lt;userTime&gt;</code></td>
    </tr>

    <tr>
      <td><code>xsplit.GetSysMemoryUsage</code></td>
      <td></td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.GetProcMemoryUsage</code></td>
      <td>processId</td>
      <td></td>
    </tr>

  </tbody>
</table>
<br />
<table>
  <caption>XjsEx.dll</caption>
  <thead>
    <tr>
      <th>Function name</th>
      <th>Parameters</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>xsplit.Copy</code></td>
      <td>source, target</td>
      <td>Returns an async ID, which can be used for the other related calls.</td>
    </tr>

    <tr>
      <td><code>xsplit.CopyCancel</code></td>
      <td>async ID</td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.CopyPause</code></td>
      <td>async ID</td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.CopyResume</code></td>
      <td>async ID</td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.CreateFolder</code></td>
      <td>target</td>
      <td>Returns "true" only if folder is created.</td>
    </tr>

    <tr>
      <td><code>xsplit.Delete</code></td>
      <td>source</td>
      <td>Returns an async ID.</td>
    </tr>

    <tr>
      <td><code>xsplit.Move</code></td>
      <td>source, target</td>
      <td>Returns an async ID.</td>
    </tr>

    <tr>
      <td><code>xsplit.Progress</code></td>
      <td>async ID</td>
      <td>Returns progress percentage of file operation as identified by async ID.</td>
    </tr>

    <tr>
      <td><code>xsplit.Write</code></td>
      <td>filename, data, overwriteFlag, type<br /><br />
        Overwrite flag must be 0 or 1. Type refers to file encoding type. Possible values are 1: Unicode, 2: UTF-8, 3: Base 64
      </td>
      <td>Writes to a file. Returns number of bytes written.</td>
    </tr>

    <tr>
      <td><code>xsplit.Zip</code></td>
      <td>input, zipPath, overwriteFlag<br /><br />
        Overwrite flag must be 0 or 1. 1 means it will create a new zip containing only input as end result, and 0 means it will append to an existing zip file.
      </td>
      <td>Creates a zip archive</td>
    </tr>

    <tr>
      <td><code>xsplit.ZipCancel</code></td>
      <td>async ID</td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.ZipPause</code></td>
      <td>async ID</td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.ZipResume</code></td>
      <td>async ID</td>
      <td></td>
    </tr>

    <tr>
      <td><code>xsplit.Exists</code></td>
      <td>item_path</td>
      <td>Checks for the existence of a file or folder. Returns "1" if it exists, and "0" otherwise.</td>
    </tr>

    <tr>
      <td><code>xsplit.HookSubscribe</code></td>
      <td></td>
      <td>Subscribes to global keyboard/mouse hook. Hook events will use the callback <code>OnInputHookEvent</code> with parameters:<br />
      <ol>
        <li><code>msg</code> - one of this values <code>WM_KEYDOWN</code>, <code>WM_KEYUP</code>, <code>WM_SYSKEYDOWN</code>, or <code>WM_SYSKEYUP</code> for keyboard events, or <code>WM_LBUTTONDOWN</code>, <code>WM_LBUTTONUP</code>, <code>WM_MOUSEMOVE</code>, <code>WM_MOUSEWHEEL</code>, <code>WM_MOUSEHWHEEL</code>, <code>WM_RBUTTONDOWN</code>, or <code>WM_RBUTTONUP</code>. - for mouse events.</li>
        <li><code>wparam</code></li>
        <li><code>lparam</code></li>
      </ol>
      For more information on the parameters, check <a href='https://msdn.microsoft.com/en-us/library/windows/desktop/ms646280(v=vs.85).aspx' target='_new'>this reference.</a>
      </td>
    </tr>

    <tr>
      <td><code>xsplit.HookUnsubscribe</code></td>
      <td></td>
      <td>Unsubscribe from global keyboard/mouse hook.</td>
    </tr>
  </tbody>
</table>
