<plugin encoded="true" protocol="file"><!DOCTYPE html><html>
  <head>
    <meta charset="utf-8">
    <title>TrackTL Properties Editor</title>

    <script>/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.5.5
window.WebComponents = window.WebComponents || {};

(function(scope) {
  var flags = scope.flags || {};
  var file = "webcomponents.js";
  var script = document.querySelector('script[src*="' + file + '"]');
  if (!flags.noOpts) {
    location.search.slice(1).split("&").forEach(function(o) {
      o = o.split("=");
      o[0] && (flags[o[0]] = o[1] || true);
    });
    if (script) {
      for (var i = 0, a; a = script.attributes[i]; i++) {
        if (a.name !== "src") {
          flags[a.name] = a.value || true;
        }
      }
    }
    if (flags.log) {
      var parts = flags.log.split(",");
      flags.log = {};
      parts.forEach(function(f) {
        flags.log[f] = true;
      });
    } else {
      flags.log = {};
    }
  }
  flags.shadow = flags.shadow || flags.shadowdom || flags.polyfill;
  if (flags.shadow === "native") {
    flags.shadow = false;
  } else {
    flags.shadow = flags.shadow || !HTMLElement.prototype.createShadowRoot;
  }
  if (flags.register) {
    window.CustomElements = window.CustomElements || {
      flags: {}
    };
    window.CustomElements.flags.register = flags.register;
  }
  scope.flags = flags;
})(WebComponents);

if (WebComponents.flags.shadow) {
  if (typeof WeakMap === "undefined") {
    (function() {
      var defineProperty = Object.defineProperty;
      var counter = Date.now() % 1e9;
      var WeakMap = function() {
        this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
      };
      WeakMap.prototype = {
        set: function(key, value) {
          var entry = key[this.name];
          if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
            value: [ key, value ],
            writable: true
          });
          return this;
        },
        get: function(key) {
          var entry;
          return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
        },
        "delete": function(key) {
          var entry = key[this.name];
          if (!entry || entry[0] !== key) return false;
          entry[0] = entry[1] = undefined;
          return true;
        },
        has: function(key) {
          var entry = key[this.name];
          if (!entry) return false;
          return entry[0] === key;
        }
      };
      window.WeakMap = WeakMap;
    })();
  }
  window.ShadowDOMPolyfill = {};
  (function(scope) {
    "use strict";
    var constructorTable = new WeakMap();
    var nativePrototypeTable = new WeakMap();
    var wrappers = Object.create(null);
    function detectEval() {
      if (typeof chrome !== "undefined" && chrome.app && chrome.app.runtime) {
        return false;
      }
      if (navigator.getDeviceStorage) {
        return false;
      }
      try {
        var f = new Function("return true;");
        return f();
      } catch (ex) {
        return false;
      }
    }
    var hasEval = detectEval();
    function assert(b) {
      if (!b) throw new Error("Assertion failed");
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    function mixin(to, from) {
      var names = getOwnPropertyNames(from);
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        defineProperty(to, name, getOwnPropertyDescriptor(from, name));
      }
      return to;
    }
    function mixinStatics(to, from) {
      var names = getOwnPropertyNames(from);
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        switch (name) {
         case "arguments":
         case "caller":
         case "length":
         case "name":
         case "prototype":
         case "toString":
          continue;
        }
        defineProperty(to, name, getOwnPropertyDescriptor(from, name));
      }
      return to;
    }
    function oneOf(object, propertyNames) {
      for (var i = 0; i < propertyNames.length; i++) {
        if (propertyNames[i] in object) return propertyNames[i];
      }
    }
    var nonEnumerableDataDescriptor = {
      value: undefined,
      configurable: true,
      enumerable: false,
      writable: true
    };
    function defineNonEnumerableDataProperty(object, name, value) {
      nonEnumerableDataDescriptor.value = value;
      defineProperty(object, name, nonEnumerableDataDescriptor);
    }
    getOwnPropertyNames(window);
    function getWrapperConstructor(node) {
      var nativePrototype = node.__proto__ || Object.getPrototypeOf(node);
      if (isFirefox) {
        try {
          getOwnPropertyNames(nativePrototype);
        } catch (error) {
          nativePrototype = nativePrototype.__proto__;
        }
      }
      var wrapperConstructor = constructorTable.get(nativePrototype);
      if (wrapperConstructor) return wrapperConstructor;
      var parentWrapperConstructor = getWrapperConstructor(nativePrototype);
      var GeneratedWrapper = createWrapperConstructor(parentWrapperConstructor);
      registerInternal(nativePrototype, GeneratedWrapper, node);
      return GeneratedWrapper;
    }
    function addForwardingProperties(nativePrototype, wrapperPrototype) {
      installProperty(nativePrototype, wrapperPrototype, true);
    }
    function registerInstanceProperties(wrapperPrototype, instanceObject) {
      installProperty(instanceObject, wrapperPrototype, false);
    }
    var isFirefox = /Firefox/.test(navigator.userAgent);
    var dummyDescriptor = {
      get: function() {},
      set: function(v) {},
      configurable: true,
      enumerable: true
    };
    function isEventHandlerName(name) {
      return /^on[a-z]+$/.test(name);
    }
    function isIdentifierName(name) {
      return /^\w[a-zA-Z_0-9]*$/.test(name);
    }
    function getGetter(name) {
      return hasEval && isIdentifierName(name) ? new Function("return this.__impl4cf1e782hg__." + name) : function() {
        return this.__impl4cf1e782hg__[name];
      };
    }
    function getSetter(name) {
      return hasEval && isIdentifierName(name) ? new Function("v", "this.__impl4cf1e782hg__." + name + " = v") : function(v) {
        this.__impl4cf1e782hg__[name] = v;
      };
    }
    function getMethod(name) {
      return hasEval && isIdentifierName(name) ? new Function("return this.__impl4cf1e782hg__." + name + ".apply(this.__impl4cf1e782hg__, arguments)") : function() {
        return this.__impl4cf1e782hg__[name].apply(this.__impl4cf1e782hg__, arguments);
      };
    }
    function getDescriptor(source, name) {
      try {
        return Object.getOwnPropertyDescriptor(source, name);
      } catch (ex) {
        return dummyDescriptor;
      }
    }
    var isBrokenSafari = function() {
      var descr = Object.getOwnPropertyDescriptor(Node.prototype, "nodeType");
      return descr && !descr.get && !descr.set;
    }();
    function installProperty(source, target, allowMethod, opt_blacklist) {
      var names = getOwnPropertyNames(source);
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        if (name === "polymerBlackList_") continue;
        if (name in target) continue;
        if (source.polymerBlackList_ && source.polymerBlackList_[name]) continue;
        if (isFirefox) {
          source.__lookupGetter__(name);
        }
        var descriptor = getDescriptor(source, name);
        var getter, setter;
        if (allowMethod && typeof descriptor.value === "function") {
          target[name] = getMethod(name);
          continue;
        }
        var isEvent = isEventHandlerName(name);
        if (isEvent) getter = scope.getEventHandlerGetter(name); else getter = getGetter(name);
        if (descriptor.writable || descriptor.set || isBrokenSafari) {
          if (isEvent) setter = scope.getEventHandlerSetter(name); else setter = getSetter(name);
        }
        var configurable = isBrokenSafari || descriptor.configurable;
        defineProperty(target, name, {
          get: getter,
          set: setter,
          configurable: configurable,
          enumerable: descriptor.enumerable
        });
      }
    }
    function register(nativeConstructor, wrapperConstructor, opt_instance) {
      var nativePrototype = nativeConstructor.prototype;
      registerInternal(nativePrototype, wrapperConstructor, opt_instance);
      mixinStatics(wrapperConstructor, nativeConstructor);
    }
    function registerInternal(nativePrototype, wrapperConstructor, opt_instance) {
      var wrapperPrototype = wrapperConstructor.prototype;
      assert(constructorTable.get(nativePrototype) === undefined);
      constructorTable.set(nativePrototype, wrapperConstructor);
      nativePrototypeTable.set(wrapperPrototype, nativePrototype);
      addForwardingProperties(nativePrototype, wrapperPrototype);
      if (opt_instance) registerInstanceProperties(wrapperPrototype, opt_instance);
      defineNonEnumerableDataProperty(wrapperPrototype, "constructor", wrapperConstructor);
      wrapperConstructor.prototype = wrapperPrototype;
    }
    function isWrapperFor(wrapperConstructor, nativeConstructor) {
      return constructorTable.get(nativeConstructor.prototype) === wrapperConstructor;
    }
    function registerObject(object) {
      var nativePrototype = Object.getPrototypeOf(object);
      var superWrapperConstructor = getWrapperConstructor(nativePrototype);
      var GeneratedWrapper = createWrapperConstructor(superWrapperConstructor);
      registerInternal(nativePrototype, GeneratedWrapper, object);
      return GeneratedWrapper;
    }
    function createWrapperConstructor(superWrapperConstructor) {
      function GeneratedWrapper(node) {
        superWrapperConstructor.call(this, node);
      }
      var p = Object.create(superWrapperConstructor.prototype);
      p.constructor = GeneratedWrapper;
      GeneratedWrapper.prototype = p;
      return GeneratedWrapper;
    }
    function isWrapper(object) {
      return object && object.__impl4cf1e782hg__;
    }
    function isNative(object) {
      return !isWrapper(object);
    }
    function wrap(impl) {
      if (impl === null) return null;
      assert(isNative(impl));
      return impl.__wrapper8e3dd93a60__ || (impl.__wrapper8e3dd93a60__ = new (getWrapperConstructor(impl))(impl));
    }
    function unwrap(wrapper) {
      if (wrapper === null) return null;
      assert(isWrapper(wrapper));
      return wrapper.__impl4cf1e782hg__;
    }
    function unsafeUnwrap(wrapper) {
      return wrapper.__impl4cf1e782hg__;
    }
    function setWrapper(impl, wrapper) {
      wrapper.__impl4cf1e782hg__ = impl;
      impl.__wrapper8e3dd93a60__ = wrapper;
    }
    function unwrapIfNeeded(object) {
      return object && isWrapper(object) ? unwrap(object) : object;
    }
    function wrapIfNeeded(object) {
      return object && !isWrapper(object) ? wrap(object) : object;
    }
    function rewrap(node, wrapper) {
      if (wrapper === null) return;
      assert(isNative(node));
      assert(wrapper === undefined || isWrapper(wrapper));
      node.__wrapper8e3dd93a60__ = wrapper;
    }
    var getterDescriptor = {
      get: undefined,
      configurable: true,
      enumerable: true
    };
    function defineGetter(constructor, name, getter) {
      getterDescriptor.get = getter;
      defineProperty(constructor.prototype, name, getterDescriptor);
    }
    function defineWrapGetter(constructor, name) {
      defineGetter(constructor, name, function() {
        return wrap(this.__impl4cf1e782hg__[name]);
      });
    }
    function forwardMethodsToWrapper(constructors, names) {
      constructors.forEach(function(constructor) {
        names.forEach(function(name) {
          constructor.prototype[name] = function() {
            var w = wrapIfNeeded(this);
            return w[name].apply(w, arguments);
          };
        });
      });
    }
    scope.assert = assert;
    scope.constructorTable = constructorTable;
    scope.defineGetter = defineGetter;
    scope.defineWrapGetter = defineWrapGetter;
    scope.forwardMethodsToWrapper = forwardMethodsToWrapper;
    scope.isWrapper = isWrapper;
    scope.isWrapperFor = isWrapperFor;
    scope.mixin = mixin;
    scope.nativePrototypeTable = nativePrototypeTable;
    scope.oneOf = oneOf;
    scope.registerObject = registerObject;
    scope.registerWrapper = register;
    scope.rewrap = rewrap;
    scope.setWrapper = setWrapper;
    scope.unsafeUnwrap = unsafeUnwrap;
    scope.unwrap = unwrap;
    scope.unwrapIfNeeded = unwrapIfNeeded;
    scope.wrap = wrap;
    scope.wrapIfNeeded = wrapIfNeeded;
    scope.wrappers = wrappers;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    function newSplice(index, removed, addedCount) {
      return {
        index: index,
        removed: removed,
        addedCount: addedCount
      };
    }
    var EDIT_LEAVE = 0;
    var EDIT_UPDATE = 1;
    var EDIT_ADD = 2;
    var EDIT_DELETE = 3;
    function ArraySplice() {}
    ArraySplice.prototype = {
      calcEditDistances: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {
        var rowCount = oldEnd - oldStart + 1;
        var columnCount = currentEnd - currentStart + 1;
        var distances = new Array(rowCount);
        for (var i = 0; i < rowCount; i++) {
          distances[i] = new Array(columnCount);
          distances[i][0] = i;
        }
        for (var j = 0; j < columnCount; j++) distances[0][j] = j;
        for (var i = 1; i < rowCount; i++) {
          for (var j = 1; j < columnCount; j++) {
            if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1]; else {
              var north = distances[i - 1][j] + 1;
              var west = distances[i][j - 1] + 1;
              distances[i][j] = north < west ? north : west;
            }
          }
        }
        return distances;
      },
      spliceOperationsFromEditDistances: function(distances) {
        var i = distances.length - 1;
        var j = distances[0].length - 1;
        var current = distances[i][j];
        var edits = [];
        while (i > 0 || j > 0) {
          if (i == 0) {
            edits.push(EDIT_ADD);
            j--;
            continue;
          }
          if (j == 0) {
            edits.push(EDIT_DELETE);
            i--;
            continue;
          }
          var northWest = distances[i - 1][j - 1];
          var west = distances[i - 1][j];
          var north = distances[i][j - 1];
          var min;
          if (west < north) min = west < northWest ? west : northWest; else min = north < northWest ? north : northWest;
          if (min == northWest) {
            if (northWest == current) {
              edits.push(EDIT_LEAVE);
            } else {
              edits.push(EDIT_UPDATE);
              current = northWest;
            }
            i--;
            j--;
          } else if (min == west) {
            edits.push(EDIT_DELETE);
            i--;
            current = west;
          } else {
            edits.push(EDIT_ADD);
            j--;
            current = north;
          }
        }
        edits.reverse();
        return edits;
      },
      calcSplices: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {
        var prefixCount = 0;
        var suffixCount = 0;
        var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
        if (currentStart == 0 && oldStart == 0) prefixCount = this.sharedPrefix(current, old, minLength);
        if (currentEnd == current.length && oldEnd == old.length) suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
        currentStart += prefixCount;
        oldStart += prefixCount;
        currentEnd -= suffixCount;
        oldEnd -= suffixCount;
        if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];
        if (currentStart == currentEnd) {
          var splice = newSplice(currentStart, [], 0);
          while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);
          return [ splice ];
        } else if (oldStart == oldEnd) return [ newSplice(currentStart, [], currentEnd - currentStart) ];
        var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
        var splice = undefined;
        var splices = [];
        var index = currentStart;
        var oldIndex = oldStart;
        for (var i = 0; i < ops.length; i++) {
          switch (ops[i]) {
           case EDIT_LEAVE:
            if (splice) {
              splices.push(splice);
              splice = undefined;
            }
            index++;
            oldIndex++;
            break;

           case EDIT_UPDATE:
            if (!splice) splice = newSplice(index, [], 0);
            splice.addedCount++;
            index++;
            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;

           case EDIT_ADD:
            if (!splice) splice = newSplice(index, [], 0);
            splice.addedCount++;
            index++;
            break;

           case EDIT_DELETE:
            if (!splice) splice = newSplice(index, [], 0);
            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
          }
        }
        if (splice) {
          splices.push(splice);
        }
        return splices;
      },
      sharedPrefix: function(current, old, searchLength) {
        for (var i = 0; i < searchLength; i++) if (!this.equals(current[i], old[i])) return i;
        return searchLength;
      },
      sharedSuffix: function(current, old, searchLength) {
        var index1 = current.length;
        var index2 = old.length;
        var count = 0;
        while (count < searchLength && this.equals(current[--index1], old[--index2])) count++;
        return count;
      },
      calculateSplices: function(current, previous) {
        return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
      },
      equals: function(currentValue, previousValue) {
        return currentValue === previousValue;
      }
    };
    scope.ArraySplice = ArraySplice;
  })(window.ShadowDOMPolyfill);
  (function(context) {
    "use strict";
    var OriginalMutationObserver = window.MutationObserver;
    var callbacks = [];
    var pending = false;
    var timerFunc;
    function handle() {
      pending = false;
      var copies = callbacks.slice(0);
      callbacks = [];
      for (var i = 0; i < copies.length; i++) {
        (0, copies[i])();
      }
    }
    if (OriginalMutationObserver) {
      var counter = 1;
      var observer = new OriginalMutationObserver(handle);
      var textNode = document.createTextNode(counter);
      observer.observe(textNode, {
        characterData: true
      });
      timerFunc = function() {
        counter = (counter + 1) % 2;
        textNode.data = counter;
      };
    } else {
      timerFunc = window.setTimeout;
    }
    function setEndOfMicrotask(func) {
      callbacks.push(func);
      if (pending) return;
      pending = true;
      timerFunc(handle, 0);
    }
    context.setEndOfMicrotask = setEndOfMicrotask;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var setEndOfMicrotask = scope.setEndOfMicrotask;
    var wrapIfNeeded = scope.wrapIfNeeded;
    var wrappers = scope.wrappers;
    var registrationsTable = new WeakMap();
    var globalMutationObservers = [];
    var isScheduled = false;
    function scheduleCallback(observer) {
      if (observer.scheduled_) return;
      observer.scheduled_ = true;
      globalMutationObservers.push(observer);
      if (isScheduled) return;
      setEndOfMicrotask(notifyObservers);
      isScheduled = true;
    }
    function notifyObservers() {
      isScheduled = false;
      while (globalMutationObservers.length) {
        var notifyList = globalMutationObservers;
        globalMutationObservers = [];
        notifyList.sort(function(x, y) {
          return x.uid_ - y.uid_;
        });
        for (var i = 0; i < notifyList.length; i++) {
          var mo = notifyList[i];
          mo.scheduled_ = false;
          var queue = mo.takeRecords();
          removeTransientObserversFor(mo);
          if (queue.length) {
            mo.callback_(queue, mo);
          }
        }
      }
    }
    function MutationRecord(type, target) {
      this.type = type;
      this.target = target;
      this.addedNodes = new wrappers.NodeList();
      this.removedNodes = new wrappers.NodeList();
      this.previousSibling = null;
      this.nextSibling = null;
      this.attributeName = null;
      this.attributeNamespace = null;
      this.oldValue = null;
    }
    function registerTransientObservers(ancestor, node) {
      for (;ancestor; ancestor = ancestor.parentNode) {
        var registrations = registrationsTable.get(ancestor);
        if (!registrations) continue;
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.options.subtree) registration.addTransientObserver(node);
        }
      }
    }
    function removeTransientObserversFor(observer) {
      for (var i = 0; i < observer.nodes_.length; i++) {
        var node = observer.nodes_[i];
        var registrations = registrationsTable.get(node);
        if (!registrations) return;
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          if (registration.observer === observer) registration.removeTransientObservers();
        }
      }
    }
    function enqueueMutation(target, type, data) {
      var interestedObservers = Object.create(null);
      var associatedStrings = Object.create(null);
      for (var node = target; node; node = node.parentNode) {
        var registrations = registrationsTable.get(node);
        if (!registrations) continue;
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          if (type === "attributes" && !options.attributes) continue;
          if (type === "attributes" && options.attributeFilter && (data.namespace !== null || options.attributeFilter.indexOf(data.name) === -1)) {
            continue;
          }
          if (type === "characterData" && !options.characterData) continue;
          if (type === "childList" && !options.childList) continue;
          var observer = registration.observer;
          interestedObservers[observer.uid_] = observer;
          if (type === "attributes" && options.attributeOldValue || type === "characterData" && options.characterDataOldValue) {
            associatedStrings[observer.uid_] = data.oldValue;
          }
        }
      }
      for (var uid in interestedObservers) {
        var observer = interestedObservers[uid];
        var record = new MutationRecord(type, target);
        if ("name" in data && "namespace" in data) {
          record.attributeName = data.name;
          record.attributeNamespace = data.namespace;
        }
        if (data.addedNodes) record.addedNodes = data.addedNodes;
        if (data.removedNodes) record.removedNodes = data.removedNodes;
        if (data.previousSibling) record.previousSibling = data.previousSibling;
        if (data.nextSibling) record.nextSibling = data.nextSibling;
        if (associatedStrings[uid] !== undefined) record.oldValue = associatedStrings[uid];
        scheduleCallback(observer);
        observer.records_.push(record);
      }
    }
    var slice = Array.prototype.slice;
    function MutationObserverOptions(options) {
      this.childList = !!options.childList;
      this.subtree = !!options.subtree;
      if (!("attributes" in options) && ("attributeOldValue" in options || "attributeFilter" in options)) {
        this.attributes = true;
      } else {
        this.attributes = !!options.attributes;
      }
      if ("characterDataOldValue" in options && !("characterData" in options)) this.characterData = true; else this.characterData = !!options.characterData;
      if (!this.attributes && (options.attributeOldValue || "attributeFilter" in options) || !this.characterData && options.characterDataOldValue) {
        throw new TypeError();
      }
      this.characterData = !!options.characterData;
      this.attributeOldValue = !!options.attributeOldValue;
      this.characterDataOldValue = !!options.characterDataOldValue;
      if ("attributeFilter" in options) {
        if (options.attributeFilter == null || typeof options.attributeFilter !== "object") {
          throw new TypeError();
        }
        this.attributeFilter = slice.call(options.attributeFilter);
      } else {
        this.attributeFilter = null;
      }
    }
    var uidCounter = 0;
    function MutationObserver(callback) {
      this.callback_ = callback;
      this.nodes_ = [];
      this.records_ = [];
      this.uid_ = ++uidCounter;
      this.scheduled_ = false;
    }
    MutationObserver.prototype = {
      constructor: MutationObserver,
      observe: function(target, options) {
        target = wrapIfNeeded(target);
        var newOptions = new MutationObserverOptions(options);
        var registration;
        var registrations = registrationsTable.get(target);
        if (!registrations) registrationsTable.set(target, registrations = []);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i].observer === this) {
            registration = registrations[i];
            registration.removeTransientObservers();
            registration.options = newOptions;
          }
        }
        if (!registration) {
          registration = new Registration(this, target, newOptions);
          registrations.push(registration);
          this.nodes_.push(target);
        }
      },
      disconnect: function() {
        this.nodes_.forEach(function(node) {
          var registrations = registrationsTable.get(node);
          for (var i = 0; i < registrations.length; i++) {
            var registration = registrations[i];
            if (registration.observer === this) {
              registrations.splice(i, 1);
              break;
            }
          }
        }, this);
        this.records_ = [];
      },
      takeRecords: function() {
        var copyOfRecords = this.records_;
        this.records_ = [];
        return copyOfRecords;
      }
    };
    function Registration(observer, target, options) {
      this.observer = observer;
      this.target = target;
      this.options = options;
      this.transientObservedNodes = [];
    }
    Registration.prototype = {
      addTransientObserver: function(node) {
        if (node === this.target) return;
        scheduleCallback(this.observer);
        this.transientObservedNodes.push(node);
        var registrations = registrationsTable.get(node);
        if (!registrations) registrationsTable.set(node, registrations = []);
        registrations.push(this);
      },
      removeTransientObservers: function() {
        var transientObservedNodes = this.transientObservedNodes;
        this.transientObservedNodes = [];
        for (var i = 0; i < transientObservedNodes.length; i++) {
          var node = transientObservedNodes[i];
          var registrations = registrationsTable.get(node);
          for (var j = 0; j < registrations.length; j++) {
            if (registrations[j] === this) {
              registrations.splice(j, 1);
              break;
            }
          }
        }
      }
    };
    scope.enqueueMutation = enqueueMutation;
    scope.registerTransientObservers = registerTransientObservers;
    scope.wrappers.MutationObserver = MutationObserver;
    scope.wrappers.MutationRecord = MutationRecord;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    function TreeScope(root, parent) {
      this.root = root;
      this.parent = parent;
    }
    TreeScope.prototype = {
      get renderer() {
        if (this.root instanceof scope.wrappers.ShadowRoot) {
          return scope.getRendererForHost(this.root.host);
        }
        return null;
      },
      contains: function(treeScope) {
        for (;treeScope; treeScope = treeScope.parent) {
          if (treeScope === this) return true;
        }
        return false;
      }
    };
    function setTreeScope(node, treeScope) {
      if (node.treeScope_ !== treeScope) {
        node.treeScope_ = treeScope;
        for (var sr = node.shadowRoot; sr; sr = sr.olderShadowRoot) {
          sr.treeScope_.parent = treeScope;
        }
        for (var child = node.firstChild; child; child = child.nextSibling) {
          setTreeScope(child, treeScope);
        }
      }
    }
    function getTreeScope(node) {
      if (node instanceof scope.wrappers.Window) {
        debugger;
      }
      if (node.treeScope_) return node.treeScope_;
      var parent = node.parentNode;
      var treeScope;
      if (parent) treeScope = getTreeScope(parent); else treeScope = new TreeScope(node, null);
      return node.treeScope_ = treeScope;
    }
    scope.TreeScope = TreeScope;
    scope.getTreeScope = getTreeScope;
    scope.setTreeScope = setTreeScope;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;
    var getTreeScope = scope.getTreeScope;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var setWrapper = scope.setWrapper;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var unwrap = scope.unwrap;
    var wrap = scope.wrap;
    var wrappers = scope.wrappers;
    var wrappedFuns = new WeakMap();
    var listenersTable = new WeakMap();
    var handledEventsTable = new WeakMap();
    var currentlyDispatchingEvents = new WeakMap();
    var targetTable = new WeakMap();
    var currentTargetTable = new WeakMap();
    var relatedTargetTable = new WeakMap();
    var eventPhaseTable = new WeakMap();
    var stopPropagationTable = new WeakMap();
    var stopImmediatePropagationTable = new WeakMap();
    var eventHandlersTable = new WeakMap();
    var eventPathTable = new WeakMap();
    function isShadowRoot(node) {
      return node instanceof wrappers.ShadowRoot;
    }
    function rootOfNode(node) {
      return getTreeScope(node).root;
    }
    function getEventPath(node, event) {
      var path = [];
      var current = node;
      path.push(current);
      while (current) {
        var destinationInsertionPoints = getDestinationInsertionPoints(current);
        if (destinationInsertionPoints && destinationInsertionPoints.length > 0) {
          for (var i = 0; i < destinationInsertionPoints.length; i++) {
            var insertionPoint = destinationInsertionPoints[i];
            if (isShadowInsertionPoint(insertionPoint)) {
              var shadowRoot = rootOfNode(insertionPoint);
              var olderShadowRoot = shadowRoot.olderShadowRoot;
              if (olderShadowRoot) path.push(olderShadowRoot);
            }
            path.push(insertionPoint);
          }
          current = destinationInsertionPoints[destinationInsertionPoints.length - 1];
        } else {
          if (isShadowRoot(current)) {
            if (inSameTree(node, current) && eventMustBeStopped(event)) {
              break;
            }
            current = current.host;
            path.push(current);
          } else {
            current = current.parentNode;
            if (current) path.push(current);
          }
        }
      }
      return path;
    }
    function eventMustBeStopped(event) {
      if (!event) return false;
      switch (event.type) {
       case "abort":
       case "error":
       case "select":
       case "change":
       case "load":
       case "reset":
       case "resize":
       case "scroll":
       case "selectstart":
        return true;
      }
      return false;
    }
    function isShadowInsertionPoint(node) {
      return node instanceof HTMLShadowElement;
    }
    function getDestinationInsertionPoints(node) {
      return scope.getDestinationInsertionPoints(node);
    }
    function eventRetargetting(path, currentTarget) {
      if (path.length === 0) return currentTarget;
      if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;
      var currentTargetTree = getTreeScope(currentTarget);
      var originalTarget = path[0];
      var originalTargetTree = getTreeScope(originalTarget);
      var relativeTargetTree = lowestCommonInclusiveAncestor(currentTargetTree, originalTargetTree);
      for (var i = 0; i < path.length; i++) {
        var node = path[i];
        if (getTreeScope(node) === relativeTargetTree) return node;
      }
      return path[path.length - 1];
    }
    function getTreeScopeAncestors(treeScope) {
      var ancestors = [];
      for (;treeScope; treeScope = treeScope.parent) {
        ancestors.push(treeScope);
      }
      return ancestors;
    }
    function lowestCommonInclusiveAncestor(tsA, tsB) {
      var ancestorsA = getTreeScopeAncestors(tsA);
      var ancestorsB = getTreeScopeAncestors(tsB);
      var result = null;
      while (ancestorsA.length > 0 && ancestorsB.length > 0) {
        var a = ancestorsA.pop();
        var b = ancestorsB.pop();
        if (a === b) result = a; else break;
      }
      return result;
    }
    function getTreeScopeRoot(ts) {
      if (!ts.parent) return ts;
      return getTreeScopeRoot(ts.parent);
    }
    function relatedTargetResolution(event, currentTarget, relatedTarget) {
      if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;
      var currentTargetTree = getTreeScope(currentTarget);
      var relatedTargetTree = getTreeScope(relatedTarget);
      var relatedTargetEventPath = getEventPath(relatedTarget, event);
      var lowestCommonAncestorTree;
      var lowestCommonAncestorTree = lowestCommonInclusiveAncestor(currentTargetTree, relatedTargetTree);
      if (!lowestCommonAncestorTree) lowestCommonAncestorTree = relatedTargetTree.root;
      for (var commonAncestorTree = lowestCommonAncestorTree; commonAncestorTree; commonAncestorTree = commonAncestorTree.parent) {
        var adjustedRelatedTarget;
        for (var i = 0; i < relatedTargetEventPath.length; i++) {
          var node = relatedTargetEventPath[i];
          if (getTreeScope(node) === commonAncestorTree) return node;
        }
      }
      return null;
    }
    function inSameTree(a, b) {
      return getTreeScope(a) === getTreeScope(b);
    }
    var NONE = 0;
    var CAPTURING_PHASE = 1;
    var AT_TARGET = 2;
    var BUBBLING_PHASE = 3;
    var pendingError;
    function dispatchOriginalEvent(originalEvent) {
      if (handledEventsTable.get(originalEvent)) return;
      handledEventsTable.set(originalEvent, true);
      dispatchEvent(wrap(originalEvent), wrap(originalEvent.target));
      if (pendingError) {
        var err = pendingError;
        pendingError = null;
        throw err;
      }
    }
    function isLoadLikeEvent(event) {
      switch (event.type) {
       case "load":
       case "beforeunload":
       case "unload":
        return true;
      }
      return false;
    }
    function dispatchEvent(event, originalWrapperTarget) {
      if (currentlyDispatchingEvents.get(event)) throw new Error("InvalidStateError");
      currentlyDispatchingEvents.set(event, true);
      scope.renderAllPending();
      var eventPath;
      var overrideTarget;
      var win;
      if (isLoadLikeEvent(event) && !event.bubbles) {
        var doc = originalWrapperTarget;
        if (doc instanceof wrappers.Document && (win = doc.defaultView)) {
          overrideTarget = doc;
          eventPath = [];
        }
      }
      if (!eventPath) {
        if (originalWrapperTarget instanceof wrappers.Window) {
          win = originalWrapperTarget;
          eventPath = [];
        } else {
          eventPath = getEventPath(originalWrapperTarget, event);
          if (!isLoadLikeEvent(event)) {
            var doc = eventPath[eventPath.length - 1];
            if (doc instanceof wrappers.Document) win = doc.defaultView;
          }
        }
      }
      eventPathTable.set(event, eventPath);
      if (dispatchCapturing(event, eventPath, win, overrideTarget)) {
        if (dispatchAtTarget(event, eventPath, win, overrideTarget)) {
          dispatchBubbling(event, eventPath, win, overrideTarget);
        }
      }
      eventPhaseTable.set(event, NONE);
      currentTargetTable.delete(event, null);
      currentlyDispatchingEvents.delete(event);
      return event.defaultPrevented;
    }
    function dispatchCapturing(event, eventPath, win, overrideTarget) {
      var phase = CAPTURING_PHASE;
      if (win) {
        if (!invoke(win, event, phase, eventPath, overrideTarget)) return false;
      }
      for (var i = eventPath.length - 1; i > 0; i--) {
        if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return false;
      }
      return true;
    }
    function dispatchAtTarget(event, eventPath, win, overrideTarget) {
      var phase = AT_TARGET;
      var currentTarget = eventPath[0] || win;
      return invoke(currentTarget, event, phase, eventPath, overrideTarget);
    }
    function dispatchBubbling(event, eventPath, win, overrideTarget) {
      var phase = BUBBLING_PHASE;
      for (var i = 1; i < eventPath.length; i++) {
        if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return;
      }
      if (win && eventPath.length > 0) {
        invoke(win, event, phase, eventPath, overrideTarget);
      }
    }
    function invoke(currentTarget, event, phase, eventPath, overrideTarget) {
      var listeners = listenersTable.get(currentTarget);
      if (!listeners) return true;
      var target = overrideTarget || eventRetargetting(eventPath, currentTarget);
      if (target === currentTarget) {
        if (phase === CAPTURING_PHASE) return true;
        if (phase === BUBBLING_PHASE) phase = AT_TARGET;
      } else if (phase === BUBBLING_PHASE && !event.bubbles) {
        return true;
      }
      if ("relatedTarget" in event) {
        var originalEvent = unwrap(event);
        var unwrappedRelatedTarget = originalEvent.relatedTarget;
        if (unwrappedRelatedTarget) {
          if (unwrappedRelatedTarget instanceof Object && unwrappedRelatedTarget.addEventListener) {
            var relatedTarget = wrap(unwrappedRelatedTarget);
            var adjusted = relatedTargetResolution(event, currentTarget, relatedTarget);
            if (adjusted === target) return true;
          } else {
            adjusted = null;
          }
          relatedTargetTable.set(event, adjusted);
        }
      }
      eventPhaseTable.set(event, phase);
      var type = event.type;
      var anyRemoved = false;
      targetTable.set(event, target);
      currentTargetTable.set(event, currentTarget);
      listeners.depth++;
      for (var i = 0, len = listeners.length; i < len; i++) {
        var listener = listeners[i];
        if (listener.removed) {
          anyRemoved = true;
          continue;
        }
        if (listener.type !== type || !listener.capture && phase === CAPTURING_PHASE || listener.capture && phase === BUBBLING_PHASE) {
          continue;
        }
        try {
          if (typeof listener.handler === "function") listener.handler.call(currentTarget, event); else listener.handler.handleEvent(event);
          if (stopImmediatePropagationTable.get(event)) return false;
        } catch (ex) {
          if (!pendingError) pendingError = ex;
        }
      }
      listeners.depth--;
      if (anyRemoved && listeners.depth === 0) {
        var copy = listeners.slice();
        listeners.length = 0;
        for (var i = 0; i < copy.length; i++) {
          if (!copy[i].removed) listeners.push(copy[i]);
        }
      }
      return !stopPropagationTable.get(event);
    }
    function Listener(type, handler, capture) {
      this.type = type;
      this.handler = handler;
      this.capture = Boolean(capture);
    }
    Listener.prototype = {
      equals: function(that) {
        return this.handler === that.handler && this.type === that.type && this.capture === that.capture;
      },
      get removed() {
        return this.handler === null;
      },
      remove: function() {
        this.handler = null;
      }
    };
    var OriginalEvent = window.Event;
    OriginalEvent.prototype.polymerBlackList_ = {
      returnValue: true,
      keyLocation: true
    };
    function Event(type, options) {
      if (type instanceof OriginalEvent) {
        var impl = type;
        if (!OriginalBeforeUnloadEvent && impl.type === "beforeunload" && !(this instanceof BeforeUnloadEvent)) {
          return new BeforeUnloadEvent(impl);
        }
        setWrapper(impl, this);
      } else {
        return wrap(constructEvent(OriginalEvent, "Event", type, options));
      }
    }
    Event.prototype = {
      get target() {
        return targetTable.get(this);
      },
      get currentTarget() {
        return currentTargetTable.get(this);
      },
      get eventPhase() {
        return eventPhaseTable.get(this);
      },
      get path() {
        var eventPath = eventPathTable.get(this);
        if (!eventPath) return [];
        return eventPath.slice();
      },
      stopPropagation: function() {
        stopPropagationTable.set(this, true);
      },
      stopImmediatePropagation: function() {
        stopPropagationTable.set(this, true);
        stopImmediatePropagationTable.set(this, true);
      }
    };
    registerWrapper(OriginalEvent, Event, document.createEvent("Event"));
    function unwrapOptions(options) {
      if (!options || !options.relatedTarget) return options;
      return Object.create(options, {
        relatedTarget: {
          value: unwrap(options.relatedTarget)
        }
      });
    }
    function registerGenericEvent(name, SuperEvent, prototype) {
      var OriginalEvent = window[name];
      var GenericEvent = function(type, options) {
        if (type instanceof OriginalEvent) setWrapper(type, this); else return wrap(constructEvent(OriginalEvent, name, type, options));
      };
      GenericEvent.prototype = Object.create(SuperEvent.prototype);
      if (prototype) mixin(GenericEvent.prototype, prototype);
      if (OriginalEvent) {
        try {
          registerWrapper(OriginalEvent, GenericEvent, new OriginalEvent("temp"));
        } catch (ex) {
          registerWrapper(OriginalEvent, GenericEvent, document.createEvent(name));
        }
      }
      return GenericEvent;
    }
    var UIEvent = registerGenericEvent("UIEvent", Event);
    var CustomEvent = registerGenericEvent("CustomEvent", Event);
    var relatedTargetProto = {
      get relatedTarget() {
        var relatedTarget = relatedTargetTable.get(this);
        if (relatedTarget !== undefined) return relatedTarget;
        return wrap(unwrap(this).relatedTarget);
      }
    };
    function getInitFunction(name, relatedTargetIndex) {
      return function() {
        arguments[relatedTargetIndex] = unwrap(arguments[relatedTargetIndex]);
        var impl = unwrap(this);
        impl[name].apply(impl, arguments);
      };
    }
    var mouseEventProto = mixin({
      initMouseEvent: getInitFunction("initMouseEvent", 14)
    }, relatedTargetProto);
    var focusEventProto = mixin({
      initFocusEvent: getInitFunction("initFocusEvent", 5)
    }, relatedTargetProto);
    var MouseEvent = registerGenericEvent("MouseEvent", UIEvent, mouseEventProto);
    var FocusEvent = registerGenericEvent("FocusEvent", UIEvent, focusEventProto);
    var defaultInitDicts = Object.create(null);
    var supportsEventConstructors = function() {
      try {
        new window.FocusEvent("focus");
      } catch (ex) {
        return false;
      }
      return true;
    }();
    function constructEvent(OriginalEvent, name, type, options) {
      if (supportsEventConstructors) return new OriginalEvent(type, unwrapOptions(options));
      var event = unwrap(document.createEvent(name));
      var defaultDict = defaultInitDicts[name];
      var args = [ type ];
      Object.keys(defaultDict).forEach(function(key) {
        var v = options != null && key in options ? options[key] : defaultDict[key];
        if (key === "relatedTarget") v = unwrap(v);
        args.push(v);
      });
      event["init" + name].apply(event, args);
      return event;
    }
    if (!supportsEventConstructors) {
      var configureEventConstructor = function(name, initDict, superName) {
        if (superName) {
          var superDict = defaultInitDicts[superName];
          initDict = mixin(mixin({}, superDict), initDict);
        }
        defaultInitDicts[name] = initDict;
      };
      configureEventConstructor("Event", {
        bubbles: false,
        cancelable: false
      });
      configureEventConstructor("CustomEvent", {
        detail: null
      }, "Event");
      configureEventConstructor("UIEvent", {
        view: null,
        detail: 0
      }, "Event");
      configureEventConstructor("MouseEvent", {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        metaKey: false,
        button: 0,
        relatedTarget: null
      }, "UIEvent");
      configureEventConstructor("FocusEvent", {
        relatedTarget: null
      }, "UIEvent");
    }
    var OriginalBeforeUnloadEvent = window.BeforeUnloadEvent;
    function BeforeUnloadEvent(impl) {
      Event.call(this, impl);
    }
    BeforeUnloadEvent.prototype = Object.create(Event.prototype);
    mixin(BeforeUnloadEvent.prototype, {
      get returnValue() {
        return unsafeUnwrap(this).returnValue;
      },
      set returnValue(v) {
        unsafeUnwrap(this).returnValue = v;
      }
    });
    if (OriginalBeforeUnloadEvent) registerWrapper(OriginalBeforeUnloadEvent, BeforeUnloadEvent);
    function isValidListener(fun) {
      if (typeof fun === "function") return true;
      return fun && fun.handleEvent;
    }
    function isMutationEvent(type) {
      switch (type) {
       case "DOMAttrModified":
       case "DOMAttributeNameChanged":
       case "DOMCharacterDataModified":
       case "DOMElementNameChanged":
       case "DOMNodeInserted":
       case "DOMNodeInsertedIntoDocument":
       case "DOMNodeRemoved":
       case "DOMNodeRemovedFromDocument":
       case "DOMSubtreeModified":
        return true;
      }
      return false;
    }
    var OriginalEventTarget = window.EventTarget;
    function EventTarget(impl) {
      setWrapper(impl, this);
    }
    var methodNames = [ "addEventListener", "removeEventListener", "dispatchEvent" ];
    [ Node, Window ].forEach(function(constructor) {
      var p = constructor.prototype;
      methodNames.forEach(function(name) {
        Object.defineProperty(p, name + "_", {
          value: p[name]
        });
      });
    });
    function getTargetToListenAt(wrapper) {
      if (wrapper instanceof wrappers.ShadowRoot) wrapper = wrapper.host;
      return unwrap(wrapper);
    }
    EventTarget.prototype = {
      addEventListener: function(type, fun, capture) {
        if (!isValidListener(fun) || isMutationEvent(type)) return;
        var listener = new Listener(type, fun, capture);
        var listeners = listenersTable.get(this);
        if (!listeners) {
          listeners = [];
          listeners.depth = 0;
          listenersTable.set(this, listeners);
        } else {
          for (var i = 0; i < listeners.length; i++) {
            if (listener.equals(listeners[i])) return;
          }
        }
        listeners.push(listener);
        var target = getTargetToListenAt(this);
        target.addEventListener_(type, dispatchOriginalEvent, true);
      },
      removeEventListener: function(type, fun, capture) {
        capture = Boolean(capture);
        var listeners = listenersTable.get(this);
        if (!listeners) return;
        var count = 0, found = false;
        for (var i = 0; i < listeners.length; i++) {
          if (listeners[i].type === type && listeners[i].capture === capture) {
            count++;
            if (listeners[i].handler === fun) {
              found = true;
              listeners[i].remove();
            }
          }
        }
        if (found && count === 1) {
          var target = getTargetToListenAt(this);
          target.removeEventListener_(type, dispatchOriginalEvent, true);
        }
      },
      dispatchEvent: function(event) {
        var nativeEvent = unwrap(event);
        var eventType = nativeEvent.type;
        handledEventsTable.set(nativeEvent, false);
        scope.renderAllPending();
        var tempListener;
        if (!hasListenerInAncestors(this, eventType)) {
          tempListener = function() {};
          this.addEventListener(eventType, tempListener, true);
        }
        try {
          return unwrap(this).dispatchEvent_(nativeEvent);
        } finally {
          if (tempListener) this.removeEventListener(eventType, tempListener, true);
        }
      }
    };
    function hasListener(node, type) {
      var listeners = listenersTable.get(node);
      if (listeners) {
        for (var i = 0; i < listeners.length; i++) {
          if (!listeners[i].removed && listeners[i].type === type) return true;
        }
      }
      return false;
    }
    function hasListenerInAncestors(target, type) {
      for (var node = unwrap(target); node; node = node.parentNode) {
        if (hasListener(wrap(node), type)) return true;
      }
      return false;
    }
    if (OriginalEventTarget) registerWrapper(OriginalEventTarget, EventTarget);
    function wrapEventTargetMethods(constructors) {
      forwardMethodsToWrapper(constructors, methodNames);
    }
    var originalElementFromPoint = document.elementFromPoint;
    function elementFromPoint(self, document, x, y) {
      scope.renderAllPending();
      var element = wrap(originalElementFromPoint.call(unsafeUnwrap(document), x, y));
      if (!element) return null;
      var path = getEventPath(element, null);
      var idx = path.lastIndexOf(self);
      if (idx == -1) return null; else path = path.slice(0, idx);
      return eventRetargetting(path, self);
    }
    function getEventHandlerGetter(name) {
      return function() {
        var inlineEventHandlers = eventHandlersTable.get(this);
        return inlineEventHandlers && inlineEventHandlers[name] && inlineEventHandlers[name].value || null;
      };
    }
    function getEventHandlerSetter(name) {
      var eventType = name.slice(2);
      return function(value) {
        var inlineEventHandlers = eventHandlersTable.get(this);
        if (!inlineEventHandlers) {
          inlineEventHandlers = Object.create(null);
          eventHandlersTable.set(this, inlineEventHandlers);
        }
        var old = inlineEventHandlers[name];
        if (old) this.removeEventListener(eventType, old.wrapped, false);
        if (typeof value === "function") {
          var wrapped = function(e) {
            var rv = value.call(this, e);
            if (rv === false) e.preventDefault(); else if (name === "onbeforeunload" && typeof rv === "string") e.returnValue = rv;
          };
          this.addEventListener(eventType, wrapped, false);
          inlineEventHandlers[name] = {
            value: value,
            wrapped: wrapped
          };
        }
      };
    }
    scope.elementFromPoint = elementFromPoint;
    scope.getEventHandlerGetter = getEventHandlerGetter;
    scope.getEventHandlerSetter = getEventHandlerSetter;
    scope.wrapEventTargetMethods = wrapEventTargetMethods;
    scope.wrappers.BeforeUnloadEvent = BeforeUnloadEvent;
    scope.wrappers.CustomEvent = CustomEvent;
    scope.wrappers.Event = Event;
    scope.wrappers.EventTarget = EventTarget;
    scope.wrappers.FocusEvent = FocusEvent;
    scope.wrappers.MouseEvent = MouseEvent;
    scope.wrappers.UIEvent = UIEvent;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var UIEvent = scope.wrappers.UIEvent;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var setWrapper = scope.setWrapper;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var wrap = scope.wrap;
    var OriginalTouchEvent = window.TouchEvent;
    if (!OriginalTouchEvent) return;
    var nativeEvent;
    try {
      nativeEvent = document.createEvent("TouchEvent");
    } catch (ex) {
      return;
    }
    var nonEnumDescriptor = {
      enumerable: false
    };
    function nonEnum(obj, prop) {
      Object.defineProperty(obj, prop, nonEnumDescriptor);
    }
    function Touch(impl) {
      setWrapper(impl, this);
    }
    Touch.prototype = {
      get target() {
        return wrap(unsafeUnwrap(this).target);
      }
    };
    var descr = {
      configurable: true,
      enumerable: true,
      get: null
    };
    [ "clientX", "clientY", "screenX", "screenY", "pageX", "pageY", "identifier", "webkitRadiusX", "webkitRadiusY", "webkitRotationAngle", "webkitForce" ].forEach(function(name) {
      descr.get = function() {
        return unsafeUnwrap(this)[name];
      };
      Object.defineProperty(Touch.prototype, name, descr);
    });
    function TouchList() {
      this.length = 0;
      nonEnum(this, "length");
    }
    TouchList.prototype = {
      item: function(index) {
        return this[index];
      }
    };
    function wrapTouchList(nativeTouchList) {
      var list = new TouchList();
      for (var i = 0; i < nativeTouchList.length; i++) {
        list[i] = new Touch(nativeTouchList[i]);
      }
      list.length = i;
      return list;
    }
    function TouchEvent(impl) {
      UIEvent.call(this, impl);
    }
    TouchEvent.prototype = Object.create(UIEvent.prototype);
    mixin(TouchEvent.prototype, {
      get touches() {
        return wrapTouchList(unsafeUnwrap(this).touches);
      },
      get targetTouches() {
        return wrapTouchList(unsafeUnwrap(this).targetTouches);
      },
      get changedTouches() {
        return wrapTouchList(unsafeUnwrap(this).changedTouches);
      },
      initTouchEvent: function() {
        throw new Error("Not implemented");
      }
    });
    registerWrapper(OriginalTouchEvent, TouchEvent, nativeEvent);
    scope.wrappers.Touch = Touch;
    scope.wrappers.TouchEvent = TouchEvent;
    scope.wrappers.TouchList = TouchList;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var unsafeUnwrap = scope.unsafeUnwrap;
    var wrap = scope.wrap;
    var nonEnumDescriptor = {
      enumerable: false
    };
    function nonEnum(obj, prop) {
      Object.defineProperty(obj, prop, nonEnumDescriptor);
    }
    function NodeList() {
      this.length = 0;
      nonEnum(this, "length");
    }
    NodeList.prototype = {
      item: function(index) {
        return this[index];
      }
    };
    nonEnum(NodeList.prototype, "item");
    function wrapNodeList(list) {
      if (list == null) return list;
      var wrapperList = new NodeList();
      for (var i = 0, length = list.length; i < length; i++) {
        wrapperList[i] = wrap(list[i]);
      }
      wrapperList.length = length;
      return wrapperList;
    }
    function addWrapNodeListMethod(wrapperConstructor, name) {
      wrapperConstructor.prototype[name] = function() {
        return wrapNodeList(unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments));
      };
    }
    scope.wrappers.NodeList = NodeList;
    scope.addWrapNodeListMethod = addWrapNodeListMethod;
    scope.wrapNodeList = wrapNodeList;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    scope.wrapHTMLCollection = scope.wrapNodeList;
    scope.wrappers.HTMLCollection = scope.wrappers.NodeList;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var EventTarget = scope.wrappers.EventTarget;
    var NodeList = scope.wrappers.NodeList;
    var TreeScope = scope.TreeScope;
    var assert = scope.assert;
    var defineWrapGetter = scope.defineWrapGetter;
    var enqueueMutation = scope.enqueueMutation;
    var getTreeScope = scope.getTreeScope;
    var isWrapper = scope.isWrapper;
    var mixin = scope.mixin;
    var registerTransientObservers = scope.registerTransientObservers;
    var registerWrapper = scope.registerWrapper;
    var setTreeScope = scope.setTreeScope;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var unwrap = scope.unwrap;
    var unwrapIfNeeded = scope.unwrapIfNeeded;
    var wrap = scope.wrap;
    var wrapIfNeeded = scope.wrapIfNeeded;
    var wrappers = scope.wrappers;
    function assertIsNodeWrapper(node) {
      assert(node instanceof Node);
    }
    function createOneElementNodeList(node) {
      var nodes = new NodeList();
      nodes[0] = node;
      nodes.length = 1;
      return nodes;
    }
    var surpressMutations = false;
    function enqueueRemovalForInsertedNodes(node, parent, nodes) {
      enqueueMutation(parent, "childList", {
        removedNodes: nodes,
        previousSibling: node.previousSibling,
        nextSibling: node.nextSibling
      });
    }
    function enqueueRemovalForInsertedDocumentFragment(df, nodes) {
      enqueueMutation(df, "childList", {
        removedNodes: nodes
      });
    }
    function collectNodes(node, parentNode, previousNode, nextNode) {
      if (node instanceof DocumentFragment) {
        var nodes = collectNodesForDocumentFragment(node);
        surpressMutations = true;
        for (var i = nodes.length - 1; i >= 0; i--) {
          node.removeChild(nodes[i]);
          nodes[i].parentNode_ = parentNode;
        }
        surpressMutations = false;
        for (var i = 0; i < nodes.length; i++) {
          nodes[i].previousSibling_ = nodes[i - 1] || previousNode;
          nodes[i].nextSibling_ = nodes[i + 1] || nextNode;
        }
        if (previousNode) previousNode.nextSibling_ = nodes[0];
        if (nextNode) nextNode.previousSibling_ = nodes[nodes.length - 1];
        return nodes;
      }
      var nodes = createOneElementNodeList(node);
      var oldParent = node.parentNode;
      if (oldParent) {
        oldParent.removeChild(node);
      }
      node.parentNode_ = parentNode;
      node.previousSibling_ = previousNode;
      node.nextSibling_ = nextNode;
      if (previousNode) previousNode.nextSibling_ = node;
      if (nextNode) nextNode.previousSibling_ = node;
      return nodes;
    }
    function collectNodesNative(node) {
      if (node instanceof DocumentFragment) return collectNodesForDocumentFragment(node);
      var nodes = createOneElementNodeList(node);
      var oldParent = node.parentNode;
      if (oldParent) enqueueRemovalForInsertedNodes(node, oldParent, nodes);
      return nodes;
    }
    function collectNodesForDocumentFragment(node) {
      var nodes = new NodeList();
      var i = 0;
      for (var child = node.firstChild; child; child = child.nextSibling) {
        nodes[i++] = child;
      }
      nodes.length = i;
      enqueueRemovalForInsertedDocumentFragment(node, nodes);
      return nodes;
    }
    function snapshotNodeList(nodeList) {
      return nodeList;
    }
    function nodeWasAdded(node, treeScope) {
      setTreeScope(node, treeScope);
      node.nodeIsInserted_();
    }
    function nodesWereAdded(nodes, parent) {
      var treeScope = getTreeScope(parent);
      for (var i = 0; i < nodes.length; i++) {
        nodeWasAdded(nodes[i], treeScope);
      }
    }
    function nodeWasRemoved(node) {
      setTreeScope(node, new TreeScope(node, null));
    }
    function nodesWereRemoved(nodes) {
      for (var i = 0; i < nodes.length; i++) {
        nodeWasRemoved(nodes[i]);
      }
    }
    function ensureSameOwnerDocument(parent, child) {
      var ownerDoc = parent.nodeType === Node.DOCUMENT_NODE ? parent : parent.ownerDocument;
      if (ownerDoc !== child.ownerDocument) ownerDoc.adoptNode(child);
    }
    function adoptNodesIfNeeded(owner, nodes) {
      if (!nodes.length) return;
      var ownerDoc = owner.ownerDocument;
      if (ownerDoc === nodes[0].ownerDocument) return;
      for (var i = 0; i < nodes.length; i++) {
        scope.adoptNodeNoRemove(nodes[i], ownerDoc);
      }
    }
    function unwrapNodesForInsertion(owner, nodes) {
      adoptNodesIfNeeded(owner, nodes);
      var length = nodes.length;
      if (length === 1) return unwrap(nodes[0]);
      var df = unwrap(owner.ownerDocument.createDocumentFragment());
      for (var i = 0; i < length; i++) {
        df.appendChild(unwrap(nodes[i]));
      }
      return df;
    }
    function clearChildNodes(wrapper) {
      if (wrapper.firstChild_ !== undefined) {
        var child = wrapper.firstChild_;
        while (child) {
          var tmp = child;
          child = child.nextSibling_;
          tmp.parentNode_ = tmp.previousSibling_ = tmp.nextSibling_ = undefined;
        }
      }
      wrapper.firstChild_ = wrapper.lastChild_ = undefined;
    }
    function removeAllChildNodes(wrapper) {
      if (wrapper.invalidateShadowRenderer()) {
        var childWrapper = wrapper.firstChild;
        while (childWrapper) {
          assert(childWrapper.parentNode === wrapper);
          var nextSibling = childWrapper.nextSibling;
          var childNode = unwrap(childWrapper);
          var parentNode = childNode.parentNode;
          if (parentNode) originalRemoveChild.call(parentNode, childNode);
          childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = null;
          childWrapper = nextSibling;
        }
        wrapper.firstChild_ = wrapper.lastChild_ = null;
      } else {
        var node = unwrap(wrapper);
        var child = node.firstChild;
        var nextSibling;
        while (child) {
          nextSibling = child.nextSibling;
          originalRemoveChild.call(node, child);
          child = nextSibling;
        }
      }
    }
    function invalidateParent(node) {
      var p = node.parentNode;
      return p && p.invalidateShadowRenderer();
    }
    function cleanupNodes(nodes) {
      for (var i = 0, n; i < nodes.length; i++) {
        n = nodes[i];
        n.parentNode.removeChild(n);
      }
    }
    var originalImportNode = document.importNode;
    var originalCloneNode = window.Node.prototype.cloneNode;
    function cloneNode(node, deep, opt_doc) {
      var clone;
      if (opt_doc) clone = wrap(originalImportNode.call(opt_doc, unsafeUnwrap(node), false)); else clone = wrap(originalCloneNode.call(unsafeUnwrap(node), false));
      if (deep) {
        for (var child = node.firstChild; child; child = child.nextSibling) {
          clone.appendChild(cloneNode(child, true, opt_doc));
        }
        if (node instanceof wrappers.HTMLTemplateElement) {
          var cloneContent = clone.content;
          for (var child = node.content.firstChild; child; child = child.nextSibling) {
            cloneContent.appendChild(cloneNode(child, true, opt_doc));
          }
        }
      }
      return clone;
    }
    function contains(self, child) {
      if (!child || getTreeScope(self) !== getTreeScope(child)) return false;
      for (var node = child; node; node = node.parentNode) {
        if (node === self) return true;
      }
      return false;
    }
    var OriginalNode = window.Node;
    function Node(original) {
      assert(original instanceof OriginalNode);
      EventTarget.call(this, original);
      this.parentNode_ = undefined;
      this.firstChild_ = undefined;
      this.lastChild_ = undefined;
      this.nextSibling_ = undefined;
      this.previousSibling_ = undefined;
      this.treeScope_ = undefined;
    }
    var OriginalDocumentFragment = window.DocumentFragment;
    var originalAppendChild = OriginalNode.prototype.appendChild;
    var originalCompareDocumentPosition = OriginalNode.prototype.compareDocumentPosition;
    var originalInsertBefore = OriginalNode.prototype.insertBefore;
    var originalRemoveChild = OriginalNode.prototype.removeChild;
    var originalReplaceChild = OriginalNode.prototype.replaceChild;
    var isIe = /Trident|Edge/.test(navigator.userAgent);
    var removeChildOriginalHelper = isIe ? function(parent, child) {
      try {
        originalRemoveChild.call(parent, child);
      } catch (ex) {
        if (!(parent instanceof OriginalDocumentFragment)) throw ex;
      }
    } : function(parent, child) {
      originalRemoveChild.call(parent, child);
    };
    Node.prototype = Object.create(EventTarget.prototype);
    mixin(Node.prototype, {
      appendChild: function(childWrapper) {
        return this.insertBefore(childWrapper, null);
      },
      insertBefore: function(childWrapper, refWrapper) {
        assertIsNodeWrapper(childWrapper);
        var refNode;
        if (refWrapper) {
          if (isWrapper(refWrapper)) {
            refNode = unwrap(refWrapper);
          } else {
            refNode = refWrapper;
            refWrapper = wrap(refNode);
          }
        } else {
          refWrapper = null;
          refNode = null;
        }
        refWrapper && assert(refWrapper.parentNode === this);
        var nodes;
        var previousNode = refWrapper ? refWrapper.previousSibling : this.lastChild;
        var useNative = !this.invalidateShadowRenderer() && !invalidateParent(childWrapper);
        if (useNative) nodes = collectNodesNative(childWrapper); else nodes = collectNodes(childWrapper, this, previousNode, refWrapper);
        if (useNative) {
          ensureSameOwnerDocument(this, childWrapper);
          clearChildNodes(this);
          originalInsertBefore.call(unsafeUnwrap(this), unwrap(childWrapper), refNode);
        } else {
          if (!previousNode) this.firstChild_ = nodes[0];
          if (!refWrapper) {
            this.lastChild_ = nodes[nodes.length - 1];
            if (this.firstChild_ === undefined) this.firstChild_ = this.firstChild;
          }
          var parentNode = refNode ? refNode.parentNode : unsafeUnwrap(this);
          if (parentNode) {
            originalInsertBefore.call(parentNode, unwrapNodesForInsertion(this, nodes), refNode);
          } else {
            adoptNodesIfNeeded(this, nodes);
          }
        }
        enqueueMutation(this, "childList", {
          addedNodes: nodes,
          nextSibling: refWrapper,
          previousSibling: previousNode
        });
        nodesWereAdded(nodes, this);
        return childWrapper;
      },
      removeChild: function(childWrapper) {
        assertIsNodeWrapper(childWrapper);
        if (childWrapper.parentNode !== this) {
          var found = false;
          var childNodes = this.childNodes;
          for (var ieChild = this.firstChild; ieChild; ieChild = ieChild.nextSibling) {
            if (ieChild === childWrapper) {
              found = true;
              break;
            }
          }
          if (!found) {
            throw new Error("NotFoundError");
          }
        }
        var childNode = unwrap(childWrapper);
        var childWrapperNextSibling = childWrapper.nextSibling;
        var childWrapperPreviousSibling = childWrapper.previousSibling;
        if (this.invalidateShadowRenderer()) {
          var thisFirstChild = this.firstChild;
          var thisLastChild = this.lastChild;
          var parentNode = childNode.parentNode;
          if (parentNode) removeChildOriginalHelper(parentNode, childNode);
          if (thisFirstChild === childWrapper) this.firstChild_ = childWrapperNextSibling;
          if (thisLastChild === childWrapper) this.lastChild_ = childWrapperPreviousSibling;
          if (childWrapperPreviousSibling) childWrapperPreviousSibling.nextSibling_ = childWrapperNextSibling;
          if (childWrapperNextSibling) {
            childWrapperNextSibling.previousSibling_ = childWrapperPreviousSibling;
          }
          childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = undefined;
        } else {
          clearChildNodes(this);
          removeChildOriginalHelper(unsafeUnwrap(this), childNode);
        }
        if (!surpressMutations) {
          enqueueMutation(this, "childList", {
            removedNodes: createOneElementNodeList(childWrapper),
            nextSibling: childWrapperNextSibling,
            previousSibling: childWrapperPreviousSibling
          });
        }
        registerTransientObservers(this, childWrapper);
        return childWrapper;
      },
      replaceChild: function(newChildWrapper, oldChildWrapper) {
        assertIsNodeWrapper(newChildWrapper);
        var oldChildNode;
        if (isWrapper(oldChildWrapper)) {
          oldChildNode = unwrap(oldChildWrapper);
        } else {
          oldChildNode = oldChildWrapper;
          oldChildWrapper = wrap(oldChildNode);
        }
        if (oldChildWrapper.parentNode !== this) {
          throw new Error("NotFoundError");
        }
        var nextNode = oldChildWrapper.nextSibling;
        var previousNode = oldChildWrapper.previousSibling;
        var nodes;
        var useNative = !this.invalidateShadowRenderer() && !invalidateParent(newChildWrapper);
        if (useNative) {
          nodes = collectNodesNative(newChildWrapper);
        } else {
          if (nextNode === newChildWrapper) nextNode = newChildWrapper.nextSibling;
          nodes = collectNodes(newChildWrapper, this, previousNode, nextNode);
        }
        if (!useNative) {
          if (this.firstChild === oldChildWrapper) this.firstChild_ = nodes[0];
          if (this.lastChild === oldChildWrapper) this.lastChild_ = nodes[nodes.length - 1];
          oldChildWrapper.previousSibling_ = oldChildWrapper.nextSibling_ = oldChildWrapper.parentNode_ = undefined;
          if (oldChildNode.parentNode) {
            originalReplaceChild.call(oldChildNode.parentNode, unwrapNodesForInsertion(this, nodes), oldChildNode);
          }
        } else {
          ensureSameOwnerDocument(this, newChildWrapper);
          clearChildNodes(this);
          originalReplaceChild.call(unsafeUnwrap(this), unwrap(newChildWrapper), oldChildNode);
        }
        enqueueMutation(this, "childList", {
          addedNodes: nodes,
          removedNodes: createOneElementNodeList(oldChildWrapper),
          nextSibling: nextNode,
          previousSibling: previousNode
        });
        nodeWasRemoved(oldChildWrapper);
        nodesWereAdded(nodes, this);
        return oldChildWrapper;
      },
      nodeIsInserted_: function() {
        for (var child = this.firstChild; child; child = child.nextSibling) {
          child.nodeIsInserted_();
        }
      },
      hasChildNodes: function() {
        return this.firstChild !== null;
      },
      get parentNode() {
        return this.parentNode_ !== undefined ? this.parentNode_ : wrap(unsafeUnwrap(this).parentNode);
      },
      get firstChild() {
        return this.firstChild_ !== undefined ? this.firstChild_ : wrap(unsafeUnwrap(this).firstChild);
      },
      get lastChild() {
        return this.lastChild_ !== undefined ? this.lastChild_ : wrap(unsafeUnwrap(this).lastChild);
      },
      get nextSibling() {
        return this.nextSibling_ !== undefined ? this.nextSibling_ : wrap(unsafeUnwrap(this).nextSibling);
      },
      get previousSibling() {
        return this.previousSibling_ !== undefined ? this.previousSibling_ : wrap(unsafeUnwrap(this).previousSibling);
      },
      get parentElement() {
        var p = this.parentNode;
        while (p && p.nodeType !== Node.ELEMENT_NODE) {
          p = p.parentNode;
        }
        return p;
      },
      get textContent() {
        var s = "";
        for (var child = this.firstChild; child; child = child.nextSibling) {
          if (child.nodeType != Node.COMMENT_NODE) {
            s += child.textContent;
          }
        }
        return s;
      },
      set textContent(textContent) {
        if (textContent == null) textContent = "";
        var removedNodes = snapshotNodeList(this.childNodes);
        if (this.invalidateShadowRenderer()) {
          removeAllChildNodes(this);
          if (textContent !== "") {
            var textNode = unsafeUnwrap(this).ownerDocument.createTextNode(textContent);
            this.appendChild(textNode);
          }
        } else {
          clearChildNodes(this);
          unsafeUnwrap(this).textContent = textContent;
        }
        var addedNodes = snapshotNodeList(this.childNodes);
        enqueueMutation(this, "childList", {
          addedNodes: addedNodes,
          removedNodes: removedNodes
        });
        nodesWereRemoved(removedNodes);
        nodesWereAdded(addedNodes, this);
      },
      get childNodes() {
        var wrapperList = new NodeList();
        var i = 0;
        for (var child = this.firstChild; child; child = child.nextSibling) {
          wrapperList[i++] = child;
        }
        wrapperList.length = i;
        return wrapperList;
      },
      cloneNode: function(deep) {
        return cloneNode(this, deep);
      },
      contains: function(child) {
        return contains(this, wrapIfNeeded(child));
      },
      compareDocumentPosition: function(otherNode) {
        return originalCompareDocumentPosition.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));
      },
      normalize: function() {
        var nodes = snapshotNodeList(this.childNodes);
        var remNodes = [];
        var s = "";
        var modNode;
        for (var i = 0, n; i < nodes.length; i++) {
          n = nodes[i];
          if (n.nodeType === Node.TEXT_NODE) {
            if (!modNode && !n.data.length) this.removeChild(n); else if (!modNode) modNode = n; else {
              s += n.data;
              remNodes.push(n);
            }
          } else {
            if (modNode && remNodes.length) {
              modNode.data += s;
              cleanupNodes(remNodes);
            }
            remNodes = [];
            s = "";
            modNode = null;
            if (n.childNodes.length) n.normalize();
          }
        }
        if (modNode && remNodes.length) {
          modNode.data += s;
          cleanupNodes(remNodes);
        }
      }
    });
    defineWrapGetter(Node, "ownerDocument");
    registerWrapper(OriginalNode, Node, document.createDocumentFragment());
    delete Node.prototype.querySelector;
    delete Node.prototype.querySelectorAll;
    Node.prototype = mixin(Object.create(EventTarget.prototype), Node.prototype);
    scope.cloneNode = cloneNode;
    scope.nodeWasAdded = nodeWasAdded;
    scope.nodeWasRemoved = nodeWasRemoved;
    scope.nodesWereAdded = nodesWereAdded;
    scope.nodesWereRemoved = nodesWereRemoved;
    scope.originalInsertBefore = originalInsertBefore;
    scope.originalRemoveChild = originalRemoveChild;
    scope.snapshotNodeList = snapshotNodeList;
    scope.wrappers.Node = Node;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLCollection = scope.wrappers.HTMLCollection;
    var NodeList = scope.wrappers.NodeList;
    var getTreeScope = scope.getTreeScope;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var wrap = scope.wrap;
    var originalDocumentQuerySelector = document.querySelector;
    var originalElementQuerySelector = document.documentElement.querySelector;
    var originalDocumentQuerySelectorAll = document.querySelectorAll;
    var originalElementQuerySelectorAll = document.documentElement.querySelectorAll;
    var originalDocumentGetElementsByTagName = document.getElementsByTagName;
    var originalElementGetElementsByTagName = document.documentElement.getElementsByTagName;
    var originalDocumentGetElementsByTagNameNS = document.getElementsByTagNameNS;
    var originalElementGetElementsByTagNameNS = document.documentElement.getElementsByTagNameNS;
    var OriginalElement = window.Element;
    var OriginalDocument = window.HTMLDocument || window.Document;
    function filterNodeList(list, index, result, deep) {
      var wrappedItem = null;
      var root = null;
      for (var i = 0, length = list.length; i < length; i++) {
        wrappedItem = wrap(list[i]);
        if (!deep && (root = getTreeScope(wrappedItem).root)) {
          if (root instanceof scope.wrappers.ShadowRoot) {
            continue;
          }
        }
        result[index++] = wrappedItem;
      }
      return index;
    }
    function shimSelector(selector) {
      return String(selector).replace(/\/deep\/|::shadow/g, " ");
    }
    function shimMatchesSelector(selector) {
      return String(selector).replace(/:host\(([^\s]+)\)/g, "$1").replace(/([^\s]):host/g, "$1").replace(":host", "*").replace(/\^|\/shadow\/|\/shadow-deep\/|::shadow|\/deep\/|::content/g, " ");
    }
    function findOne(node, selector) {
      var m, el = node.firstElementChild;
      while (el) {
        if (el.matches(selector)) return el;
        m = findOne(el, selector);
        if (m) return m;
        el = el.nextElementSibling;
      }
      return null;
    }
    function matchesSelector(el, selector) {
      return el.matches(selector);
    }
    var XHTML_NS = "http://www.w3.org/1999/xhtml";
    function matchesTagName(el, localName, localNameLowerCase) {
      var ln = el.localName;
      return ln === localName || ln === localNameLowerCase && el.namespaceURI === XHTML_NS;
    }
    function matchesEveryThing() {
      return true;
    }
    function matchesLocalNameOnly(el, ns, localName) {
      return el.localName === localName;
    }
    function matchesNameSpace(el, ns) {
      return el.namespaceURI === ns;
    }
    function matchesLocalNameNS(el, ns, localName) {
      return el.namespaceURI === ns && el.localName === localName;
    }
    function findElements(node, index, result, p, arg0, arg1) {
      var el = node.firstElementChild;
      while (el) {
        if (p(el, arg0, arg1)) result[index++] = el;
        index = findElements(el, index, result, p, arg0, arg1);
        el = el.nextElementSibling;
      }
      return index;
    }
    function querySelectorAllFiltered(p, index, result, selector, deep) {
      var target = unsafeUnwrap(this);
      var list;
      var root = getTreeScope(this).root;
      if (root instanceof scope.wrappers.ShadowRoot) {
        return findElements(this, index, result, p, selector, null);
      } else if (target instanceof OriginalElement) {
        list = originalElementQuerySelectorAll.call(target, selector);
      } else if (target instanceof OriginalDocument) {
        list = originalDocumentQuerySelectorAll.call(target, selector);
      } else {
        return findElements(this, index, result, p, selector, null);
      }
      return filterNodeList(list, index, result, deep);
    }
    var SelectorsInterface = {
      querySelector: function(selector) {
        var shimmed = shimSelector(selector);
        var deep = shimmed !== selector;
        selector = shimmed;
        var target = unsafeUnwrap(this);
        var wrappedItem;
        var root = getTreeScope(this).root;
        if (root instanceof scope.wrappers.ShadowRoot) {
          return findOne(this, selector);
        } else if (target instanceof OriginalElement) {
          wrappedItem = wrap(originalElementQuerySelector.call(target, selector));
        } else if (target instanceof OriginalDocument) {
          wrappedItem = wrap(originalDocumentQuerySelector.call(target, selector));
        } else {
          return findOne(this, selector);
        }
        if (!wrappedItem) {
          return wrappedItem;
        } else if (!deep && (root = getTreeScope(wrappedItem).root)) {
          if (root instanceof scope.wrappers.ShadowRoot) {
            return findOne(this, selector);
          }
        }
        return wrappedItem;
      },
      querySelectorAll: function(selector) {
        var shimmed = shimSelector(selector);
        var deep = shimmed !== selector;
        selector = shimmed;
        var result = new NodeList();
        result.length = querySelectorAllFiltered.call(this, matchesSelector, 0, result, selector, deep);
        return result;
      }
    };
    var MatchesInterface = {
      matches: function(selector) {
        selector = shimMatchesSelector(selector);
        return scope.originalMatches.call(unsafeUnwrap(this), selector);
      }
    };
    function getElementsByTagNameFiltered(p, index, result, localName, lowercase) {
      var target = unsafeUnwrap(this);
      var list;
      var root = getTreeScope(this).root;
      if (root instanceof scope.wrappers.ShadowRoot) {
        return findElements(this, index, result, p, localName, lowercase);
      } else if (target instanceof OriginalElement) {
        list = originalElementGetElementsByTagName.call(target, localName, lowercase);
      } else if (target instanceof OriginalDocument) {
        list = originalDocumentGetElementsByTagName.call(target, localName, lowercase);
      } else {
        return findElements(this, index, result, p, localName, lowercase);
      }
      return filterNodeList(list, index, result, false);
    }
    function getElementsByTagNameNSFiltered(p, index, result, ns, localName) {
      var target = unsafeUnwrap(this);
      var list;
      var root = getTreeScope(this).root;
      if (root instanceof scope.wrappers.ShadowRoot) {
        return findElements(this, index, result, p, ns, localName);
      } else if (target instanceof OriginalElement) {
        list = originalElementGetElementsByTagNameNS.call(target, ns, localName);
      } else if (target instanceof OriginalDocument) {
        list = originalDocumentGetElementsByTagNameNS.call(target, ns, localName);
      } else {
        return findElements(this, index, result, p, ns, localName);
      }
      return filterNodeList(list, index, result, false);
    }
    var GetElementsByInterface = {
      getElementsByTagName: function(localName) {
        var result = new HTMLCollection();
        var match = localName === "*" ? matchesEveryThing : matchesTagName;
        result.length = getElementsByTagNameFiltered.call(this, match, 0, result, localName, localName.toLowerCase());
        return result;
      },
      getElementsByClassName: function(className) {
        return this.querySelectorAll("." + className);
      },
      getElementsByTagNameNS: function(ns, localName) {
        var result = new HTMLCollection();
        var match = null;
        if (ns === "*") {
          match = localName === "*" ? matchesEveryThing : matchesLocalNameOnly;
        } else {
          match = localName === "*" ? matchesNameSpace : matchesLocalNameNS;
        }
        result.length = getElementsByTagNameNSFiltered.call(this, match, 0, result, ns || null, localName);
        return result;
      }
    };
    scope.GetElementsByInterface = GetElementsByInterface;
    scope.SelectorsInterface = SelectorsInterface;
    scope.MatchesInterface = MatchesInterface;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var NodeList = scope.wrappers.NodeList;
    function forwardElement(node) {
      while (node && node.nodeType !== Node.ELEMENT_NODE) {
        node = node.nextSibling;
      }
      return node;
    }
    function backwardsElement(node) {
      while (node && node.nodeType !== Node.ELEMENT_NODE) {
        node = node.previousSibling;
      }
      return node;
    }
    var ParentNodeInterface = {
      get firstElementChild() {
        return forwardElement(this.firstChild);
      },
      get lastElementChild() {
        return backwardsElement(this.lastChild);
      },
      get childElementCount() {
        var count = 0;
        for (var child = this.firstElementChild; child; child = child.nextElementSibling) {
          count++;
        }
        return count;
      },
      get children() {
        var wrapperList = new NodeList();
        var i = 0;
        for (var child = this.firstElementChild; child; child = child.nextElementSibling) {
          wrapperList[i++] = child;
        }
        wrapperList.length = i;
        return wrapperList;
      },
      remove: function() {
        var p = this.parentNode;
        if (p) p.removeChild(this);
      }
    };
    var ChildNodeInterface = {
      get nextElementSibling() {
        return forwardElement(this.nextSibling);
      },
      get previousElementSibling() {
        return backwardsElement(this.previousSibling);
      }
    };
    scope.ChildNodeInterface = ChildNodeInterface;
    scope.ParentNodeInterface = ParentNodeInterface;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var ChildNodeInterface = scope.ChildNodeInterface;
    var Node = scope.wrappers.Node;
    var enqueueMutation = scope.enqueueMutation;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var OriginalCharacterData = window.CharacterData;
    function CharacterData(node) {
      Node.call(this, node);
    }
    CharacterData.prototype = Object.create(Node.prototype);
    mixin(CharacterData.prototype, {
      get textContent() {
        return this.data;
      },
      set textContent(value) {
        this.data = value;
      },
      get data() {
        return unsafeUnwrap(this).data;
      },
      set data(value) {
        var oldValue = unsafeUnwrap(this).data;
        enqueueMutation(this, "characterData", {
          oldValue: oldValue
        });
        unsafeUnwrap(this).data = value;
      }
    });
    mixin(CharacterData.prototype, ChildNodeInterface);
    registerWrapper(OriginalCharacterData, CharacterData, document.createTextNode(""));
    scope.wrappers.CharacterData = CharacterData;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var CharacterData = scope.wrappers.CharacterData;
    var enqueueMutation = scope.enqueueMutation;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    function toUInt32(x) {
      return x >>> 0;
    }
    var OriginalText = window.Text;
    function Text(node) {
      CharacterData.call(this, node);
    }
    Text.prototype = Object.create(CharacterData.prototype);
    mixin(Text.prototype, {
      splitText: function(offset) {
        offset = toUInt32(offset);
        var s = this.data;
        if (offset > s.length) throw new Error("IndexSizeError");
        var head = s.slice(0, offset);
        var tail = s.slice(offset);
        this.data = head;
        var newTextNode = this.ownerDocument.createTextNode(tail);
        if (this.parentNode) this.parentNode.insertBefore(newTextNode, this.nextSibling);
        return newTextNode;
      }
    });
    registerWrapper(OriginalText, Text, document.createTextNode(""));
    scope.wrappers.Text = Text;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    if (!window.DOMTokenList) {
      console.warn("Missing DOMTokenList prototype, please include a " + "compatible classList polyfill such as http://goo.gl/uTcepH.");
      return;
    }
    var unsafeUnwrap = scope.unsafeUnwrap;
    var enqueueMutation = scope.enqueueMutation;
    function getClass(el) {
      return unsafeUnwrap(el).getAttribute("class");
    }
    function enqueueClassAttributeChange(el, oldValue) {
      enqueueMutation(el, "attributes", {
        name: "class",
        namespace: null,
        oldValue: oldValue
      });
    }
    function invalidateClass(el) {
      scope.invalidateRendererBasedOnAttribute(el, "class");
    }
    function changeClass(tokenList, method, args) {
      var ownerElement = tokenList.ownerElement_;
      if (ownerElement == null) {
        return method.apply(tokenList, args);
      }
      var oldValue = getClass(ownerElement);
      var retv = method.apply(tokenList, args);
      if (getClass(ownerElement) !== oldValue) {
        enqueueClassAttributeChange(ownerElement, oldValue);
        invalidateClass(ownerElement);
      }
      return retv;
    }
    var oldAdd = DOMTokenList.prototype.add;
    DOMTokenList.prototype.add = function() {
      changeClass(this, oldAdd, arguments);
    };
    var oldRemove = DOMTokenList.prototype.remove;
    DOMTokenList.prototype.remove = function() {
      changeClass(this, oldRemove, arguments);
    };
    var oldToggle = DOMTokenList.prototype.toggle;
    DOMTokenList.prototype.toggle = function() {
      return changeClass(this, oldToggle, arguments);
    };
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var ChildNodeInterface = scope.ChildNodeInterface;
    var GetElementsByInterface = scope.GetElementsByInterface;
    var Node = scope.wrappers.Node;
    var ParentNodeInterface = scope.ParentNodeInterface;
    var SelectorsInterface = scope.SelectorsInterface;
    var MatchesInterface = scope.MatchesInterface;
    var addWrapNodeListMethod = scope.addWrapNodeListMethod;
    var enqueueMutation = scope.enqueueMutation;
    var mixin = scope.mixin;
    var oneOf = scope.oneOf;
    var registerWrapper = scope.registerWrapper;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var wrappers = scope.wrappers;
    var OriginalElement = window.Element;
    var matchesNames = [ "matches", "mozMatchesSelector", "msMatchesSelector", "webkitMatchesSelector" ].filter(function(name) {
      return OriginalElement.prototype[name];
    });
    var matchesName = matchesNames[0];
    var originalMatches = OriginalElement.prototype[matchesName];
    function invalidateRendererBasedOnAttribute(element, name) {
      var p = element.parentNode;
      if (!p || !p.shadowRoot) return;
      var renderer = scope.getRendererForHost(p);
      if (renderer.dependsOnAttribute(name)) renderer.invalidate();
    }
    function enqueAttributeChange(element, name, oldValue) {
      enqueueMutation(element, "attributes", {
        name: name,
        namespace: null,
        oldValue: oldValue
      });
    }
    var classListTable = new WeakMap();
    function Element(node) {
      Node.call(this, node);
    }
    Element.prototype = Object.create(Node.prototype);
    mixin(Element.prototype, {
      createShadowRoot: function() {
        var newShadowRoot = new wrappers.ShadowRoot(this);
        unsafeUnwrap(this).polymerShadowRoot_ = newShadowRoot;
        var renderer = scope.getRendererForHost(this);
        renderer.invalidate();
        return newShadowRoot;
      },
      get shadowRoot() {
        return unsafeUnwrap(this).polymerShadowRoot_ || null;
      },
      setAttribute: function(name, value) {
        var oldValue = unsafeUnwrap(this).getAttribute(name);
        unsafeUnwrap(this).setAttribute(name, value);
        enqueAttributeChange(this, name, oldValue);
        invalidateRendererBasedOnAttribute(this, name);
      },
      removeAttribute: function(name) {
        var oldValue = unsafeUnwrap(this).getAttribute(name);
        unsafeUnwrap(this).removeAttribute(name);
        enqueAttributeChange(this, name, oldValue);
        invalidateRendererBasedOnAttribute(this, name);
      },
      get classList() {
        var list = classListTable.get(this);
        if (!list) {
          list = unsafeUnwrap(this).classList;
          if (!list) return;
          list.ownerElement_ = this;
          classListTable.set(this, list);
        }
        return list;
      },
      get className() {
        return unsafeUnwrap(this).className;
      },
      set className(v) {
        this.setAttribute("class", v);
      },
      get id() {
        return unsafeUnwrap(this).id;
      },
      set id(v) {
        this.setAttribute("id", v);
      }
    });
    matchesNames.forEach(function(name) {
      if (name !== "matches") {
        Element.prototype[name] = function(selector) {
          return this.matches(selector);
        };
      }
    });
    if (OriginalElement.prototype.webkitCreateShadowRoot) {
      Element.prototype.webkitCreateShadowRoot = Element.prototype.createShadowRoot;
    }
    mixin(Element.prototype, ChildNodeInterface);
    mixin(Element.prototype, GetElementsByInterface);
    mixin(Element.prototype, ParentNodeInterface);
    mixin(Element.prototype, SelectorsInterface);
    mixin(Element.prototype, MatchesInterface);
    registerWrapper(OriginalElement, Element, document.createElementNS(null, "x"));
    scope.invalidateRendererBasedOnAttribute = invalidateRendererBasedOnAttribute;
    scope.matchesNames = matchesNames;
    scope.originalMatches = originalMatches;
    scope.wrappers.Element = Element;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var Element = scope.wrappers.Element;
    var defineGetter = scope.defineGetter;
    var enqueueMutation = scope.enqueueMutation;
    var mixin = scope.mixin;
    var nodesWereAdded = scope.nodesWereAdded;
    var nodesWereRemoved = scope.nodesWereRemoved;
    var registerWrapper = scope.registerWrapper;
    var snapshotNodeList = scope.snapshotNodeList;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var unwrap = scope.unwrap;
    var wrap = scope.wrap;
    var wrappers = scope.wrappers;
    var escapeAttrRegExp = /[&\u00A0"]/g;
    var escapeDataRegExp = /[&\u00A0<>]/g;
    function escapeReplace(c) {
      switch (c) {
       case "&":
        return "&amp;";

       case "<":
        return "&lt;";

       case ">":
        return "&gt;";

       case '"':
        return "&quot;";

       case " ":
        return "&nbsp;";
      }
    }
    function escapeAttr(s) {
      return s.replace(escapeAttrRegExp, escapeReplace);
    }
    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
    function makeSet(arr) {
      var set = {};
      for (var i = 0; i < arr.length; i++) {
        set[arr[i]] = true;
      }
      return set;
    }
    var voidElements = makeSet([ "area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr" ]);
    var plaintextParents = makeSet([ "style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript" ]);
    function getOuterHTML(node, parentNode) {
      switch (node.nodeType) {
       case Node.ELEMENT_NODE:
        var tagName = node.tagName.toLowerCase();
        var s = "<" + tagName;
        var attrs = node.attributes;
        for (var i = 0, attr; attr = attrs[i]; i++) {
          s += " " + attr.name + '="' + escapeAttr(attr.value) + '"';
        }
        s += ">";
        if (voidElements[tagName]) return s;
        return s + getInnerHTML(node) + "</" + tagName + ">";

       case Node.TEXT_NODE:
        var data = node.data;
        if (parentNode && plaintextParents[parentNode.localName]) return data;
        return escapeData(data);

       case Node.COMMENT_NODE:
        return "<!--" + node.data + "-->";

       default:
        console.error(node);
        throw new Error("not implemented");
      }
    }
    function getInnerHTML(node) {
      if (node instanceof wrappers.HTMLTemplateElement) node = node.content;
      var s = "";
      for (var child = node.firstChild; child; child = child.nextSibling) {
        s += getOuterHTML(child, node);
      }
      return s;
    }
    function setInnerHTML(node, value, opt_tagName) {
      var tagName = opt_tagName || "div";
      node.textContent = "";
      var tempElement = unwrap(node.ownerDocument.createElement(tagName));
      tempElement.innerHTML = value;
      var firstChild;
      while (firstChild = tempElement.firstChild) {
        node.appendChild(wrap(firstChild));
      }
    }
    var oldIe = /MSIE/.test(navigator.userAgent);
    var OriginalHTMLElement = window.HTMLElement;
    var OriginalHTMLTemplateElement = window.HTMLTemplateElement;
    function HTMLElement(node) {
      Element.call(this, node);
    }
    HTMLElement.prototype = Object.create(Element.prototype);
    mixin(HTMLElement.prototype, {
      get innerHTML() {
        return getInnerHTML(this);
      },
      set innerHTML(value) {
        if (oldIe && plaintextParents[this.localName]) {
          this.textContent = value;
          return;
        }
        var removedNodes = snapshotNodeList(this.childNodes);
        if (this.invalidateShadowRenderer()) {
          if (this instanceof wrappers.HTMLTemplateElement) setInnerHTML(this.content, value); else setInnerHTML(this, value, this.tagName);
        } else if (!OriginalHTMLTemplateElement && this instanceof wrappers.HTMLTemplateElement) {
          setInnerHTML(this.content, value);
        } else {
          unsafeUnwrap(this).innerHTML = value;
        }
        var addedNodes = snapshotNodeList(this.childNodes);
        enqueueMutation(this, "childList", {
          addedNodes: addedNodes,
          removedNodes: removedNodes
        });
        nodesWereRemoved(removedNodes);
        nodesWereAdded(addedNodes, this);
      },
      get outerHTML() {
        return getOuterHTML(this, this.parentNode);
      },
      set outerHTML(value) {
        var p = this.parentNode;
        if (p) {
          p.invalidateShadowRenderer();
          var df = frag(p, value);
          p.replaceChild(df, this);
        }
      },
      insertAdjacentHTML: function(position, text) {
        var contextElement, refNode;
        switch (String(position).toLowerCase()) {
         case "beforebegin":
          contextElement = this.parentNode;
          refNode = this;
          break;

         case "afterend":
          contextElement = this.parentNode;
          refNode = this.nextSibling;
          break;

         case "afterbegin":
          contextElement = this;
          refNode = this.firstChild;
          break;

         case "beforeend":
          contextElement = this;
          refNode = null;
          break;

         default:
          return;
        }
        var df = frag(contextElement, text);
        contextElement.insertBefore(df, refNode);
      },
      get hidden() {
        return this.hasAttribute("hidden");
      },
      set hidden(v) {
        if (v) {
          this.setAttribute("hidden", "");
        } else {
          this.removeAttribute("hidden");
        }
      }
    });
    function frag(contextElement, html) {
      var p = unwrap(contextElement.cloneNode(false));
      p.innerHTML = html;
      var df = unwrap(document.createDocumentFragment());
      var c;
      while (c = p.firstChild) {
        df.appendChild(c);
      }
      return wrap(df);
    }
    function getter(name) {
      return function() {
        scope.renderAllPending();
        return unsafeUnwrap(this)[name];
      };
    }
    function getterRequiresRendering(name) {
      defineGetter(HTMLElement, name, getter(name));
    }
    [ "clientHeight", "clientLeft", "clientTop", "clientWidth", "offsetHeight", "offsetLeft", "offsetTop", "offsetWidth", "scrollHeight", "scrollWidth" ].forEach(getterRequiresRendering);
    function getterAndSetterRequiresRendering(name) {
      Object.defineProperty(HTMLElement.prototype, name, {
        get: getter(name),
        set: function(v) {
          scope.renderAllPending();
          unsafeUnwrap(this)[name] = v;
        },
        configurable: true,
        enumerable: true
      });
    }
    [ "scrollLeft", "scrollTop" ].forEach(getterAndSetterRequiresRendering);
    function methodRequiresRendering(name) {
      Object.defineProperty(HTMLElement.prototype, name, {
        value: function() {
          scope.renderAllPending();
          return unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments);
        },
        configurable: true,
        enumerable: true
      });
    }
    [ "getBoundingClientRect", "getClientRects", "scrollIntoView" ].forEach(methodRequiresRendering);
    registerWrapper(OriginalHTMLElement, HTMLElement, document.createElement("b"));
    scope.wrappers.HTMLElement = HTMLElement;
    scope.getInnerHTML = getInnerHTML;
    scope.setInnerHTML = setInnerHTML;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLElement = scope.wrappers.HTMLElement;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var wrap = scope.wrap;
    var OriginalHTMLCanvasElement = window.HTMLCanvasElement;
    function HTMLCanvasElement(node) {
      HTMLElement.call(this, node);
    }
    HTMLCanvasElement.prototype = Object.create(HTMLElement.prototype);
    mixin(HTMLCanvasElement.prototype, {
      getContext: function() {
        var context = unsafeUnwrap(this).getContext.apply(unsafeUnwrap(this), arguments);
        return context && wrap(context);
      }
    });
    registerWrapper(OriginalHTMLCanvasElement, HTMLCanvasElement, document.createElement("canvas"));
    scope.wrappers.HTMLCanvasElement = HTMLCanvasElement;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLElement = scope.wrappers.HTMLElement;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var OriginalHTMLContentElement = window.HTMLContentElement;
    function HTMLContentElement(node) {
      HTMLElement.call(this, node);
    }
    HTMLContentElement.prototype = Object.create(HTMLElement.prototype);
    mixin(HTMLContentElement.prototype, {
      constructor: HTMLContentElement,
      get select() {
        return this.getAttribute("select");
      },
      set select(value) {
        this.setAttribute("select", value);
      },
      setAttribute: function(n, v) {
        HTMLElement.prototype.setAttribute.call(this, n, v);
        if (String(n).toLowerCase() === "select") this.invalidateShadowRenderer(true);
      }
    });
    if (OriginalHTMLContentElement) registerWrapper(OriginalHTMLContentElement, HTMLContentElement);
    scope.wrappers.HTMLContentElement = HTMLContentElement;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLElement = scope.wrappers.HTMLElement;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var wrapHTMLCollection = scope.wrapHTMLCollection;
    var unwrap = scope.unwrap;
    var OriginalHTMLFormElement = window.HTMLFormElement;
    function HTMLFormElement(node) {
      HTMLElement.call(this, node);
    }
    HTMLFormElement.prototype = Object.create(HTMLElement.prototype);
    mixin(HTMLFormElement.prototype, {
      get elements() {
        return wrapHTMLCollection(unwrap(this).elements);
      }
    });
    registerWrapper(OriginalHTMLFormElement, HTMLFormElement, document.createElement("form"));
    scope.wrappers.HTMLFormElement = HTMLFormElement;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLElement = scope.wrappers.HTMLElement;
    var registerWrapper = scope.registerWrapper;
    var unwrap = scope.unwrap;
    var rewrap = scope.rewrap;
    var OriginalHTMLImageElement = window.HTMLImageElement;
    function HTMLImageElement(node) {
      HTMLElement.call(this, node);
    }
    HTMLImageElement.prototype = Object.create(HTMLElement.prototype);
    registerWrapper(OriginalHTMLImageElement, HTMLImageElement, document.createElement("img"));
    function Image(width, height) {
      if (!(this instanceof Image)) {
        throw new TypeError("DOM object constructor cannot be called as a function.");
      }
      var node = unwrap(document.createElement("img"));
      HTMLElement.call(this, node);
      rewrap(node, this);
      if (width !== undefined) node.width = width;
      if (height !== undefined) node.height = height;
    }
    Image.prototype = HTMLImageElement.prototype;
    scope.wrappers.HTMLImageElement = HTMLImageElement;
    scope.wrappers.Image = Image;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLElement = scope.wrappers.HTMLElement;
    var mixin = scope.mixin;
    var NodeList = scope.wrappers.NodeList;
    var registerWrapper = scope.registerWrapper;
    var OriginalHTMLShadowElement = window.HTMLShadowElement;
    function HTMLShadowElement(node) {
      HTMLElement.call(this, node);
    }
    HTMLShadowElement.prototype = Object.create(HTMLElement.prototype);
    HTMLShadowElement.prototype.constructor = HTMLShadowElement;
    if (OriginalHTMLShadowElement) registerWrapper(OriginalHTMLShadowElement, HTMLShadowElement);
    scope.wrappers.HTMLShadowElement = HTMLShadowElement;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLElement = scope.wrappers.HTMLElement;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var unwrap = scope.unwrap;
    var wrap = scope.wrap;
    var contentTable = new WeakMap();
    var templateContentsOwnerTable = new WeakMap();
    function getTemplateContentsOwner(doc) {
      if (!doc.defaultView) return doc;
      var d = templateContentsOwnerTable.get(doc);
      if (!d) {
        d = doc.implementation.createHTMLDocument("");
        while (d.lastChild) {
          d.removeChild(d.lastChild);
        }
        templateContentsOwnerTable.set(doc, d);
      }
      return d;
    }
    function extractContent(templateElement) {
      var doc = getTemplateContentsOwner(templateElement.ownerDocument);
      var df = unwrap(doc.createDocumentFragment());
      var child;
      while (child = templateElement.firstChild) {
        df.appendChild(child);
      }
      return df;
    }
    var OriginalHTMLTemplateElement = window.HTMLTemplateElement;
    function HTMLTemplateElement(node) {
      HTMLElement.call(this, node);
      if (!OriginalHTMLTemplateElement) {
        var content = extractContent(node);
        contentTable.set(this, wrap(content));
      }
    }
    HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);
    mixin(HTMLTemplateElement.prototype, {
      constructor: HTMLTemplateElement,
      get content() {
        if (OriginalHTMLTemplateElement) return wrap(unsafeUnwrap(this).content);
        return contentTable.get(this);
      }
    });
    if (OriginalHTMLTemplateElement) registerWrapper(OriginalHTMLTemplateElement, HTMLTemplateElement);
    scope.wrappers.HTMLTemplateElement = HTMLTemplateElement;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLElement = scope.wrappers.HTMLElement;
    var registerWrapper = scope.registerWrapper;
    var OriginalHTMLMediaElement = window.HTMLMediaElement;
    if (!OriginalHTMLMediaElement) return;
    function HTMLMediaElement(node) {
      HTMLElement.call(this, node);
    }
    HTMLMediaElement.prototype = Object.create(HTMLElement.prototype);
    registerWrapper(OriginalHTMLMediaElement, HTMLMediaElement, document.createElement("audio"));
    scope.wrappers.HTMLMediaElement = HTMLMediaElement;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLMediaElement = scope.wrappers.HTMLMediaElement;
    var registerWrapper = scope.registerWrapper;
    var unwrap = scope.unwrap;
    var rewrap = scope.rewrap;
    var OriginalHTMLAudioElement = window.HTMLAudioElement;
    if (!OriginalHTMLAudioElement) return;
    function HTMLAudioElement(node) {
      HTMLMediaElement.call(this, node);
    }
    HTMLAudioElement.prototype = Object.create(HTMLMediaElement.prototype);
    registerWrapper(OriginalHTMLAudioElement, HTMLAudioElement, document.createElement("audio"));
    function Audio(src) {
      if (!(this instanceof Audio)) {
        throw new TypeError("DOM object constructor cannot be called as a function.");
      }
      var node = unwrap(document.createElement("audio"));
      HTMLMediaElement.call(this, node);
      rewrap(node, this);
      node.setAttribute("preload", "auto");
      if (src !== undefined) node.setAttribute("src", src);
    }
    Audio.prototype = HTMLAudioElement.prototype;
    scope.wrappers.HTMLAudioElement = HTMLAudioElement;
    scope.wrappers.Audio = Audio;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLElement = scope.wrappers.HTMLElement;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var rewrap = scope.rewrap;
    var unwrap = scope.unwrap;
    var wrap = scope.wrap;
    var OriginalHTMLOptionElement = window.HTMLOptionElement;
    function trimText(s) {
      return s.replace(/\s+/g, " ").trim();
    }
    function HTMLOptionElement(node) {
      HTMLElement.call(this, node);
    }
    HTMLOptionElement.prototype = Object.create(HTMLElement.prototype);
    mixin(HTMLOptionElement.prototype, {
      get text() {
        return trimText(this.textContent);
      },
      set text(value) {
        this.textContent = trimText(String(value));
      },
      get form() {
        return wrap(unwrap(this).form);
      }
    });
    registerWrapper(OriginalHTMLOptionElement, HTMLOptionElement, document.createElement("option"));
    function Option(text, value, defaultSelected, selected) {
      if (!(this instanceof Option)) {
        throw new TypeError("DOM object constructor cannot be called as a function.");
      }
      var node = unwrap(document.createElement("option"));
      HTMLElement.call(this, node);
      rewrap(node, this);
      if (text !== undefined) node.text = text;
      if (value !== undefined) node.setAttribute("value", value);
      if (defaultSelected === true) node.setAttribute("selected", "");
      node.selected = selected === true;
    }
    Option.prototype = HTMLOptionElement.prototype;
    scope.wrappers.HTMLOptionElement = HTMLOptionElement;
    scope.wrappers.Option = Option;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLElement = scope.wrappers.HTMLElement;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var unwrap = scope.unwrap;
    var wrap = scope.wrap;
    var OriginalHTMLSelectElement = window.HTMLSelectElement;
    function HTMLSelectElement(node) {
      HTMLElement.call(this, node);
    }
    HTMLSelectElement.prototype = Object.create(HTMLElement.prototype);
    mixin(HTMLSelectElement.prototype, {
      add: function(element, before) {
        if (typeof before === "object") before = unwrap(before);
        unwrap(this).add(unwrap(element), before);
      },
      remove: function(indexOrNode) {
        if (indexOrNode === undefined) {
          HTMLElement.prototype.remove.call(this);
          return;
        }
        if (typeof indexOrNode === "object") indexOrNode = unwrap(indexOrNode);
        unwrap(this).remove(indexOrNode);
      },
      get form() {
        return wrap(unwrap(this).form);
      }
    });
    registerWrapper(OriginalHTMLSelectElement, HTMLSelectElement, document.createElement("select"));
    scope.wrappers.HTMLSelectElement = HTMLSelectElement;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLElement = scope.wrappers.HTMLElement;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var unwrap = scope.unwrap;
    var wrap = scope.wrap;
    var wrapHTMLCollection = scope.wrapHTMLCollection;
    var OriginalHTMLTableElement = window.HTMLTableElement;
    function HTMLTableElement(node) {
      HTMLElement.call(this, node);
    }
    HTMLTableElement.prototype = Object.create(HTMLElement.prototype);
    mixin(HTMLTableElement.prototype, {
      get caption() {
        return wrap(unwrap(this).caption);
      },
      createCaption: function() {
        return wrap(unwrap(this).createCaption());
      },
      get tHead() {
        return wrap(unwrap(this).tHead);
      },
      createTHead: function() {
        return wrap(unwrap(this).createTHead());
      },
      createTFoot: function() {
        return wrap(unwrap(this).createTFoot());
      },
      get tFoot() {
        return wrap(unwrap(this).tFoot);
      },
      get tBodies() {
        return wrapHTMLCollection(unwrap(this).tBodies);
      },
      createTBody: function() {
        return wrap(unwrap(this).createTBody());
      },
      get rows() {
        return wrapHTMLCollection(unwrap(this).rows);
      },
      insertRow: function(index) {
        return wrap(unwrap(this).insertRow(index));
      }
    });
    registerWrapper(OriginalHTMLTableElement, HTMLTableElement, document.createElement("table"));
    scope.wrappers.HTMLTableElement = HTMLTableElement;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLElement = scope.wrappers.HTMLElement;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var wrapHTMLCollection = scope.wrapHTMLCollection;
    var unwrap = scope.unwrap;
    var wrap = scope.wrap;
    var OriginalHTMLTableSectionElement = window.HTMLTableSectionElement;
    function HTMLTableSectionElement(node) {
      HTMLElement.call(this, node);
    }
    HTMLTableSectionElement.prototype = Object.create(HTMLElement.prototype);
    mixin(HTMLTableSectionElement.prototype, {
      constructor: HTMLTableSectionElement,
      get rows() {
        return wrapHTMLCollection(unwrap(this).rows);
      },
      insertRow: function(index) {
        return wrap(unwrap(this).insertRow(index));
      }
    });
    registerWrapper(OriginalHTMLTableSectionElement, HTMLTableSectionElement, document.createElement("thead"));
    scope.wrappers.HTMLTableSectionElement = HTMLTableSectionElement;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLElement = scope.wrappers.HTMLElement;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var wrapHTMLCollection = scope.wrapHTMLCollection;
    var unwrap = scope.unwrap;
    var wrap = scope.wrap;
    var OriginalHTMLTableRowElement = window.HTMLTableRowElement;
    function HTMLTableRowElement(node) {
      HTMLElement.call(this, node);
    }
    HTMLTableRowElement.prototype = Object.create(HTMLElement.prototype);
    mixin(HTMLTableRowElement.prototype, {
      get cells() {
        return wrapHTMLCollection(unwrap(this).cells);
      },
      insertCell: function(index) {
        return wrap(unwrap(this).insertCell(index));
      }
    });
    registerWrapper(OriginalHTMLTableRowElement, HTMLTableRowElement, document.createElement("tr"));
    scope.wrappers.HTMLTableRowElement = HTMLTableRowElement;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLContentElement = scope.wrappers.HTMLContentElement;
    var HTMLElement = scope.wrappers.HTMLElement;
    var HTMLShadowElement = scope.wrappers.HTMLShadowElement;
    var HTMLTemplateElement = scope.wrappers.HTMLTemplateElement;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var OriginalHTMLUnknownElement = window.HTMLUnknownElement;
    function HTMLUnknownElement(node) {
      switch (node.localName) {
       case "content":
        return new HTMLContentElement(node);

       case "shadow":
        return new HTMLShadowElement(node);

       case "template":
        return new HTMLTemplateElement(node);
      }
      HTMLElement.call(this, node);
    }
    HTMLUnknownElement.prototype = Object.create(HTMLElement.prototype);
    registerWrapper(OriginalHTMLUnknownElement, HTMLUnknownElement);
    scope.wrappers.HTMLUnknownElement = HTMLUnknownElement;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var Element = scope.wrappers.Element;
    var HTMLElement = scope.wrappers.HTMLElement;
    var registerObject = scope.registerObject;
    var defineWrapGetter = scope.defineWrapGetter;
    var SVG_NS = "http://www.w3.org/2000/svg";
    var svgTitleElement = document.createElementNS(SVG_NS, "title");
    var SVGTitleElement = registerObject(svgTitleElement);
    var SVGElement = Object.getPrototypeOf(SVGTitleElement.prototype).constructor;
    if (!("classList" in svgTitleElement)) {
      var descr = Object.getOwnPropertyDescriptor(Element.prototype, "classList");
      Object.defineProperty(HTMLElement.prototype, "classList", descr);
      delete Element.prototype.classList;
    }
    defineWrapGetter(SVGElement, "ownerSVGElement");
    scope.wrappers.SVGElement = SVGElement;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var unwrap = scope.unwrap;
    var wrap = scope.wrap;
    var OriginalSVGUseElement = window.SVGUseElement;
    var SVG_NS = "http://www.w3.org/2000/svg";
    var gWrapper = wrap(document.createElementNS(SVG_NS, "g"));
    var useElement = document.createElementNS(SVG_NS, "use");
    var SVGGElement = gWrapper.constructor;
    var parentInterfacePrototype = Object.getPrototypeOf(SVGGElement.prototype);
    var parentInterface = parentInterfacePrototype.constructor;
    function SVGUseElement(impl) {
      parentInterface.call(this, impl);
    }
    SVGUseElement.prototype = Object.create(parentInterfacePrototype);
    if ("instanceRoot" in useElement) {
      mixin(SVGUseElement.prototype, {
        get instanceRoot() {
          return wrap(unwrap(this).instanceRoot);
        },
        get animatedInstanceRoot() {
          return wrap(unwrap(this).animatedInstanceRoot);
        }
      });
    }
    registerWrapper(OriginalSVGUseElement, SVGUseElement, useElement);
    scope.wrappers.SVGUseElement = SVGUseElement;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var EventTarget = scope.wrappers.EventTarget;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var wrap = scope.wrap;
    var OriginalSVGElementInstance = window.SVGElementInstance;
    if (!OriginalSVGElementInstance) return;
    function SVGElementInstance(impl) {
      EventTarget.call(this, impl);
    }
    SVGElementInstance.prototype = Object.create(EventTarget.prototype);
    mixin(SVGElementInstance.prototype, {
      get correspondingElement() {
        return wrap(unsafeUnwrap(this).correspondingElement);
      },
      get correspondingUseElement() {
        return wrap(unsafeUnwrap(this).correspondingUseElement);
      },
      get parentNode() {
        return wrap(unsafeUnwrap(this).parentNode);
      },
      get childNodes() {
        throw new Error("Not implemented");
      },
      get firstChild() {
        return wrap(unsafeUnwrap(this).firstChild);
      },
      get lastChild() {
        return wrap(unsafeUnwrap(this).lastChild);
      },
      get previousSibling() {
        return wrap(unsafeUnwrap(this).previousSibling);
      },
      get nextSibling() {
        return wrap(unsafeUnwrap(this).nextSibling);
      }
    });
    registerWrapper(OriginalSVGElementInstance, SVGElementInstance);
    scope.wrappers.SVGElementInstance = SVGElementInstance;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var setWrapper = scope.setWrapper;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var unwrap = scope.unwrap;
    var unwrapIfNeeded = scope.unwrapIfNeeded;
    var wrap = scope.wrap;
    var OriginalCanvasRenderingContext2D = window.CanvasRenderingContext2D;
    function CanvasRenderingContext2D(impl) {
      setWrapper(impl, this);
    }
    mixin(CanvasRenderingContext2D.prototype, {
      get canvas() {
        return wrap(unsafeUnwrap(this).canvas);
      },
      drawImage: function() {
        arguments[0] = unwrapIfNeeded(arguments[0]);
        unsafeUnwrap(this).drawImage.apply(unsafeUnwrap(this), arguments);
      },
      createPattern: function() {
        arguments[0] = unwrap(arguments[0]);
        return unsafeUnwrap(this).createPattern.apply(unsafeUnwrap(this), arguments);
      }
    });
    registerWrapper(OriginalCanvasRenderingContext2D, CanvasRenderingContext2D, document.createElement("canvas").getContext("2d"));
    scope.wrappers.CanvasRenderingContext2D = CanvasRenderingContext2D;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var setWrapper = scope.setWrapper;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var unwrapIfNeeded = scope.unwrapIfNeeded;
    var wrap = scope.wrap;
    var OriginalWebGLRenderingContext = window.WebGLRenderingContext;
    if (!OriginalWebGLRenderingContext) return;
    function WebGLRenderingContext(impl) {
      setWrapper(impl, this);
    }
    mixin(WebGLRenderingContext.prototype, {
      get canvas() {
        return wrap(unsafeUnwrap(this).canvas);
      },
      texImage2D: function() {
        arguments[5] = unwrapIfNeeded(arguments[5]);
        unsafeUnwrap(this).texImage2D.apply(unsafeUnwrap(this), arguments);
      },
      texSubImage2D: function() {
        arguments[6] = unwrapIfNeeded(arguments[6]);
        unsafeUnwrap(this).texSubImage2D.apply(unsafeUnwrap(this), arguments);
      }
    });
    var instanceProperties = /WebKit/.test(navigator.userAgent) ? {
      drawingBufferHeight: null,
      drawingBufferWidth: null
    } : {};
    registerWrapper(OriginalWebGLRenderingContext, WebGLRenderingContext, instanceProperties);
    scope.wrappers.WebGLRenderingContext = WebGLRenderingContext;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var registerWrapper = scope.registerWrapper;
    var setWrapper = scope.setWrapper;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var unwrap = scope.unwrap;
    var unwrapIfNeeded = scope.unwrapIfNeeded;
    var wrap = scope.wrap;
    var OriginalRange = window.Range;
    function Range(impl) {
      setWrapper(impl, this);
    }
    Range.prototype = {
      get startContainer() {
        return wrap(unsafeUnwrap(this).startContainer);
      },
      get endContainer() {
        return wrap(unsafeUnwrap(this).endContainer);
      },
      get commonAncestorContainer() {
        return wrap(unsafeUnwrap(this).commonAncestorContainer);
      },
      setStart: function(refNode, offset) {
        unsafeUnwrap(this).setStart(unwrapIfNeeded(refNode), offset);
      },
      setEnd: function(refNode, offset) {
        unsafeUnwrap(this).setEnd(unwrapIfNeeded(refNode), offset);
      },
      setStartBefore: function(refNode) {
        unsafeUnwrap(this).setStartBefore(unwrapIfNeeded(refNode));
      },
      setStartAfter: function(refNode) {
        unsafeUnwrap(this).setStartAfter(unwrapIfNeeded(refNode));
      },
      setEndBefore: function(refNode) {
        unsafeUnwrap(this).setEndBefore(unwrapIfNeeded(refNode));
      },
      setEndAfter: function(refNode) {
        unsafeUnwrap(this).setEndAfter(unwrapIfNeeded(refNode));
      },
      selectNode: function(refNode) {
        unsafeUnwrap(this).selectNode(unwrapIfNeeded(refNode));
      },
      selectNodeContents: function(refNode) {
        unsafeUnwrap(this).selectNodeContents(unwrapIfNeeded(refNode));
      },
      compareBoundaryPoints: function(how, sourceRange) {
        return unsafeUnwrap(this).compareBoundaryPoints(how, unwrap(sourceRange));
      },
      extractContents: function() {
        return wrap(unsafeUnwrap(this).extractContents());
      },
      cloneContents: function() {
        return wrap(unsafeUnwrap(this).cloneContents());
      },
      insertNode: function(node) {
        unsafeUnwrap(this).insertNode(unwrapIfNeeded(node));
      },
      surroundContents: function(newParent) {
        unsafeUnwrap(this).surroundContents(unwrapIfNeeded(newParent));
      },
      cloneRange: function() {
        return wrap(unsafeUnwrap(this).cloneRange());
      },
      isPointInRange: function(node, offset) {
        return unsafeUnwrap(this).isPointInRange(unwrapIfNeeded(node), offset);
      },
      comparePoint: function(node, offset) {
        return unsafeUnwrap(this).comparePoint(unwrapIfNeeded(node), offset);
      },
      intersectsNode: function(node) {
        return unsafeUnwrap(this).intersectsNode(unwrapIfNeeded(node));
      },
      toString: function() {
        return unsafeUnwrap(this).toString();
      }
    };
    if (OriginalRange.prototype.createContextualFragment) {
      Range.prototype.createContextualFragment = function(html) {
        return wrap(unsafeUnwrap(this).createContextualFragment(html));
      };
    }
    registerWrapper(window.Range, Range, document.createRange());
    scope.wrappers.Range = Range;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var GetElementsByInterface = scope.GetElementsByInterface;
    var ParentNodeInterface = scope.ParentNodeInterface;
    var SelectorsInterface = scope.SelectorsInterface;
    var mixin = scope.mixin;
    var registerObject = scope.registerObject;
    var DocumentFragment = registerObject(document.createDocumentFragment());
    mixin(DocumentFragment.prototype, ParentNodeInterface);
    mixin(DocumentFragment.prototype, SelectorsInterface);
    mixin(DocumentFragment.prototype, GetElementsByInterface);
    var Comment = registerObject(document.createComment(""));
    scope.wrappers.Comment = Comment;
    scope.wrappers.DocumentFragment = DocumentFragment;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var DocumentFragment = scope.wrappers.DocumentFragment;
    var TreeScope = scope.TreeScope;
    var elementFromPoint = scope.elementFromPoint;
    var getInnerHTML = scope.getInnerHTML;
    var getTreeScope = scope.getTreeScope;
    var mixin = scope.mixin;
    var rewrap = scope.rewrap;
    var setInnerHTML = scope.setInnerHTML;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var unwrap = scope.unwrap;
    var shadowHostTable = new WeakMap();
    var nextOlderShadowTreeTable = new WeakMap();
    var spaceCharRe = /[ \t\n\r\f]/;
    function ShadowRoot(hostWrapper) {
      var node = unwrap(unsafeUnwrap(hostWrapper).ownerDocument.createDocumentFragment());
      DocumentFragment.call(this, node);
      rewrap(node, this);
      var oldShadowRoot = hostWrapper.shadowRoot;
      nextOlderShadowTreeTable.set(this, oldShadowRoot);
      this.treeScope_ = new TreeScope(this, getTreeScope(oldShadowRoot || hostWrapper));
      shadowHostTable.set(this, hostWrapper);
    }
    ShadowRoot.prototype = Object.create(DocumentFragment.prototype);
    mixin(ShadowRoot.prototype, {
      constructor: ShadowRoot,
      get innerHTML() {
        return getInnerHTML(this);
      },
      set innerHTML(value) {
        setInnerHTML(this, value);
        this.invalidateShadowRenderer();
      },
      get olderShadowRoot() {
        return nextOlderShadowTreeTable.get(this) || null;
      },
      get host() {
        return shadowHostTable.get(this) || null;
      },
      invalidateShadowRenderer: function() {
        return shadowHostTable.get(this).invalidateShadowRenderer();
      },
      elementFromPoint: function(x, y) {
        return elementFromPoint(this, this.ownerDocument, x, y);
      },
      getElementById: function(id) {
        if (spaceCharRe.test(id)) return null;
        return this.querySelector('[id="' + id + '"]');
      }
    });
    scope.wrappers.ShadowRoot = ShadowRoot;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var Element = scope.wrappers.Element;
    var HTMLContentElement = scope.wrappers.HTMLContentElement;
    var HTMLShadowElement = scope.wrappers.HTMLShadowElement;
    var Node = scope.wrappers.Node;
    var ShadowRoot = scope.wrappers.ShadowRoot;
    var assert = scope.assert;
    var getTreeScope = scope.getTreeScope;
    var mixin = scope.mixin;
    var oneOf = scope.oneOf;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var unwrap = scope.unwrap;
    var wrap = scope.wrap;
    var ArraySplice = scope.ArraySplice;
    function updateWrapperUpAndSideways(wrapper) {
      wrapper.previousSibling_ = wrapper.previousSibling;
      wrapper.nextSibling_ = wrapper.nextSibling;
      wrapper.parentNode_ = wrapper.parentNode;
    }
    function updateWrapperDown(wrapper) {
      wrapper.firstChild_ = wrapper.firstChild;
      wrapper.lastChild_ = wrapper.lastChild;
    }
    function updateAllChildNodes(parentNodeWrapper) {
      assert(parentNodeWrapper instanceof Node);
      for (var childWrapper = parentNodeWrapper.firstChild; childWrapper; childWrapper = childWrapper.nextSibling) {
        updateWrapperUpAndSideways(childWrapper);
      }
      updateWrapperDown(parentNodeWrapper);
    }
    function insertBefore(parentNodeWrapper, newChildWrapper, refChildWrapper) {
      var parentNode = unwrap(parentNodeWrapper);
      var newChild = unwrap(newChildWrapper);
      var refChild = refChildWrapper ? unwrap(refChildWrapper) : null;
      remove(newChildWrapper);
      updateWrapperUpAndSideways(newChildWrapper);
      if (!refChildWrapper) {
        parentNodeWrapper.lastChild_ = parentNodeWrapper.lastChild;
        if (parentNodeWrapper.lastChild === parentNodeWrapper.firstChild) parentNodeWrapper.firstChild_ = parentNodeWrapper.firstChild;
        var lastChildWrapper = wrap(parentNode.lastChild);
        if (lastChildWrapper) lastChildWrapper.nextSibling_ = lastChildWrapper.nextSibling;
      } else {
        if (parentNodeWrapper.firstChild === refChildWrapper) parentNodeWrapper.firstChild_ = refChildWrapper;
        refChildWrapper.previousSibling_ = refChildWrapper.previousSibling;
      }
      scope.originalInsertBefore.call(parentNode, newChild, refChild);
    }
    function remove(nodeWrapper) {
      var node = unwrap(nodeWrapper);
      var parentNode = node.parentNode;
      if (!parentNode) return;
      var parentNodeWrapper = wrap(parentNode);
      updateWrapperUpAndSideways(nodeWrapper);
      if (nodeWrapper.previousSibling) nodeWrapper.previousSibling.nextSibling_ = nodeWrapper;
      if (nodeWrapper.nextSibling) nodeWrapper.nextSibling.previousSibling_ = nodeWrapper;
      if (parentNodeWrapper.lastChild === nodeWrapper) parentNodeWrapper.lastChild_ = nodeWrapper;
      if (parentNodeWrapper.firstChild === nodeWrapper) parentNodeWrapper.firstChild_ = nodeWrapper;
      scope.originalRemoveChild.call(parentNode, node);
    }
    var distributedNodesTable = new WeakMap();
    var destinationInsertionPointsTable = new WeakMap();
    var rendererForHostTable = new WeakMap();
    function resetDistributedNodes(insertionPoint) {
      distributedNodesTable.set(insertionPoint, []);
    }
    function getDistributedNodes(insertionPoint) {
      var rv = distributedNodesTable.get(insertionPoint);
      if (!rv) distributedNodesTable.set(insertionPoint, rv = []);
      return rv;
    }
    function getChildNodesSnapshot(node) {
      var result = [], i = 0;
      for (var child = node.firstChild; child; child = child.nextSibling) {
        result[i++] = child;
      }
      return result;
    }
    var request = oneOf(window, [ "requestAnimationFrame", "mozRequestAnimationFrame", "webkitRequestAnimationFrame", "setTimeout" ]);
    var pendingDirtyRenderers = [];
    var renderTimer;
    function renderAllPending() {
      for (var i = 0; i < pendingDirtyRenderers.length; i++) {
        var renderer = pendingDirtyRenderers[i];
        var parentRenderer = renderer.parentRenderer;
        if (parentRenderer && parentRenderer.dirty) continue;
        renderer.render();
      }
      pendingDirtyRenderers = [];
    }
    function handleRequestAnimationFrame() {
      renderTimer = null;
      renderAllPending();
    }
    function getRendererForHost(host) {
      var renderer = rendererForHostTable.get(host);
      if (!renderer) {
        renderer = new ShadowRenderer(host);
        rendererForHostTable.set(host, renderer);
      }
      return renderer;
    }
    function getShadowRootAncestor(node) {
      var root = getTreeScope(node).root;
      if (root instanceof ShadowRoot) return root;
      return null;
    }
    function getRendererForShadowRoot(shadowRoot) {
      return getRendererForHost(shadowRoot.host);
    }
    var spliceDiff = new ArraySplice();
    spliceDiff.equals = function(renderNode, rawNode) {
      return unwrap(renderNode.node) === rawNode;
    };
    function RenderNode(node) {
      this.skip = false;
      this.node = node;
      this.childNodes = [];
    }
    RenderNode.prototype = {
      append: function(node) {
        var rv = new RenderNode(node);
        this.childNodes.push(rv);
        return rv;
      },
      sync: function(opt_added) {
        if (this.skip) return;
        var nodeWrapper = this.node;
        var newChildren = this.childNodes;
        var oldChildren = getChildNodesSnapshot(unwrap(nodeWrapper));
        var added = opt_added || new WeakMap();
        var splices = spliceDiff.calculateSplices(newChildren, oldChildren);
        var newIndex = 0, oldIndex = 0;
        var lastIndex = 0;
        for (var i = 0; i < splices.length; i++) {
          var splice = splices[i];
          for (;lastIndex < splice.index; lastIndex++) {
            oldIndex++;
            newChildren[newIndex++].sync(added);
          }
          var removedCount = splice.removed.length;
          for (var j = 0; j < removedCount; j++) {
            var wrapper = wrap(oldChildren[oldIndex++]);
            if (!added.get(wrapper)) remove(wrapper);
          }
          var addedCount = splice.addedCount;
          var refNode = oldChildren[oldIndex] && wrap(oldChildren[oldIndex]);
          for (var j = 0; j < addedCount; j++) {
            var newChildRenderNode = newChildren[newIndex++];
            var newChildWrapper = newChildRenderNode.node;
            insertBefore(nodeWrapper, newChildWrapper, refNode);
            added.set(newChildWrapper, true);
            newChildRenderNode.sync(added);
          }
          lastIndex += addedCount;
        }
        for (var i = lastIndex; i < newChildren.length; i++) {
          newChildren[i].sync(added);
        }
      }
    };
    function ShadowRenderer(host) {
      this.host = host;
      this.dirty = false;
      this.invalidateAttributes();
      this.associateNode(host);
    }
    ShadowRenderer.prototype = {
      render: function(opt_renderNode) {
        if (!this.dirty) return;
        this.invalidateAttributes();
        var host = this.host;
        this.distribution(host);
        var renderNode = opt_renderNode || new RenderNode(host);
        this.buildRenderTree(renderNode, host);
        var topMostRenderer = !opt_renderNode;
        if (topMostRenderer) renderNode.sync();
        this.dirty = false;
      },
      get parentRenderer() {
        return getTreeScope(this.host).renderer;
      },
      invalidate: function() {
        if (!this.dirty) {
          this.dirty = true;
          var parentRenderer = this.parentRenderer;
          if (parentRenderer) parentRenderer.invalidate();
          pendingDirtyRenderers.push(this);
          if (renderTimer) return;
          renderTimer = window[request](handleRequestAnimationFrame, 0);
        }
      },
      distribution: function(root) {
        this.resetAllSubtrees(root);
        this.distributionResolution(root);
      },
      resetAll: function(node) {
        if (isInsertionPoint(node)) resetDistributedNodes(node); else resetDestinationInsertionPoints(node);
        this.resetAllSubtrees(node);
      },
      resetAllSubtrees: function(node) {
        for (var child = node.firstChild; child; child = child.nextSibling) {
          this.resetAll(child);
        }
        if (node.shadowRoot) this.resetAll(node.shadowRoot);
        if (node.olderShadowRoot) this.resetAll(node.olderShadowRoot);
      },
      distributionResolution: function(node) {
        if (isShadowHost(node)) {
          var shadowHost = node;
          var pool = poolPopulation(shadowHost);
          var shadowTrees = getShadowTrees(shadowHost);
          for (var i = 0; i < shadowTrees.length; i++) {
            this.poolDistribution(shadowTrees[i], pool);
          }
          for (var i = shadowTrees.length - 1; i >= 0; i--) {
            var shadowTree = shadowTrees[i];
            var shadow = getShadowInsertionPoint(shadowTree);
            if (shadow) {
              var olderShadowRoot = shadowTree.olderShadowRoot;
              if (olderShadowRoot) {
                pool = poolPopulation(olderShadowRoot);
              }
              for (var j = 0; j < pool.length; j++) {
                destributeNodeInto(pool[j], shadow);
              }
            }
            this.distributionResolution(shadowTree);
          }
        }
        for (var child = node.firstChild; child; child = child.nextSibling) {
          this.distributionResolution(child);
        }
      },
      poolDistribution: function(node, pool) {
        if (node instanceof HTMLShadowElement) return;
        if (node instanceof HTMLContentElement) {
          var content = node;
          this.updateDependentAttributes(content.getAttribute("select"));
          var anyDistributed = false;
          for (var i = 0; i < pool.length; i++) {
            var node = pool[i];
            if (!node) continue;
            if (matches(node, content)) {
              destributeNodeInto(node, content);
              pool[i] = undefined;
              anyDistributed = true;
            }
          }
          if (!anyDistributed) {
            for (var child = content.firstChild; child; child = child.nextSibling) {
              destributeNodeInto(child, content);
            }
          }
          return;
        }
        for (var child = node.firstChild; child; child = child.nextSibling) {
          this.poolDistribution(child, pool);
        }
      },
      buildRenderTree: function(renderNode, node) {
        var children = this.compose(node);
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          var childRenderNode = renderNode.append(child);
          this.buildRenderTree(childRenderNode, child);
        }
        if (isShadowHost(node)) {
          var renderer = getRendererForHost(node);
          renderer.dirty = false;
        }
      },
      compose: function(node) {
        var children = [];
        var p = node.shadowRoot || node;
        for (var child = p.firstChild; child; child = child.nextSibling) {
          if (isInsertionPoint(child)) {
            this.associateNode(p);
            var distributedNodes = getDistributedNodes(child);
            for (var j = 0; j < distributedNodes.length; j++) {
              var distributedNode = distributedNodes[j];
              if (isFinalDestination(child, distributedNode)) children.push(distributedNode);
            }
          } else {
            children.push(child);
          }
        }
        return children;
      },
      invalidateAttributes: function() {
        this.attributes = Object.create(null);
      },
      updateDependentAttributes: function(selector) {
        if (!selector) return;
        var attributes = this.attributes;
        if (/\.\w+/.test(selector)) attributes["class"] = true;
        if (/#\w+/.test(selector)) attributes["id"] = true;
        selector.replace(/\[\s*([^\s=\|~\]]+)/g, function(_, name) {
          attributes[name] = true;
        });
      },
      dependsOnAttribute: function(name) {
        return this.attributes[name];
      },
      associateNode: function(node) {
        unsafeUnwrap(node).polymerShadowRenderer_ = this;
      }
    };
    function poolPopulation(node) {
      var pool = [];
      for (var child = node.firstChild; child; child = child.nextSibling) {
        if (isInsertionPoint(child)) {
          pool.push.apply(pool, getDistributedNodes(child));
        } else {
          pool.push(child);
        }
      }
      return pool;
    }
    function getShadowInsertionPoint(node) {
      if (node instanceof HTMLShadowElement) return node;
      if (node instanceof HTMLContentElement) return null;
      for (var child = node.firstChild; child; child = child.nextSibling) {
        var res = getShadowInsertionPoint(child);
        if (res) return res;
      }
      return null;
    }
    function destributeNodeInto(child, insertionPoint) {
      getDistributedNodes(insertionPoint).push(child);
      var points = destinationInsertionPointsTable.get(child);
      if (!points) destinationInsertionPointsTable.set(child, [ insertionPoint ]); else points.push(insertionPoint);
    }
    function getDestinationInsertionPoints(node) {
      return destinationInsertionPointsTable.get(node);
    }
    function resetDestinationInsertionPoints(node) {
      destinationInsertionPointsTable.set(node, undefined);
    }
    var selectorStartCharRe = /^(:not\()?[*.#[a-zA-Z_|]/;
    function matches(node, contentElement) {
      var select = contentElement.getAttribute("select");
      if (!select) return true;
      select = select.trim();
      if (!select) return true;
      if (!(node instanceof Element)) return false;
      if (!selectorStartCharRe.test(select)) return false;
      try {
        return node.matches(select);
      } catch (ex) {
        return false;
      }
    }
    function isFinalDestination(insertionPoint, node) {
      var points = getDestinationInsertionPoints(node);
      return points && points[points.length - 1] === insertionPoint;
    }
    function isInsertionPoint(node) {
      return node instanceof HTMLContentElement || node instanceof HTMLShadowElement;
    }
    function isShadowHost(shadowHost) {
      return shadowHost.shadowRoot;
    }
    function getShadowTrees(host) {
      var trees = [];
      for (var tree = host.shadowRoot; tree; tree = tree.olderShadowRoot) {
        trees.push(tree);
      }
      return trees;
    }
    function render(host) {
      new ShadowRenderer(host).render();
    }
    Node.prototype.invalidateShadowRenderer = function(force) {
      var renderer = unsafeUnwrap(this).polymerShadowRenderer_;
      if (renderer) {
        renderer.invalidate();
        return true;
      }
      return false;
    };
    HTMLContentElement.prototype.getDistributedNodes = HTMLShadowElement.prototype.getDistributedNodes = function() {
      renderAllPending();
      return getDistributedNodes(this);
    };
    Element.prototype.getDestinationInsertionPoints = function() {
      renderAllPending();
      return getDestinationInsertionPoints(this) || [];
    };
    HTMLContentElement.prototype.nodeIsInserted_ = HTMLShadowElement.prototype.nodeIsInserted_ = function() {
      this.invalidateShadowRenderer();
      var shadowRoot = getShadowRootAncestor(this);
      var renderer;
      if (shadowRoot) renderer = getRendererForShadowRoot(shadowRoot);
      unsafeUnwrap(this).polymerShadowRenderer_ = renderer;
      if (renderer) renderer.invalidate();
    };
    scope.getRendererForHost = getRendererForHost;
    scope.getShadowTrees = getShadowTrees;
    scope.renderAllPending = renderAllPending;
    scope.getDestinationInsertionPoints = getDestinationInsertionPoints;
    scope.visual = {
      insertBefore: insertBefore,
      remove: remove
    };
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var HTMLElement = scope.wrappers.HTMLElement;
    var assert = scope.assert;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var unwrap = scope.unwrap;
    var wrap = scope.wrap;
    var elementsWithFormProperty = [ "HTMLButtonElement", "HTMLFieldSetElement", "HTMLInputElement", "HTMLKeygenElement", "HTMLLabelElement", "HTMLLegendElement", "HTMLObjectElement", "HTMLOutputElement", "HTMLTextAreaElement" ];
    function createWrapperConstructor(name) {
      if (!window[name]) return;
      assert(!scope.wrappers[name]);
      var GeneratedWrapper = function(node) {
        HTMLElement.call(this, node);
      };
      GeneratedWrapper.prototype = Object.create(HTMLElement.prototype);
      mixin(GeneratedWrapper.prototype, {
        get form() {
          return wrap(unwrap(this).form);
        }
      });
      registerWrapper(window[name], GeneratedWrapper, document.createElement(name.slice(4, -7)));
      scope.wrappers[name] = GeneratedWrapper;
    }
    elementsWithFormProperty.forEach(createWrapperConstructor);
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var registerWrapper = scope.registerWrapper;
    var setWrapper = scope.setWrapper;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var unwrap = scope.unwrap;
    var unwrapIfNeeded = scope.unwrapIfNeeded;
    var wrap = scope.wrap;
    var OriginalSelection = window.Selection;
    function Selection(impl) {
      setWrapper(impl, this);
    }
    Selection.prototype = {
      get anchorNode() {
        return wrap(unsafeUnwrap(this).anchorNode);
      },
      get focusNode() {
        return wrap(unsafeUnwrap(this).focusNode);
      },
      addRange: function(range) {
        unsafeUnwrap(this).addRange(unwrap(range));
      },
      collapse: function(node, index) {
        unsafeUnwrap(this).collapse(unwrapIfNeeded(node), index);
      },
      containsNode: function(node, allowPartial) {
        return unsafeUnwrap(this).containsNode(unwrapIfNeeded(node), allowPartial);
      },
      extend: function(node, offset) {
        unsafeUnwrap(this).extend(unwrapIfNeeded(node), offset);
      },
      getRangeAt: function(index) {
        return wrap(unsafeUnwrap(this).getRangeAt(index));
      },
      removeRange: function(range) {
        unsafeUnwrap(this).removeRange(unwrap(range));
      },
      selectAllChildren: function(node) {
        unsafeUnwrap(this).selectAllChildren(unwrapIfNeeded(node));
      },
      toString: function() {
        return unsafeUnwrap(this).toString();
      }
    };
    registerWrapper(window.Selection, Selection, window.getSelection());
    scope.wrappers.Selection = Selection;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var GetElementsByInterface = scope.GetElementsByInterface;
    var Node = scope.wrappers.Node;
    var ParentNodeInterface = scope.ParentNodeInterface;
    var Selection = scope.wrappers.Selection;
    var SelectorsInterface = scope.SelectorsInterface;
    var ShadowRoot = scope.wrappers.ShadowRoot;
    var TreeScope = scope.TreeScope;
    var cloneNode = scope.cloneNode;
    var defineWrapGetter = scope.defineWrapGetter;
    var elementFromPoint = scope.elementFromPoint;
    var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;
    var matchesNames = scope.matchesNames;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var renderAllPending = scope.renderAllPending;
    var rewrap = scope.rewrap;
    var setWrapper = scope.setWrapper;
    var unsafeUnwrap = scope.unsafeUnwrap;
    var unwrap = scope.unwrap;
    var wrap = scope.wrap;
    var wrapEventTargetMethods = scope.wrapEventTargetMethods;
    var wrapNodeList = scope.wrapNodeList;
    var implementationTable = new WeakMap();
    function Document(node) {
      Node.call(this, node);
      this.treeScope_ = new TreeScope(this, null);
    }
    Document.prototype = Object.create(Node.prototype);
    defineWrapGetter(Document, "documentElement");
    defineWrapGetter(Document, "body");
    defineWrapGetter(Document, "head");
    function wrapMethod(name) {
      var original = document[name];
      Document.prototype[name] = function() {
        return wrap(original.apply(unsafeUnwrap(this), arguments));
      };
    }
    [ "createComment", "createDocumentFragment", "createElement", "createElementNS", "createEvent", "createEventNS", "createRange", "createTextNode", "getElementById" ].forEach(wrapMethod);
    var originalAdoptNode = document.adoptNode;
    function adoptNodeNoRemove(node, doc) {
      originalAdoptNode.call(unsafeUnwrap(doc), unwrap(node));
      adoptSubtree(node, doc);
    }
    function adoptSubtree(node, doc) {
      if (node.shadowRoot) doc.adoptNode(node.shadowRoot);
      if (node instanceof ShadowRoot) adoptOlderShadowRoots(node, doc);
      for (var child = node.firstChild; child; child = child.nextSibling) {
        adoptSubtree(child, doc);
      }
    }
    function adoptOlderShadowRoots(shadowRoot, doc) {
      var oldShadowRoot = shadowRoot.olderShadowRoot;
      if (oldShadowRoot) doc.adoptNode(oldShadowRoot);
    }
    var originalGetSelection = document.getSelection;
    mixin(Document.prototype, {
      adoptNode: function(node) {
        if (node.parentNode) node.parentNode.removeChild(node);
        adoptNodeNoRemove(node, this);
        return node;
      },
      elementFromPoint: function(x, y) {
        return elementFromPoint(this, this, x, y);
      },
      importNode: function(node, deep) {
        return cloneNode(node, deep, unsafeUnwrap(this));
      },
      getSelection: function() {
        renderAllPending();
        return new Selection(originalGetSelection.call(unwrap(this)));
      },
      getElementsByName: function(name) {
        return SelectorsInterface.querySelectorAll.call(this, "[name=" + JSON.stringify(String(name)) + "]");
      }
    });
    if (document.registerElement) {
      var originalRegisterElement = document.registerElement;
      Document.prototype.registerElement = function(tagName, object) {
        var prototype, extendsOption;
        if (object !== undefined) {
          prototype = object.prototype;
          extendsOption = object.extends;
        }
        if (!prototype) prototype = Object.create(HTMLElement.prototype);
        if (scope.nativePrototypeTable.get(prototype)) {
          throw new Error("NotSupportedError");
        }
        var proto = Object.getPrototypeOf(prototype);
        var nativePrototype;
        var prototypes = [];
        while (proto) {
          nativePrototype = scope.nativePrototypeTable.get(proto);
          if (nativePrototype) break;
          prototypes.push(proto);
          proto = Object.getPrototypeOf(proto);
        }
        if (!nativePrototype) {
          throw new Error("NotSupportedError");
        }
        var newPrototype = Object.create(nativePrototype);
        for (var i = prototypes.length - 1; i >= 0; i--) {
          newPrototype = Object.create(newPrototype);
        }
        [ "createdCallback", "attachedCallback", "detachedCallback", "attributeChangedCallback" ].forEach(function(name) {
          var f = prototype[name];
          if (!f) return;
          newPrototype[name] = function() {
            if (!(wrap(this) instanceof CustomElementConstructor)) {
              rewrap(this);
            }
            f.apply(wrap(this), arguments);
          };
        });
        var p = {
          prototype: newPrototype
        };
        if (extendsOption) p.extends = extendsOption;
        function CustomElementConstructor(node) {
          if (!node) {
            if (extendsOption) {
              return document.createElement(extendsOption, tagName);
            } else {
              return document.createElement(tagName);
            }
          }
          setWrapper(node, this);
        }
        CustomElementConstructor.prototype = prototype;
        CustomElementConstructor.prototype.constructor = CustomElementConstructor;
        scope.constructorTable.set(newPrototype, CustomElementConstructor);
        scope.nativePrototypeTable.set(prototype, newPrototype);
        var nativeConstructor = originalRegisterElement.call(unwrap(this), tagName, p);
        return CustomElementConstructor;
      };
      forwardMethodsToWrapper([ window.HTMLDocument || window.Document ], [ "registerElement" ]);
    }
    forwardMethodsToWrapper([ window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement, window.HTMLHtmlElement ], [ "appendChild", "compareDocumentPosition", "contains", "getElementsByClassName", "getElementsByTagName", "getElementsByTagNameNS", "insertBefore", "querySelector", "querySelectorAll", "removeChild", "replaceChild" ]);
    forwardMethodsToWrapper([ window.HTMLBodyElement, window.HTMLHeadElement, window.HTMLHtmlElement ], matchesNames);
    forwardMethodsToWrapper([ window.HTMLDocument || window.Document ], [ "adoptNode", "importNode", "contains", "createComment", "createDocumentFragment", "createElement", "createElementNS", "createEvent", "createEventNS", "createRange", "createTextNode", "elementFromPoint", "getElementById", "getElementsByName", "getSelection" ]);
    mixin(Document.prototype, GetElementsByInterface);
    mixin(Document.prototype, ParentNodeInterface);
    mixin(Document.prototype, SelectorsInterface);
    mixin(Document.prototype, {
      get implementation() {
        var implementation = implementationTable.get(this);
        if (implementation) return implementation;
        implementation = new DOMImplementation(unwrap(this).implementation);
        implementationTable.set(this, implementation);
        return implementation;
      },
      get defaultView() {
        return wrap(unwrap(this).defaultView);
      }
    });
    registerWrapper(window.Document, Document, document.implementation.createHTMLDocument(""));
    if (window.HTMLDocument) registerWrapper(window.HTMLDocument, Document);
    wrapEventTargetMethods([ window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement ]);
    function DOMImplementation(impl) {
      setWrapper(impl, this);
    }
    function wrapImplMethod(constructor, name) {
      var original = document.implementation[name];
      constructor.prototype[name] = function() {
        return wrap(original.apply(unsafeUnwrap(this), arguments));
      };
    }
    function forwardImplMethod(constructor, name) {
      var original = document.implementation[name];
      constructor.prototype[name] = function() {
        return original.apply(unsafeUnwrap(this), arguments);
      };
    }
    wrapImplMethod(DOMImplementation, "createDocumentType");
    wrapImplMethod(DOMImplementation, "createDocument");
    wrapImplMethod(DOMImplementation, "createHTMLDocument");
    forwardImplMethod(DOMImplementation, "hasFeature");
    registerWrapper(window.DOMImplementation, DOMImplementation);
    forwardMethodsToWrapper([ window.DOMImplementation ], [ "createDocumentType", "createDocument", "createHTMLDocument", "hasFeature" ]);
    scope.adoptNodeNoRemove = adoptNodeNoRemove;
    scope.wrappers.DOMImplementation = DOMImplementation;
    scope.wrappers.Document = Document;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var EventTarget = scope.wrappers.EventTarget;
    var Selection = scope.wrappers.Selection;
    var mixin = scope.mixin;
    var registerWrapper = scope.registerWrapper;
    var renderAllPending = scope.renderAllPending;
    var unwrap = scope.unwrap;
    var unwrapIfNeeded = scope.unwrapIfNeeded;
    var wrap = scope.wrap;
    var OriginalWindow = window.Window;
    var originalGetComputedStyle = window.getComputedStyle;
    var originalGetDefaultComputedStyle = window.getDefaultComputedStyle;
    var originalGetSelection = window.getSelection;
    function Window(impl) {
      EventTarget.call(this, impl);
    }
    Window.prototype = Object.create(EventTarget.prototype);
    OriginalWindow.prototype.getComputedStyle = function(el, pseudo) {
      return wrap(this || window).getComputedStyle(unwrapIfNeeded(el), pseudo);
    };
    if (originalGetDefaultComputedStyle) {
      OriginalWindow.prototype.getDefaultComputedStyle = function(el, pseudo) {
        return wrap(this || window).getDefaultComputedStyle(unwrapIfNeeded(el), pseudo);
      };
    }
    OriginalWindow.prototype.getSelection = function() {
      return wrap(this || window).getSelection();
    };
    delete window.getComputedStyle;
    delete window.getDefaultComputedStyle;
    delete window.getSelection;
    [ "addEventListener", "removeEventListener", "dispatchEvent" ].forEach(function(name) {
      OriginalWindow.prototype[name] = function() {
        var w = wrap(this || window);
        return w[name].apply(w, arguments);
      };
      delete window[name];
    });
    mixin(Window.prototype, {
      getComputedStyle: function(el, pseudo) {
        renderAllPending();
        return originalGetComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);
      },
      getSelection: function() {
        renderAllPending();
        return new Selection(originalGetSelection.call(unwrap(this)));
      },
      get document() {
        return wrap(unwrap(this).document);
      }
    });
    if (originalGetDefaultComputedStyle) {
      Window.prototype.getDefaultComputedStyle = function(el, pseudo) {
        renderAllPending();
        return originalGetDefaultComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);
      };
    }
    registerWrapper(OriginalWindow, Window, window);
    scope.wrappers.Window = Window;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var unwrap = scope.unwrap;
    var OriginalDataTransfer = window.DataTransfer || window.Clipboard;
    var OriginalDataTransferSetDragImage = OriginalDataTransfer.prototype.setDragImage;
    if (OriginalDataTransferSetDragImage) {
      OriginalDataTransfer.prototype.setDragImage = function(image, x, y) {
        OriginalDataTransferSetDragImage.call(this, unwrap(image), x, y);
      };
    }
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var registerWrapper = scope.registerWrapper;
    var setWrapper = scope.setWrapper;
    var unwrap = scope.unwrap;
    var OriginalFormData = window.FormData;
    if (!OriginalFormData) return;
    function FormData(formElement) {
      var impl;
      if (formElement instanceof OriginalFormData) {
        impl = formElement;
      } else {
        impl = new OriginalFormData(formElement && unwrap(formElement));
      }
      setWrapper(impl, this);
    }
    registerWrapper(OriginalFormData, FormData, new OriginalFormData());
    scope.wrappers.FormData = FormData;
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var unwrapIfNeeded = scope.unwrapIfNeeded;
    var originalSend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.send = function(obj) {
      return originalSend.call(this, unwrapIfNeeded(obj));
    };
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    "use strict";
    var isWrapperFor = scope.isWrapperFor;
    var elements = {
      a: "HTMLAnchorElement",
      area: "HTMLAreaElement",
      audio: "HTMLAudioElement",
      base: "HTMLBaseElement",
      body: "HTMLBodyElement",
      br: "HTMLBRElement",
      button: "HTMLButtonElement",
      canvas: "HTMLCanvasElement",
      caption: "HTMLTableCaptionElement",
      col: "HTMLTableColElement",
      content: "HTMLContentElement",
      data: "HTMLDataElement",
      datalist: "HTMLDataListElement",
      del: "HTMLModElement",
      dir: "HTMLDirectoryElement",
      div: "HTMLDivElement",
      dl: "HTMLDListElement",
      embed: "HTMLEmbedElement",
      fieldset: "HTMLFieldSetElement",
      font: "HTMLFontElement",
      form: "HTMLFormElement",
      frame: "HTMLFrameElement",
      frameset: "HTMLFrameSetElement",
      h1: "HTMLHeadingElement",
      head: "HTMLHeadElement",
      hr: "HTMLHRElement",
      html: "HTMLHtmlElement",
      iframe: "HTMLIFrameElement",
      img: "HTMLImageElement",
      input: "HTMLInputElement",
      keygen: "HTMLKeygenElement",
      label: "HTMLLabelElement",
      legend: "HTMLLegendElement",
      li: "HTMLLIElement",
      link: "HTMLLinkElement",
      map: "HTMLMapElement",
      marquee: "HTMLMarqueeElement",
      menu: "HTMLMenuElement",
      menuitem: "HTMLMenuItemElement",
      meta: "HTMLMetaElement",
      meter: "HTMLMeterElement",
      object: "HTMLObjectElement",
      ol: "HTMLOListElement",
      optgroup: "HTMLOptGroupElement",
      option: "HTMLOptionElement",
      output: "HTMLOutputElement",
      p: "HTMLParagraphElement",
      param: "HTMLParamElement",
      pre: "HTMLPreElement",
      progress: "HTMLProgressElement",
      q: "HTMLQuoteElement",
      script: "HTMLScriptElement",
      select: "HTMLSelectElement",
      shadow: "HTMLShadowElement",
      source: "HTMLSourceElement",
      span: "HTMLSpanElement",
      style: "HTMLStyleElement",
      table: "HTMLTableElement",
      tbody: "HTMLTableSectionElement",
      template: "HTMLTemplateElement",
      textarea: "HTMLTextAreaElement",
      thead: "HTMLTableSectionElement",
      time: "HTMLTimeElement",
      title: "HTMLTitleElement",
      tr: "HTMLTableRowElement",
      track: "HTMLTrackElement",
      ul: "HTMLUListElement",
      video: "HTMLVideoElement"
    };
    function overrideConstructor(tagName) {
      var nativeConstructorName = elements[tagName];
      var nativeConstructor = window[nativeConstructorName];
      if (!nativeConstructor) return;
      var element = document.createElement(tagName);
      var wrapperConstructor = element.constructor;
      window[nativeConstructorName] = wrapperConstructor;
    }
    Object.keys(elements).forEach(overrideConstructor);
    Object.getOwnPropertyNames(scope.wrappers).forEach(function(name) {
      window[name] = scope.wrappers[name];
    });
  })(window.ShadowDOMPolyfill);
  (function(scope) {
    var ShadowCSS = {
      strictStyling: false,
      registry: {},
      shimStyling: function(root, name, extendsName) {
        var scopeStyles = this.prepareRoot(root, name, extendsName);
        var typeExtension = this.isTypeExtension(extendsName);
        var scopeSelector = this.makeScopeSelector(name, typeExtension);
        var cssText = stylesToCssText(scopeStyles, true);
        cssText = this.scopeCssText(cssText, scopeSelector);
        if (root) {
          root.shimmedStyle = cssText;
        }
        this.addCssToDocument(cssText, name);
      },
      shimStyle: function(style, selector) {
        return this.shimCssText(style.textContent, selector);
      },
      shimCssText: function(cssText, selector) {
        cssText = this.insertDirectives(cssText);
        return this.scopeCssText(cssText, selector);
      },
      makeScopeSelector: function(name, typeExtension) {
        if (name) {
          return typeExtension ? "[is=" + name + "]" : name;
        }
        return "";
      },
      isTypeExtension: function(extendsName) {
        return extendsName && extendsName.indexOf("-") < 0;
      },
      prepareRoot: function(root, name, extendsName) {
        var def = this.registerRoot(root, name, extendsName);
        this.replaceTextInStyles(def.rootStyles, this.insertDirectives);
        this.removeStyles(root, def.rootStyles);
        if (this.strictStyling) {
          this.applyScopeToContent(root, name);
        }
        return def.scopeStyles;
      },
      removeStyles: function(root, styles) {
        for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
          s.parentNode.removeChild(s);
        }
      },
      registerRoot: function(root, name, extendsName) {
        var def = this.registry[name] = {
          root: root,
          name: name,
          extendsName: extendsName
        };
        var styles = this.findStyles(root);
        def.rootStyles = styles;
        def.scopeStyles = def.rootStyles;
        var extendee = this.registry[def.extendsName];
        if (extendee) {
          def.scopeStyles = extendee.scopeStyles.concat(def.scopeStyles);
        }
        return def;
      },
      findStyles: function(root) {
        if (!root) {
          return [];
        }
        var styles = root.querySelectorAll("style");
        return Array.prototype.filter.call(styles, function(s) {
          return !s.hasAttribute(NO_SHIM_ATTRIBUTE);
        });
      },
      applyScopeToContent: function(root, name) {
        if (root) {
          Array.prototype.forEach.call(root.querySelectorAll("*"), function(node) {
            node.setAttribute(name, "");
          });
          Array.prototype.forEach.call(root.querySelectorAll("template"), function(template) {
            this.applyScopeToContent(template.content, name);
          }, this);
        }
      },
      insertDirectives: function(cssText) {
        cssText = this.insertPolyfillDirectivesInCssText(cssText);
        return this.insertPolyfillRulesInCssText(cssText);
      },
      insertPolyfillDirectivesInCssText: function(cssText) {
        cssText = cssText.replace(cssCommentNextSelectorRe, function(match, p1) {
          return p1.slice(0, -2) + "{";
        });
        return cssText.replace(cssContentNextSelectorRe, function(match, p1) {
          return p1 + " {";
        });
      },
      insertPolyfillRulesInCssText: function(cssText) {
        cssText = cssText.replace(cssCommentRuleRe, function(match, p1) {
          return p1.slice(0, -1);
        });
        return cssText.replace(cssContentRuleRe, function(match, p1, p2, p3) {
          var rule = match.replace(p1, "").replace(p2, "");
          return p3 + rule;
        });
      },
      scopeCssText: function(cssText, scopeSelector) {
        var unscoped = this.extractUnscopedRulesFromCssText(cssText);
        cssText = this.insertPolyfillHostInCssText(cssText);
        cssText = this.convertColonHost(cssText);
        cssText = this.convertColonHostContext(cssText);
        cssText = this.convertShadowDOMSelectors(cssText);
        if (scopeSelector) {
          var self = this, cssText;
          withCssRules(cssText, function(rules) {
            cssText = self.scopeRules(rules, scopeSelector);
          });
        }
        cssText = cssText + "\n" + unscoped;
        return cssText.trim();
      },
      extractUnscopedRulesFromCssText: function(cssText) {
        var r = "", m;
        while (m = cssCommentUnscopedRuleRe.exec(cssText)) {
          r += m[1].slice(0, -1) + "\n\n";
        }
        while (m = cssContentUnscopedRuleRe.exec(cssText)) {
          r += m[0].replace(m[2], "").replace(m[1], m[3]) + "\n\n";
        }
        return r;
      },
      convertColonHost: function(cssText) {
        return this.convertColonRule(cssText, cssColonHostRe, this.colonHostPartReplacer);
      },
      convertColonHostContext: function(cssText) {
        return this.convertColonRule(cssText, cssColonHostContextRe, this.colonHostContextPartReplacer);
      },
      convertColonRule: function(cssText, regExp, partReplacer) {
        return cssText.replace(regExp, function(m, p1, p2, p3) {
          p1 = polyfillHostNoCombinator;
          if (p2) {
            var parts = p2.split(","), r = [];
            for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
              p = p.trim();
              r.push(partReplacer(p1, p, p3));
            }
            return r.join(",");
          } else {
            return p1 + p3;
          }
        });
      },
      colonHostContextPartReplacer: function(host, part, suffix) {
        if (part.match(polyfillHost)) {
          return this.colonHostPartReplacer(host, part, suffix);
        } else {
          return host + part + suffix + ", " + part + " " + host + suffix;
        }
      },
      colonHostPartReplacer: function(host, part, suffix) {
        return host + part.replace(polyfillHost, "") + suffix;
      },
      convertShadowDOMSelectors: function(cssText) {
        for (var i = 0; i < shadowDOMSelectorsRe.length; i++) {
          cssText = cssText.replace(shadowDOMSelectorsRe[i], " ");
        }
        return cssText;
      },
      scopeRules: function(cssRules, scopeSelector) {
        var cssText = "";
        if (cssRules) {
          Array.prototype.forEach.call(cssRules, function(rule) {
            if (rule.selectorText && (rule.style && rule.style.cssText !== undefined)) {
              cssText += this.scopeSelector(rule.selectorText, scopeSelector, this.strictStyling) + " {\n	";
              cssText += this.propertiesFromRule(rule) + "\n}\n\n";
            } else if (rule.type === CSSRule.MEDIA_RULE) {
              cssText += "@media " + rule.media.mediaText + " {\n";
              cssText += this.scopeRules(rule.cssRules, scopeSelector);
              cssText += "\n}\n\n";
            } else {
              try {
                if (rule.cssText) {
                  cssText += rule.cssText + "\n\n";
                }
              } catch (x) {
                if (rule.type === CSSRule.KEYFRAMES_RULE && rule.cssRules) {
                  cssText += this.ieSafeCssTextFromKeyFrameRule(rule);
                }
              }
            }
          }, this);
        }
        return cssText;
      },
      ieSafeCssTextFromKeyFrameRule: function(rule) {
        var cssText = "@keyframes " + rule.name + " {";
        Array.prototype.forEach.call(rule.cssRules, function(rule) {
          cssText += " " + rule.keyText + " {" + rule.style.cssText + "}";
        });
        cssText += " }";
        return cssText;
      },
      scopeSelector: function(selector, scopeSelector, strict) {
        var r = [], parts = selector.split(",");
        parts.forEach(function(p) {
          p = p.trim();
          if (this.selectorNeedsScoping(p, scopeSelector)) {
            p = strict && !p.match(polyfillHostNoCombinator) ? this.applyStrictSelectorScope(p, scopeSelector) : this.applySelectorScope(p, scopeSelector);
          }
          r.push(p);
        }, this);
        return r.join(", ");
      },
      selectorNeedsScoping: function(selector, scopeSelector) {
        if (Array.isArray(scopeSelector)) {
          return true;
        }
        var re = this.makeScopeMatcher(scopeSelector);
        return !selector.match(re);
      },
      makeScopeMatcher: function(scopeSelector) {
        scopeSelector = scopeSelector.replace(/\[/g, "\\[").replace(/\]/g, "\\]");
        return new RegExp("^(" + scopeSelector + ")" + selectorReSuffix, "m");
      },
      applySelectorScope: function(selector, selectorScope) {
        return Array.isArray(selectorScope) ? this.applySelectorScopeList(selector, selectorScope) : this.applySimpleSelectorScope(selector, selectorScope);
      },
      applySelectorScopeList: function(selector, scopeSelectorList) {
        var r = [];
        for (var i = 0, s; s = scopeSelectorList[i]; i++) {
          r.push(this.applySimpleSelectorScope(selector, s));
        }
        return r.join(", ");
      },
      applySimpleSelectorScope: function(selector, scopeSelector) {
        if (selector.match(polyfillHostRe)) {
          selector = selector.replace(polyfillHostNoCombinator, scopeSelector);
          return selector.replace(polyfillHostRe, scopeSelector + " ");
        } else {
          return scopeSelector + " " + selector;
        }
      },
      applyStrictSelectorScope: function(selector, scopeSelector) {
        scopeSelector = scopeSelector.replace(/\[is=([^\]]*)\]/g, "$1");
        var splits = [ " ", ">", "+", "~" ], scoped = selector, attrName = "[" + scopeSelector + "]";
        splits.forEach(function(sep) {
          var parts = scoped.split(sep);
          scoped = parts.map(function(p) {
            var t = p.trim().replace(polyfillHostRe, "");
            if (t && splits.indexOf(t) < 0 && t.indexOf(attrName) < 0) {
              p = t.replace(/([^:]*)(:*)(.*)/, "$1" + attrName + "$2$3");
            }
            return p;
          }).join(sep);
        });
        return scoped;
      },
      insertPolyfillHostInCssText: function(selector) {
        return selector.replace(colonHostContextRe, polyfillHostContext).replace(colonHostRe, polyfillHost);
      },
      propertiesFromRule: function(rule) {
        var cssText = rule.style.cssText;
        if (rule.style.content && !rule.style.content.match(/['"]+|attr/)) {
          cssText = cssText.replace(/content:[^;]*;/g, "content: '" + rule.style.content + "';");
        }
        var style = rule.style;
        for (var i in style) {
          if (style[i] === "initial") {
            cssText += i + ": initial; ";
          }
        }
        return cssText;
      },
      replaceTextInStyles: function(styles, action) {
        if (styles && action) {
          if (!(styles instanceof Array)) {
            styles = [ styles ];
          }
          Array.prototype.forEach.call(styles, function(s) {
            s.textContent = action.call(this, s.textContent);
          }, this);
        }
      },
      addCssToDocument: function(cssText, name) {
        if (cssText.match("@import")) {
          addOwnSheet(cssText, name);
        } else {
          addCssToDocument(cssText);
        }
      }
    };
    var selectorRe = /([^{]*)({[\s\S]*?})/gim, cssCommentRe = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim, cssCommentNextSelectorRe = /\/\*\s*@polyfill ([^*]*\*+([^/*][^*]*\*+)*\/)([^{]*?){/gim, cssContentNextSelectorRe = /polyfill-next-selector[^}]*content\:[\s]*?['"](.*?)['"][;\s]*}([^{]*?){/gim, cssCommentRuleRe = /\/\*\s@polyfill-rule([^*]*\*+([^/*][^*]*\*+)*)\//gim, cssContentRuleRe = /(polyfill-rule)[^}]*(content\:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim, cssCommentUnscopedRuleRe = /\/\*\s@polyfill-unscoped-rule([^*]*\*+([^/*][^*]*\*+)*)\//gim, cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content\:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim, cssPseudoRe = /::(x-[^\s{,(]*)/gim, cssPartRe = /::part\(([^)]*)\)/gim, polyfillHost = "-shadowcsshost", polyfillHostContext = "-shadowcsscontext", parenSuffix = ")(?:\\((" + "(?:\\([^)(]*\\)|[^)(]*)+?" + ")\\))?([^,{]*)";
    var cssColonHostRe = new RegExp("(" + polyfillHost + parenSuffix, "gim"), cssColonHostContextRe = new RegExp("(" + polyfillHostContext + parenSuffix, "gim"), selectorReSuffix = "([>\\s~+[.,{:][\\s\\S]*)?$", colonHostRe = /\:host/gim, colonHostContextRe = /\:host-context/gim, polyfillHostNoCombinator = polyfillHost + "-no-combinator", polyfillHostRe = new RegExp(polyfillHost, "gim"), polyfillHostContextRe = new RegExp(polyfillHostContext, "gim"), shadowDOMSelectorsRe = [ /\^\^/g, /\^/g, /\/shadow\//g, /\/shadow-deep\//g, /::shadow/g, /\/deep\//g, /::content/g ];
    function stylesToCssText(styles, preserveComments) {
      var cssText = "";
      Array.prototype.forEach.call(styles, function(s) {
        cssText += s.textContent + "\n\n";
      });
      if (!preserveComments) {
        cssText = cssText.replace(cssCommentRe, "");
      }
      return cssText;
    }
    function cssTextToStyle(cssText) {
      var style = document.createElement("style");
      style.textContent = cssText;
      return style;
    }
    function cssToRules(cssText) {
      var style = cssTextToStyle(cssText);
      document.head.appendChild(style);
      var rules = [];
      if (style.sheet) {
        try {
          rules = style.sheet.cssRules;
        } catch (e) {}
      } else {
        console.warn("sheet not found", style);
      }
      style.parentNode.removeChild(style);
      return rules;
    }
    var frame = document.createElement("iframe");
    frame.style.display = "none";
    function initFrame() {
      frame.initialized = true;
      document.body.appendChild(frame);
      var doc = frame.contentDocument;
      var base = doc.createElement("base");
      base.href = document.baseURI;
      doc.head.appendChild(base);
    }
    function inFrame(fn) {
      if (!frame.initialized) {
        initFrame();
      }
      document.body.appendChild(frame);
      fn(frame.contentDocument);
      document.body.removeChild(frame);
    }
    var isChrome = navigator.userAgent.match("Chrome");
    function withCssRules(cssText, callback) {
      if (!callback) {
        return;
      }
      var rules;
      if (cssText.match("@import") && isChrome) {
        var style = cssTextToStyle(cssText);
        inFrame(function(doc) {
          doc.head.appendChild(style.impl);
          rules = Array.prototype.slice.call(style.sheet.cssRules, 0);
          callback(rules);
        });
      } else {
        rules = cssToRules(cssText);
        callback(rules);
      }
    }
    function rulesToCss(cssRules) {
      for (var i = 0, css = []; i < cssRules.length; i++) {
        css.push(cssRules[i].cssText);
      }
      return css.join("\n\n");
    }
    function addCssToDocument(cssText) {
      if (cssText) {
        getSheet().appendChild(document.createTextNode(cssText));
      }
    }
    function addOwnSheet(cssText, name) {
      var style = cssTextToStyle(cssText);
      style.setAttribute(name, "");
      style.setAttribute(SHIMMED_ATTRIBUTE, "");
      document.head.appendChild(style);
    }
    var SHIM_ATTRIBUTE = "shim-shadowdom";
    var SHIMMED_ATTRIBUTE = "shim-shadowdom-css";
    var NO_SHIM_ATTRIBUTE = "no-shim";
    var sheet;
    function getSheet() {
      if (!sheet) {
        sheet = document.createElement("style");
        sheet.setAttribute(SHIMMED_ATTRIBUTE, "");
        sheet[SHIMMED_ATTRIBUTE] = true;
      }
      return sheet;
    }
    if (window.ShadowDOMPolyfill) {
      addCssToDocument("style { display: none !important; }\n");
      var doc = ShadowDOMPolyfill.wrap(document);
      var head = doc.querySelector("head");
      head.insertBefore(getSheet(), head.childNodes[0]);
      document.addEventListener("DOMContentLoaded", function() {
        var urlResolver = scope.urlResolver;
        if (window.HTMLImports && !HTMLImports.useNative) {
          var SHIM_SHEET_SELECTOR = "link[rel=stylesheet]" + "[" + SHIM_ATTRIBUTE + "]";
          var SHIM_STYLE_SELECTOR = "style[" + SHIM_ATTRIBUTE + "]";
          HTMLImports.importer.documentPreloadSelectors += "," + SHIM_SHEET_SELECTOR;
          HTMLImports.importer.importsPreloadSelectors += "," + SHIM_SHEET_SELECTOR;
          HTMLImports.parser.documentSelectors = [ HTMLImports.parser.documentSelectors, SHIM_SHEET_SELECTOR, SHIM_STYLE_SELECTOR ].join(",");
          var originalParseGeneric = HTMLImports.parser.parseGeneric;
          HTMLImports.parser.parseGeneric = function(elt) {
            if (elt[SHIMMED_ATTRIBUTE]) {
              return;
            }
            var style = elt.__importElement || elt;
            if (!style.hasAttribute(SHIM_ATTRIBUTE)) {
              originalParseGeneric.call(this, elt);
              return;
            }
            if (elt.__resource) {
              style = elt.ownerDocument.createElement("style");
              style.textContent = elt.__resource;
            }
            HTMLImports.path.resolveUrlsInStyle(style);
            style.textContent = ShadowCSS.shimStyle(style);
            style.removeAttribute(SHIM_ATTRIBUTE, "");
            style.setAttribute(SHIMMED_ATTRIBUTE, "");
            style[SHIMMED_ATTRIBUTE] = true;
            if (style.parentNode !== head) {
              if (elt.parentNode === head) {
                head.replaceChild(style, elt);
              } else {
                this.addElementToDocument(style);
              }
            }
            style.__importParsed = true;
            this.markParsingComplete(elt);
            this.parseNext();
          };
          var hasResource = HTMLImports.parser.hasResource;
          HTMLImports.parser.hasResource = function(node) {
            if (node.localName === "link" && node.rel === "stylesheet" && node.hasAttribute(SHIM_ATTRIBUTE)) {
              return node.__resource;
            } else {
              return hasResource.call(this, node);
            }
          };
        }
      });
    }
    scope.ShadowCSS = ShadowCSS;
  })(window.WebComponents);
}

(function(scope) {
  if (window.ShadowDOMPolyfill) {
    window.wrap = ShadowDOMPolyfill.wrapIfNeeded;
    window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;
  } else {
    window.wrap = window.unwrap = function(n) {
      return n;
    };
  }
})(window.WebComponents);

window.HTMLImports = window.HTMLImports || {
  flags: {}
};

(function(scope) {
  var IMPORT_LINK_TYPE = "import";
  var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement("link"));
  var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);
  var wrap = function(node) {
    return hasShadowDOMPolyfill ? ShadowDOMPolyfill.wrapIfNeeded(node) : node;
  };
  var rootDocument = wrap(document);
  var currentScriptDescriptor = {
    get: function() {
      var script = HTMLImports.currentScript || document.currentScript || (document.readyState !== "complete" ? document.scripts[document.scripts.length - 1] : null);
      return wrap(script);
    },
    configurable: true
  };
  Object.defineProperty(document, "_currentScript", currentScriptDescriptor);
  Object.defineProperty(rootDocument, "_currentScript", currentScriptDescriptor);
  var isIE = /Trident|Edge/.test(navigator.userAgent);
  function whenReady(callback, doc) {
    doc = doc || rootDocument;
    whenDocumentReady(function() {
      watchImportsLoad(callback, doc);
    }, doc);
  }
  var requiredReadyState = isIE ? "complete" : "interactive";
  var READY_EVENT = "readystatechange";
  function isDocumentReady(doc) {
    return doc.readyState === "complete" || doc.readyState === requiredReadyState;
  }
  function whenDocumentReady(callback, doc) {
    if (!isDocumentReady(doc)) {
      var checkReady = function() {
        if (doc.readyState === "complete" || doc.readyState === requiredReadyState) {
          doc.removeEventListener(READY_EVENT, checkReady);
          whenDocumentReady(callback, doc);
        }
      };
      doc.addEventListener(READY_EVENT, checkReady);
    } else if (callback) {
      callback();
    }
  }
  function markTargetLoaded(event) {
    event.target.__loaded = true;
  }
  function watchImportsLoad(callback, doc) {
    var imports = doc.querySelectorAll("link[rel=import]");
    var loaded = 0, l = imports.length;
    function checkDone(d) {
      if (loaded == l && callback) {
        callback();
      }
    }
    function loadedImport(e) {
      markTargetLoaded(e);
      loaded++;
      checkDone();
    }
    if (l) {
      for (var i = 0, imp; i < l && (imp = imports[i]); i++) {
        if (isImportLoaded(imp)) {
          loadedImport.call(imp, {
            target: imp
          });
        } else {
          imp.addEventListener("load", loadedImport);
          imp.addEventListener("error", loadedImport);
        }
      }
    } else {
      checkDone();
    }
  }
  function isImportLoaded(link) {
    return useNative ? link.__loaded || link.import && link.import.readyState !== "loading" : link.__importParsed;
  }
  if (useNative) {
    new MutationObserver(function(mxns) {
      for (var i = 0, l = mxns.length, m; i < l && (m = mxns[i]); i++) {
        if (m.addedNodes) {
          handleImports(m.addedNodes);
        }
      }
    }).observe(document.head, {
      childList: true
    });
    function handleImports(nodes) {
      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
        if (isImport(n)) {
          handleImport(n);
        }
      }
    }
    function isImport(element) {
      return element.localName === "link" && element.rel === "import";
    }
    function handleImport(element) {
      var loaded = element.import;
      if (loaded) {
        markTargetLoaded({
          target: element
        });
      } else {
        element.addEventListener("load", markTargetLoaded);
        element.addEventListener("error", markTargetLoaded);
      }
    }
    (function() {
      if (document.readyState === "loading") {
        var imports = document.querySelectorAll("link[rel=import]");
        for (var i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {
          handleImport(imp);
        }
      }
    })();
  }
  whenReady(function() {
    HTMLImports.ready = true;
    HTMLImports.readyTime = new Date().getTime();
    var evt = rootDocument.createEvent("CustomEvent");
    evt.initCustomEvent("HTMLImportsLoaded", true, true, {});
    rootDocument.dispatchEvent(evt);
  });
  scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;
  scope.useNative = useNative;
  scope.rootDocument = rootDocument;
  scope.whenReady = whenReady;
  scope.isIE = isIE;
})(HTMLImports);

(function(scope) {
  var modules = [];
  var addModule = function(module) {
    modules.push(module);
  };
  var initializeModules = function() {
    modules.forEach(function(module) {
      module(scope);
    });
  };
  scope.addModule = addModule;
  scope.initializeModules = initializeModules;
})(HTMLImports);

HTMLImports.addModule(function(scope) {
  var CSS_URL_REGEXP = /(url\()([^)]*)(\))/g;
  var CSS_IMPORT_REGEXP = /(@import[\s]+(?!url\())([^;]*)(;)/g;
  var path = {
    resolveUrlsInStyle: function(style) {
      var doc = style.ownerDocument;
      var resolver = doc.createElement("a");
      style.textContent = this.resolveUrlsInCssText(style.textContent, resolver);
      return style;
    },
    resolveUrlsInCssText: function(cssText, urlObj) {
      var r = this.replaceUrls(cssText, urlObj, CSS_URL_REGEXP);
      r = this.replaceUrls(r, urlObj, CSS_IMPORT_REGEXP);
      return r;
    },
    replaceUrls: function(text, urlObj, regexp) {
      return text.replace(regexp, function(m, pre, url, post) {
        var urlPath = url.replace(/["']/g, "");
        urlObj.href = urlPath;
        urlPath = urlObj.href;
        return pre + "'" + urlPath + "'" + post;
      });
    }
  };
  scope.path = path;
});

HTMLImports.addModule(function(scope) {
  var xhr = {
    async: true,
    ok: function(request) {
      return request.status >= 200 && request.status < 300 || request.status === 304 || request.status === 0;
    },
    load: function(url, next, nextContext) {
      var request = new XMLHttpRequest();
      if (scope.flags.debug || scope.flags.bust) {
        url += "?" + Math.random();
      }
      request.open("GET", url, xhr.async);
      request.addEventListener("readystatechange", function(e) {
        if (request.readyState === 4) {
          var locationHeader = request.getResponseHeader("Location");
          var redirectedUrl = null;
          if (locationHeader) {
            var redirectedUrl = locationHeader.substr(0, 1) === "/" ? location.origin + locationHeader : locationHeader;
          }
          next.call(nextContext, !xhr.ok(request) && request, request.response || request.responseText, redirectedUrl);
        }
      });
      request.send();
      return request;
    },
    loadDocument: function(url, next, nextContext) {
      this.load(url, next, nextContext).responseType = "document";
    }
  };
  scope.xhr = xhr;
});

HTMLImports.addModule(function(scope) {
  var xhr = scope.xhr;
  var flags = scope.flags;
  var Loader = function(onLoad, onComplete) {
    this.cache = {};
    this.onload = onLoad;
    this.oncomplete = onComplete;
    this.inflight = 0;
    this.pending = {};
  };
  Loader.prototype = {
    addNodes: function(nodes) {
      this.inflight += nodes.length;
      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
        this.require(n);
      }
      this.checkDone();
    },
    addNode: function(node) {
      this.inflight++;
      this.require(node);
      this.checkDone();
    },
    require: function(elt) {
      var url = elt.src || elt.href;
      elt.__nodeUrl = url;
      if (!this.dedupe(url, elt)) {
        this.fetch(url, elt);
      }
    },
    dedupe: function(url, elt) {
      if (this.pending[url]) {
        this.pending[url].push(elt);
        return true;
      }
      var resource;
      if (this.cache[url]) {
        this.onload(url, elt, this.cache[url]);
        this.tail();
        return true;
      }
      this.pending[url] = [ elt ];
      return false;
    },
    fetch: function(url, elt) {
      flags.load && console.log("fetch", url, elt);
      if (!url) {
        setTimeout(function() {
          this.receive(url, elt, {
            error: "href must be specified"
          }, null);
        }.bind(this), 0);
      } else if (url.match(/^data:/)) {
        var pieces = url.split(",");
        var header = pieces[0];
        var body = pieces[1];
        if (header.indexOf(";base64") > -1) {
          body = atob(body);
        } else {
          body = decodeURIComponent(body);
        }
        setTimeout(function() {
          this.receive(url, elt, null, body);
        }.bind(this), 0);
      } else {
        var receiveXhr = function(err, resource, redirectedUrl) {
          this.receive(url, elt, err, resource, redirectedUrl);
        }.bind(this);
        xhr.load(url, receiveXhr);
      }
    },
    receive: function(url, elt, err, resource, redirectedUrl) {
      this.cache[url] = resource;
      var $p = this.pending[url];
      for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
        this.onload(url, p, resource, err, redirectedUrl);
        this.tail();
      }
      this.pending[url] = null;
    },
    tail: function() {
      --this.inflight;
      this.checkDone();
    },
    checkDone: function() {
      if (!this.inflight) {
        this.oncomplete();
      }
    }
  };
  scope.Loader = Loader;
});

HTMLImports.addModule(function(scope) {
  var Observer = function(addCallback) {
    this.addCallback = addCallback;
    this.mo = new MutationObserver(this.handler.bind(this));
  };
  Observer.prototype = {
    handler: function(mutations) {
      for (var i = 0, l = mutations.length, m; i < l && (m = mutations[i]); i++) {
        if (m.type === "childList" && m.addedNodes.length) {
          this.addedNodes(m.addedNodes);
        }
      }
    },
    addedNodes: function(nodes) {
      if (this.addCallback) {
        this.addCallback(nodes);
      }
      for (var i = 0, l = nodes.length, n, loading; i < l && (n = nodes[i]); i++) {
        if (n.children && n.children.length) {
          this.addedNodes(n.children);
        }
      }
    },
    observe: function(root) {
      this.mo.observe(root, {
        childList: true,
        subtree: true
      });
    }
  };
  scope.Observer = Observer;
});

HTMLImports.addModule(function(scope) {
  var path = scope.path;
  var rootDocument = scope.rootDocument;
  var flags = scope.flags;
  var isIE = scope.isIE;
  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
  var IMPORT_SELECTOR = "link[rel=" + IMPORT_LINK_TYPE + "]";
  var importParser = {
    documentSelectors: IMPORT_SELECTOR,
    importsSelectors: [ IMPORT_SELECTOR, "link[rel=stylesheet]", "style", "script:not([type])", 'script[type="text/javascript"]' ].join(","),
    map: {
      link: "parseLink",
      script: "parseScript",
      style: "parseStyle"
    },
    dynamicElements: [],
    parseNext: function() {
      var next = this.nextToParse();
      if (next) {
        this.parse(next);
      }
    },
    parse: function(elt) {
      if (this.isParsed(elt)) {
        flags.parse && console.log("[%s] is already parsed", elt.localName);
        return;
      }
      var fn = this[this.map[elt.localName]];
      if (fn) {
        this.markParsing(elt);
        fn.call(this, elt);
      }
    },
    parseDynamic: function(elt, quiet) {
      this.dynamicElements.push(elt);
      if (!quiet) {
        this.parseNext();
      }
    },
    markParsing: function(elt) {
      flags.parse && console.log("parsing", elt);
      this.parsingElement = elt;
    },
    markParsingComplete: function(elt) {
      elt.__importParsed = true;
      this.markDynamicParsingComplete(elt);
      if (elt.__importElement) {
        elt.__importElement.__importParsed = true;
        this.markDynamicParsingComplete(elt.__importElement);
      }
      this.parsingElement = null;
      flags.parse && console.log("completed", elt);
    },
    markDynamicParsingComplete: function(elt) {
      var i = this.dynamicElements.indexOf(elt);
      if (i >= 0) {
        this.dynamicElements.splice(i, 1);
      }
    },
    parseImport: function(elt) {
      if (HTMLImports.__importsParsingHook) {
        HTMLImports.__importsParsingHook(elt);
      }
      if (elt.import) {
        elt.import.__importParsed = true;
      }
      this.markParsingComplete(elt);
      if (elt.__resource && !elt.__error) {
        elt.dispatchEvent(new CustomEvent("load", {
          bubbles: false
        }));
      } else {
        elt.dispatchEvent(new CustomEvent("error", {
          bubbles: false
        }));
      }
      if (elt.__pending) {
        var fn;
        while (elt.__pending.length) {
          fn = elt.__pending.shift();
          if (fn) {
            fn({
              target: elt
            });
          }
        }
      }
      this.parseNext();
    },
    parseLink: function(linkElt) {
      if (nodeIsImport(linkElt)) {
        this.parseImport(linkElt);
      } else {
        linkElt.href = linkElt.href;
        this.parseGeneric(linkElt);
      }
    },
    parseStyle: function(elt) {
      var src = elt;
      elt = cloneStyle(elt);
      elt.__importElement = src;
      this.parseGeneric(elt);
    },
    parseGeneric: function(elt) {
      this.trackElement(elt);
      this.addElementToDocument(elt);
    },
    rootImportForElement: function(elt) {
      var n = elt;
      while (n.ownerDocument.__importLink) {
        n = n.ownerDocument.__importLink;
      }
      return n;
    },
    addElementToDocument: function(elt) {
      var port = this.rootImportForElement(elt.__importElement || elt);
      port.parentNode.insertBefore(elt, port);
    },
    trackElement: function(elt, callback) {
      var self = this;
      var done = function(e) {
        if (callback) {
          callback(e);
        }
        self.markParsingComplete(elt);
        self.parseNext();
      };
      elt.addEventListener("load", done);
      elt.addEventListener("error", done);
      if (isIE && elt.localName === "style") {
        var fakeLoad = false;
        if (elt.textContent.indexOf("@import") == -1) {
          fakeLoad = true;
        } else if (elt.sheet) {
          fakeLoad = true;
          var csr = elt.sheet.cssRules;
          var len = csr ? csr.length : 0;
          for (var i = 0, r; i < len && (r = csr[i]); i++) {
            if (r.type === CSSRule.IMPORT_RULE) {
              fakeLoad = fakeLoad && Boolean(r.styleSheet);
            }
          }
        }
        if (fakeLoad) {
          elt.dispatchEvent(new CustomEvent("load", {
            bubbles: false
          }));
        }
      }
    },
    parseScript: function(scriptElt) {
      var script = document.createElement("script");
      script.__importElement = scriptElt;
      script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);
      scope.currentScript = scriptElt;
      this.trackElement(script, function(e) {
        script.parentNode.removeChild(script);
        scope.currentScript = null;
      });
      this.addElementToDocument(script);
    },
    nextToParse: function() {
      this._mayParse = [];
      return !this.parsingElement && (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());
    },
    nextToParseInDoc: function(doc, link) {
      if (doc && this._mayParse.indexOf(doc) < 0) {
        this._mayParse.push(doc);
        var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));
        for (var i = 0, l = nodes.length, p = 0, n; i < l && (n = nodes[i]); i++) {
          if (!this.isParsed(n)) {
            if (this.hasResource(n)) {
              return nodeIsImport(n) ? this.nextToParseInDoc(n.import, n) : n;
            } else {
              return;
            }
          }
        }
      }
      return link;
    },
    nextToParseDynamic: function() {
      return this.dynamicElements[0];
    },
    parseSelectorsForNode: function(node) {
      var doc = node.ownerDocument || node;
      return doc === rootDocument ? this.documentSelectors : this.importsSelectors;
    },
    isParsed: function(node) {
      return node.__importParsed;
    },
    needsDynamicParsing: function(elt) {
      return this.dynamicElements.indexOf(elt) >= 0;
    },
    hasResource: function(node) {
      if (nodeIsImport(node) && node.import === undefined) {
        return false;
      }
      return true;
    }
  };
  function nodeIsImport(elt) {
    return elt.localName === "link" && elt.rel === IMPORT_LINK_TYPE;
  }
  function generateScriptDataUrl(script) {
    var scriptContent = generateScriptContent(script);
    return "data:text/javascript;charset=utf-8," + encodeURIComponent(scriptContent);
  }
  function generateScriptContent(script) {
    return script.textContent + generateSourceMapHint(script);
  }
  function generateSourceMapHint(script) {
    var owner = script.ownerDocument;
    owner.__importedScripts = owner.__importedScripts || 0;
    var moniker = script.ownerDocument.baseURI;
    var num = owner.__importedScripts ? "-" + owner.__importedScripts : "";
    owner.__importedScripts++;
    return "\n//# sourceURL=" + moniker + num + ".js\n";
  }
  function cloneStyle(style) {
    var clone = style.ownerDocument.createElement("style");
    clone.textContent = style.textContent;
    path.resolveUrlsInStyle(clone);
    return clone;
  }
  scope.parser = importParser;
  scope.IMPORT_SELECTOR = IMPORT_SELECTOR;
});

HTMLImports.addModule(function(scope) {
  var flags = scope.flags;
  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
  var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;
  var rootDocument = scope.rootDocument;
  var Loader = scope.Loader;
  var Observer = scope.Observer;
  var parser = scope.parser;
  var importer = {
    documents: {},
    documentPreloadSelectors: IMPORT_SELECTOR,
    importsPreloadSelectors: [ IMPORT_SELECTOR ].join(","),
    loadNode: function(node) {
      importLoader.addNode(node);
    },
    loadSubtree: function(parent) {
      var nodes = this.marshalNodes(parent);
      importLoader.addNodes(nodes);
    },
    marshalNodes: function(parent) {
      return parent.querySelectorAll(this.loadSelectorsForNode(parent));
    },
    loadSelectorsForNode: function(node) {
      var doc = node.ownerDocument || node;
      return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;
    },
    loaded: function(url, elt, resource, err, redirectedUrl) {
      flags.load && console.log("loaded", url, elt);
      elt.__resource = resource;
      elt.__error = err;
      if (isImportLink(elt)) {
        var doc = this.documents[url];
        if (doc === undefined) {
          doc = err ? null : makeDocument(resource, redirectedUrl || url);
          if (doc) {
            doc.__importLink = elt;
            this.bootDocument(doc);
          }
          this.documents[url] = doc;
        }
        elt.import = doc;
      }
      parser.parseNext();
    },
    bootDocument: function(doc) {
      this.loadSubtree(doc);
      this.observer.observe(doc);
      parser.parseNext();
    },
    loadedAll: function() {
      parser.parseNext();
    }
  };
  var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));
  importer.observer = new Observer();
  function isImportLink(elt) {
    return isLinkRel(elt, IMPORT_LINK_TYPE);
  }
  function isLinkRel(elt, rel) {
    return elt.localName === "link" && elt.getAttribute("rel") === rel;
  }
  function hasBaseURIAccessor(doc) {
    return !!Object.getOwnPropertyDescriptor(doc, "baseURI");
  }
  function makeDocument(resource, url) {
    var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);
    doc._URL = url;
    var base = doc.createElement("base");
    base.setAttribute("href", url);
    if (!doc.baseURI && !hasBaseURIAccessor(doc)) {
      Object.defineProperty(doc, "baseURI", {
        value: url
      });
    }
    var meta = doc.createElement("meta");
    meta.setAttribute("charset", "utf-8");
    doc.head.appendChild(meta);
    doc.head.appendChild(base);
    doc.body.innerHTML = resource;
    if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {
      HTMLTemplateElement.bootstrap(doc);
    }
    return doc;
  }
  if (!document.baseURI) {
    var baseURIDescriptor = {
      get: function() {
        var base = document.querySelector("base");
        return base ? base.href : window.location.href;
      },
      configurable: true
    };
    Object.defineProperty(document, "baseURI", baseURIDescriptor);
    Object.defineProperty(rootDocument, "baseURI", baseURIDescriptor);
  }
  scope.importer = importer;
  scope.importLoader = importLoader;
});

HTMLImports.addModule(function(scope) {
  var parser = scope.parser;
  var importer = scope.importer;
  var dynamic = {
    added: function(nodes) {
      var owner, parsed, loading;
      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
        if (!owner) {
          owner = n.ownerDocument;
          parsed = parser.isParsed(owner);
        }
        loading = this.shouldLoadNode(n);
        if (loading) {
          importer.loadNode(n);
        }
        if (this.shouldParseNode(n) && parsed) {
          parser.parseDynamic(n, loading);
        }
      }
    },
    shouldLoadNode: function(node) {
      return node.nodeType === 1 && matches.call(node, importer.loadSelectorsForNode(node));
    },
    shouldParseNode: function(node) {
      return node.nodeType === 1 && matches.call(node, parser.parseSelectorsForNode(node));
    }
  };
  importer.observer.addCallback = dynamic.added.bind(dynamic);
  var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;
});

(function(scope) {
  var initializeModules = scope.initializeModules;
  var isIE = scope.isIE;
  if (scope.useNative) {
    return;
  }
  if (isIE && typeof window.CustomEvent !== "function") {
    window.CustomEvent = function(inType, params) {
      params = params || {};
      var e = document.createEvent("CustomEvent");
      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
      return e;
    };
    window.CustomEvent.prototype = window.Event.prototype;
  }
  initializeModules();
  var rootDocument = scope.rootDocument;
  function bootstrap() {
    HTMLImports.importer.bootDocument(rootDocument);
  }
  if (document.readyState === "complete" || document.readyState === "interactive" && !window.attachEvent) {
    bootstrap();
  } else {
    document.addEventListener("DOMContentLoaded", bootstrap);
  }
})(HTMLImports);

window.CustomElements = window.CustomElements || {
  flags: {}
};

(function(scope) {
  var flags = scope.flags;
  var modules = [];
  var addModule = function(module) {
    modules.push(module);
  };
  var initializeModules = function() {
    modules.forEach(function(module) {
      module(scope);
    });
  };
  scope.addModule = addModule;
  scope.initializeModules = initializeModules;
  scope.hasNative = Boolean(document.registerElement);
  scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || HTMLImports.useNative);
})(CustomElements);

CustomElements.addModule(function(scope) {
  var IMPORT_LINK_TYPE = window.HTMLImports ? HTMLImports.IMPORT_LINK_TYPE : "none";
  function forSubtree(node, cb) {
    findAllElements(node, function(e) {
      if (cb(e)) {
        return true;
      }
      forRoots(e, cb);
    });
    forRoots(node, cb);
  }
  function findAllElements(node, find, data) {
    var e = node.firstElementChild;
    if (!e) {
      e = node.firstChild;
      while (e && e.nodeType !== Node.ELEMENT_NODE) {
        e = e.nextSibling;
      }
    }
    while (e) {
      if (find(e, data) !== true) {
        findAllElements(e, find, data);
      }
      e = e.nextElementSibling;
    }
    return null;
  }
  function forRoots(node, cb) {
    var root = node.shadowRoot;
    while (root) {
      forSubtree(root, cb);
      root = root.olderShadowRoot;
    }
  }
  var processingDocuments;
  function forDocumentTree(doc, cb) {
    processingDocuments = [];
    _forDocumentTree(doc, cb);
    processingDocuments = null;
  }
  function _forDocumentTree(doc, cb) {
    doc = wrap(doc);
    if (processingDocuments.indexOf(doc) >= 0) {
      return;
    }
    processingDocuments.push(doc);
    var imports = doc.querySelectorAll("link[rel=" + IMPORT_LINK_TYPE + "]");
    for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {
      if (n.import) {
        _forDocumentTree(n.import, cb);
      }
    }
    cb(doc);
  }
  scope.forDocumentTree = forDocumentTree;
  scope.forSubtree = forSubtree;
});

CustomElements.addModule(function(scope) {
  var flags = scope.flags;
  var forSubtree = scope.forSubtree;
  var forDocumentTree = scope.forDocumentTree;
  function addedNode(node) {
    return added(node) || addedSubtree(node);
  }
  function added(node) {
    if (scope.upgrade(node)) {
      return true;
    }
    attached(node);
  }
  function addedSubtree(node) {
    forSubtree(node, function(e) {
      if (added(e)) {
        return true;
      }
    });
  }
  function attachedNode(node) {
    attached(node);
    if (inDocument(node)) {
      forSubtree(node, function(e) {
        attached(e);
      });
    }
  }
  var hasPolyfillMutations = !window.MutationObserver || window.MutationObserver === window.JsMutationObserver;
  scope.hasPolyfillMutations = hasPolyfillMutations;
  var isPendingMutations = false;
  var pendingMutations = [];
  function deferMutation(fn) {
    pendingMutations.push(fn);
    if (!isPendingMutations) {
      isPendingMutations = true;
      setTimeout(takeMutations);
    }
  }
  function takeMutations() {
    isPendingMutations = false;
    var $p = pendingMutations;
    for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
      p();
    }
    pendingMutations = [];
  }
  function attached(element) {
    if (hasPolyfillMutations) {
      deferMutation(function() {
        _attached(element);
      });
    } else {
      _attached(element);
    }
  }
  function _attached(element) {
    if (element.__upgraded__ && (element.attachedCallback || element.detachedCallback)) {
      if (!element.__attached && inDocument(element)) {
        element.__attached = true;
        if (element.attachedCallback) {
          element.attachedCallback();
        }
      }
    }
  }
  function detachedNode(node) {
    detached(node);
    forSubtree(node, function(e) {
      detached(e);
    });
  }
  function detached(element) {
    if (hasPolyfillMutations) {
      deferMutation(function() {
        _detached(element);
      });
    } else {
      _detached(element);
    }
  }
  function _detached(element) {
    if (element.__upgraded__ && (element.attachedCallback || element.detachedCallback)) {
      if (element.__attached && !inDocument(element)) {
        element.__attached = false;
        if (element.detachedCallback) {
          element.detachedCallback();
        }
      }
    }
  }
  function inDocument(element) {
    var p = element;
    var doc = wrap(document);
    while (p) {
      if (p == doc) {
        return true;
      }
      p = p.parentNode || p.host;
    }
  }
  function watchShadow(node) {
    if (node.shadowRoot && !node.shadowRoot.__watched) {
      flags.dom && console.log("watching shadow-root for: ", node.localName);
      var root = node.shadowRoot;
      while (root) {
        observe(root);
        root = root.olderShadowRoot;
      }
    }
  }
  function handler(mutations) {
    if (flags.dom) {
      var mx = mutations[0];
      if (mx && mx.type === "childList" && mx.addedNodes) {
        if (mx.addedNodes) {
          var d = mx.addedNodes[0];
          while (d && d !== document && !d.host) {
            d = d.parentNode;
          }
          var u = d && (d.URL || d._URL || d.host && d.host.localName) || "";
          u = u.split("/?").shift().split("/").pop();
        }
      }
      console.group("mutations (%d) [%s]", mutations.length, u || "");
    }
    mutations.forEach(function(mx) {
      if (mx.type === "childList") {
        forEach(mx.addedNodes, function(n) {
          if (!n.localName) {
            return;
          }
          addedNode(n);
        });
        forEach(mx.removedNodes, function(n) {
          if (!n.localName) {
            return;
          }
          detachedNode(n);
        });
      }
    });
    flags.dom && console.groupEnd();
  }
  function takeRecords(node) {
    node = wrap(node);
    if (!node) {
      node = wrap(document);
    }
    while (node.parentNode) {
      node = node.parentNode;
    }
    var observer = node.__observer;
    if (observer) {
      handler(observer.takeRecords());
      takeMutations();
    }
  }
  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  function observe(inRoot) {
    if (inRoot.__observer) {
      return;
    }
    var observer = new MutationObserver(handler);
    observer.observe(inRoot, {
      childList: true,
      subtree: true
    });
    inRoot.__observer = observer;
  }
  function upgradeDocument(doc) {
    doc = wrap(doc);
    flags.dom && console.group("upgradeDocument: ", doc.baseURI.split("/").pop());
    addedNode(doc);
    observe(doc);
    flags.dom && console.groupEnd();
  }
  function upgradeDocumentTree(doc) {
    forDocumentTree(doc, upgradeDocument);
  }
  var originalCreateShadowRoot = Element.prototype.createShadowRoot;
  if (originalCreateShadowRoot) {
    Element.prototype.createShadowRoot = function() {
      var root = originalCreateShadowRoot.call(this);
      CustomElements.watchShadow(this);
      return root;
    };
  }
  scope.watchShadow = watchShadow;
  scope.upgradeDocumentTree = upgradeDocumentTree;
  scope.upgradeSubtree = addedSubtree;
  scope.upgradeAll = addedNode;
  scope.attachedNode = attachedNode;
  scope.takeRecords = takeRecords;
});

CustomElements.addModule(function(scope) {
  var flags = scope.flags;
  function upgrade(node) {
    if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {
      var is = node.getAttribute("is");
      var definition = scope.getRegisteredDefinition(is || node.localName);
      if (definition) {
        if (is && definition.tag == node.localName) {
          return upgradeWithDefinition(node, definition);
        } else if (!is && !definition.extends) {
          return upgradeWithDefinition(node, definition);
        }
      }
    }
  }
  function upgradeWithDefinition(element, definition) {
    flags.upgrade && console.group("upgrade:", element.localName);
    if (definition.is) {
      element.setAttribute("is", definition.is);
    }
    implementPrototype(element, definition);
    element.__upgraded__ = true;
    created(element);
    scope.attachedNode(element);
    scope.upgradeSubtree(element);
    flags.upgrade && console.groupEnd();
    return element;
  }
  function implementPrototype(element, definition) {
    if (Object.__proto__) {
      element.__proto__ = definition.prototype;
    } else {
      customMixin(element, definition.prototype, definition.native);
      element.__proto__ = definition.prototype;
    }
  }
  function customMixin(inTarget, inSrc, inNative) {
    var used = {};
    var p = inSrc;
    while (p !== inNative && p !== HTMLElement.prototype) {
      var keys = Object.getOwnPropertyNames(p);
      for (var i = 0, k; k = keys[i]; i++) {
        if (!used[k]) {
          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));
          used[k] = 1;
        }
      }
      p = Object.getPrototypeOf(p);
    }
  }
  function created(element) {
    if (element.createdCallback) {
      element.createdCallback();
    }
  }
  scope.upgrade = upgrade;
  scope.upgradeWithDefinition = upgradeWithDefinition;
  scope.implementPrototype = implementPrototype;
});

CustomElements.addModule(function(scope) {
  var upgradeDocumentTree = scope.upgradeDocumentTree;
  var upgrade = scope.upgrade;
  var upgradeWithDefinition = scope.upgradeWithDefinition;
  var implementPrototype = scope.implementPrototype;
  var useNative = scope.useNative;
  function register(name, options) {
    var definition = options || {};
    if (!name) {
      throw new Error("document.registerElement: first argument `name` must not be empty");
    }
    if (name.indexOf("-") < 0) {
      throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '" + String(name) + "'.");
    }
    if (isReservedTag(name)) {
      throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '" + String(name) + "'. The type name is invalid.");
    }
    if (getRegisteredDefinition(name)) {
      throw new Error("DuplicateDefinitionError: a type with name '" + String(name) + "' is already registered");
    }
    if (!definition.prototype) {
      definition.prototype = Object.create(HTMLElement.prototype);
    }
    definition.__name = name.toLowerCase();
    definition.lifecycle = definition.lifecycle || {};
    definition.ancestry = ancestry(definition.extends);
    resolveTagName(definition);
    resolvePrototypeChain(definition);
    overrideAttributeApi(definition.prototype);
    registerDefinition(definition.__name, definition);
    definition.ctor = generateConstructor(definition);
    definition.ctor.prototype = definition.prototype;
    definition.prototype.constructor = definition.ctor;
    if (scope.ready) {
      upgradeDocumentTree(document);
    }
    return definition.ctor;
  }
  function overrideAttributeApi(prototype) {
    if (prototype.setAttribute._polyfilled) {
      return;
    }
    var setAttribute = prototype.setAttribute;
    prototype.setAttribute = function(name, value) {
      changeAttribute.call(this, name, value, setAttribute);
    };
    var removeAttribute = prototype.removeAttribute;
    prototype.removeAttribute = function(name) {
      changeAttribute.call(this, name, null, removeAttribute);
    };
    prototype.setAttribute._polyfilled = true;
  }
  function changeAttribute(name, value, operation) {
    name = name.toLowerCase();
    var oldValue = this.getAttribute(name);
    operation.apply(this, arguments);
    var newValue = this.getAttribute(name);
    if (this.attributeChangedCallback && newValue !== oldValue) {
      this.attributeChangedCallback(name, oldValue, newValue);
    }
  }
  function isReservedTag(name) {
    for (var i = 0; i < reservedTagList.length; i++) {
      if (name === reservedTagList[i]) {
        return true;
      }
    }
  }
  var reservedTagList = [ "annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph" ];
  function ancestry(extnds) {
    var extendee = getRegisteredDefinition(extnds);
    if (extendee) {
      return ancestry(extendee.extends).concat([ extendee ]);
    }
    return [];
  }
  function resolveTagName(definition) {
    var baseTag = definition.extends;
    for (var i = 0, a; a = definition.ancestry[i]; i++) {
      baseTag = a.is && a.tag;
    }
    definition.tag = baseTag || definition.__name;
    if (baseTag) {
      definition.is = definition.__name;
    }
  }
  function resolvePrototypeChain(definition) {
    if (!Object.__proto__) {
      var nativePrototype = HTMLElement.prototype;
      if (definition.is) {
        var inst = document.createElement(definition.tag);
        var expectedPrototype = Object.getPrototypeOf(inst);
        if (expectedPrototype === definition.prototype) {
          nativePrototype = expectedPrototype;
        }
      }
      var proto = definition.prototype, ancestor;
      while (proto && proto !== nativePrototype) {
        ancestor = Object.getPrototypeOf(proto);
        proto.__proto__ = ancestor;
        proto = ancestor;
      }
      definition.native = nativePrototype;
    }
  }
  function instantiate(definition) {
    return upgradeWithDefinition(domCreateElement(definition.tag), definition);
  }
  var registry = {};
  function getRegisteredDefinition(name) {
    if (name) {
      return registry[name.toLowerCase()];
    }
  }
  function registerDefinition(name, definition) {
    registry[name] = definition;
  }
  function generateConstructor(definition) {
    return function() {
      return instantiate(definition);
    };
  }
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  function createElementNS(namespace, tag, typeExtension) {
    if (namespace === HTML_NAMESPACE) {
      return createElement(tag, typeExtension);
    } else {
      return domCreateElementNS(namespace, tag);
    }
  }
  function createElement(tag, typeExtension) {
    var definition = getRegisteredDefinition(typeExtension || tag);
    if (definition) {
      if (tag == definition.tag && typeExtension == definition.is) {
        return new definition.ctor();
      }
      if (!typeExtension && !definition.is) {
        return new definition.ctor();
      }
    }
    var element;
    if (typeExtension) {
      element = createElement(tag);
      element.setAttribute("is", typeExtension);
      return element;
    }
    element = domCreateElement(tag);
    if (tag.indexOf("-") >= 0) {
      implementPrototype(element, HTMLElement);
    }
    return element;
  }
  function cloneNode(deep) {
    var n = domCloneNode.call(this, deep);
    upgrade(n);
    return n;
  }
  var domCreateElement = document.createElement.bind(document);
  var domCreateElementNS = document.createElementNS.bind(document);
  var domCloneNode = Node.prototype.cloneNode;
  var isInstance;
  if (!Object.__proto__ && !useNative) {
    isInstance = function(obj, ctor) {
      var p = obj;
      while (p) {
        if (p === ctor.prototype) {
          return true;
        }
        p = p.__proto__;
      }
      return false;
    };
  } else {
    isInstance = function(obj, base) {
      return obj instanceof base;
    };
  }
  document.registerElement = register;
  document.createElement = createElement;
  document.createElementNS = createElementNS;
  Node.prototype.cloneNode = cloneNode;
  scope.registry = registry;
  scope.instanceof = isInstance;
  scope.reservedTagList = reservedTagList;
  scope.getRegisteredDefinition = getRegisteredDefinition;
  document.register = document.registerElement;
});

(function(scope) {
  var useNative = scope.useNative;
  var initializeModules = scope.initializeModules;
  var isIE11OrOlder = /Trident/.test(navigator.userAgent);
  if (useNative) {
    var nop = function() {};
    scope.watchShadow = nop;
    scope.upgrade = nop;
    scope.upgradeAll = nop;
    scope.upgradeDocumentTree = nop;
    scope.upgradeSubtree = nop;
    scope.takeRecords = nop;
    scope.instanceof = function(obj, base) {
      return obj instanceof base;
    };
  } else {
    initializeModules();
  }
  var upgradeDocumentTree = scope.upgradeDocumentTree;
  if (!window.wrap) {
    if (window.ShadowDOMPolyfill) {
      window.wrap = ShadowDOMPolyfill.wrapIfNeeded;
      window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;
    } else {
      window.wrap = window.unwrap = function(node) {
        return node;
      };
    }
  }
  function bootstrap() {
    upgradeDocumentTree(wrap(document));
    if (window.HTMLImports) {
      HTMLImports.__importsParsingHook = function(elt) {
        upgradeDocumentTree(wrap(elt.import));
      };
    }
    CustomElements.ready = true;
    setTimeout(function() {
      CustomElements.readyTime = Date.now();
      if (window.HTMLImports) {
        CustomElements.elapsed = CustomElements.readyTime - HTMLImports.readyTime;
      }
      document.dispatchEvent(new CustomEvent("WebComponentsReady", {
        bubbles: true
      }));
    });
  }
  if (isIE11OrOlder && typeof window.CustomEvent !== "function") {
    window.CustomEvent = function(inType, params) {
      params = params || {};
      var e = document.createEvent("CustomEvent");
      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
      return e;
    };
    window.CustomEvent.prototype = window.Event.prototype;
  }
  if (document.readyState === "complete" || scope.flags.eager) {
    bootstrap();
  } else if (document.readyState === "interactive" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {
    bootstrap();
  } else {
    var loadEvent = window.HTMLImports && !HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
    window.addEventListener(loadEvent, bootstrap);
  }
})(window.CustomElements);

(function(scope) {
  if (!Function.prototype.bind) {
    Function.prototype.bind = function(scope) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
      return function() {
        var args2 = args.slice();
        args2.push.apply(args2, arguments);
        return self.apply(scope, args2);
      };
    };
  }
})(window.WebComponents);

(function(scope) {
  "use strict";
  if (!window.performance) {
    var start = Date.now();
    window.performance = {
      now: function() {
        return Date.now() - start;
      }
    };
  }
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function() {
      var nativeRaf = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
      return nativeRaf ? function(callback) {
        return nativeRaf(function() {
          callback(performance.now());
        });
      } : function(callback) {
        return window.setTimeout(callback, 1e3 / 60);
      };
    }();
  }
  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function() {
      return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id) {
        clearTimeout(id);
      };
    }();
  }
  var elementDeclarations = [];
  var polymerStub = function(name, dictionary) {
    if (typeof name !== "string" && arguments.length === 1) {
      Array.prototype.push.call(arguments, document._currentScript);
    }
    elementDeclarations.push(arguments);
  };
  window.Polymer = polymerStub;
  scope.consumeDeclarations = function(callback) {
    scope.consumeDeclarations = function() {
      throw "Possible attempt to load Polymer twice";
    };
    if (callback) {
      callback(elementDeclarations);
    }
    elementDeclarations = null;
  };
  function installPolymerWarning() {
    if (window.Polymer === polymerStub) {
      window.Polymer = function() {
        throw new Error("You tried to use polymer without loading it first. To " + 'load polymer, <link rel="import" href="' + 'components/polymer/polymer.html">');
      };
    }
  }
  if (HTMLImports.useNative) {
    installPolymerWarning();
  } else {
    addEventListener("DOMContentLoaded", installPolymerWarning);
  }
})(window.WebComponents);

(function(scope) {
  var style = document.createElement("style");
  style.textContent = "" + "body {" + "transition: opacity ease-in 0.2s;" + " } \n" + "body[unresolved] {" + "opacity: 0; display: block; overflow: hidden; position: relative;" + " } \n";
  var head = document.querySelector("head");
  head.insertBefore(style, head.firstChild);
})(window.WebComponents);

(function(scope) {
  window.Platform = scope;
})(window.WebComponents);</script>

    <!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><style shim-shadowdom="">
/*******************************
          Flex Layout
*******************************/

html /deep/ [layout][horizontal], html /deep/ [layout][vertical] {
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
}

html /deep/ [layout][horizontal][inline], html /deep/ [layout][vertical][inline] {
  display: -ms-inline-flexbox;
  display: -webkit-inline-flex;
  display: inline-flex;
}

html /deep/ [layout][horizontal] {
  -ms-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

html /deep/ [layout][horizontal][reverse] {
  -ms-flex-direction: row-reverse;
  -webkit-flex-direction: row-reverse;
  flex-direction: row-reverse;
}

html /deep/ [layout][vertical] {
  -ms-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}

html /deep/ [layout][vertical][reverse] {
  -ms-flex-direction: column-reverse;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
}

html /deep/ [layout][wrap] {
  -ms-flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
}

html /deep/ [layout][wrap-reverse] {
  -ms-flex-wrap: wrap-reverse;
  -webkit-flex-wrap: wrap-reverse;
  flex-wrap: wrap-reverse;
}

html /deep/ [flex] {
  -ms-flex: 1 1 0.000000001px;
  -webkit-flex: 1;
  flex: 1;
  -webkit-flex-basis: 0.000000001px;
  flex-basis: 0.000000001px;
}

html /deep/ [vertical][layout] > [flex][auto-vertical], html /deep/ [vertical][layout]::shadow [flex][auto-vertical] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html /deep/ [flex][auto] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html /deep/ [flex][none] {
  -ms-flex: none;
  -webkit-flex: none;
  flex: none;
}

html /deep/ [flex][one] {
  -ms-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

html /deep/ [flex][two] {
  -ms-flex: 2;
  -webkit-flex: 2;
  flex: 2;
}

html /deep/ [flex][three] {
  -ms-flex: 3;
  -webkit-flex: 3;
  flex: 3;
}

html /deep/ [flex][four] {
  -ms-flex: 4;
  -webkit-flex: 4;
  flex: 4;
}

html /deep/ [flex][five] {
  -ms-flex: 5;
  -webkit-flex: 5;
  flex: 5;
}

html /deep/ [flex][six] {
  -ms-flex: 6;
  -webkit-flex: 6;
  flex: 6;
}

html /deep/ [flex][seven] {
  -ms-flex: 7;
  -webkit-flex: 7;
  flex: 7;
}

html /deep/ [flex][eight] {
  -ms-flex: 8;
  -webkit-flex: 8;
  flex: 8;
}

html /deep/ [flex][nine] {
  -ms-flex: 9;
  -webkit-flex: 9;
  flex: 9;
}

html /deep/ [flex][ten] {
  -ms-flex: 10;
  -webkit-flex: 10;
  flex: 10;
}

html /deep/ [flex][eleven] {
  -ms-flex: 11;
  -webkit-flex: 11;
  flex: 11;
}

html /deep/ [flex][twelve] {
  -ms-flex: 12;
  -webkit-flex: 12;
  flex: 12;
}

/* alignment in cross axis */

html /deep/ [layout][start] {
  -ms-flex-align: start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}

html /deep/ [layout][center], html /deep/ [layout][center-center] {
  -ms-flex-align: center;
  -webkit-align-items: center;
  align-items: center;
}

html /deep/ [layout][end] {
  -ms-flex-align: end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

/* alignment in main axis */

html /deep/ [layout][start-justified] {
  -ms-flex-pack: start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

html /deep/ [layout][center-justified], html /deep/ [layout][center-center] {
  -ms-flex-pack: center;
  -webkit-justify-content: center;
  justify-content: center;
}

html /deep/ [layout][end-justified] {
  -ms-flex-pack: end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

html /deep/ [layout][around-justified] {
  -ms-flex-pack: distribute;
  -webkit-justify-content: space-around;
  justify-content: space-around;
}

html /deep/ [layout][justified] {
  -ms-flex-pack: justify;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}

/* self alignment */

html /deep/ [self-start] {
  -ms-align-self: flex-start;
  -webkit-align-self: flex-start;
  align-self: flex-start;
}

html /deep/ [self-center] {
  -ms-align-self: center;
  -webkit-align-self: center;
  align-self: center;
}

html /deep/ [self-end] {
  -ms-align-self: flex-end;
  -webkit-align-self: flex-end;
  align-self: flex-end;
}

html /deep/ [self-stretch] {
  -ms-align-self: stretch;
  -webkit-align-self: stretch;
  align-self: stretch;
}

/*******************************
          Other Layout
*******************************/

html /deep/ [block] {
  display: block;
}

/* ie support for hidden */
html /deep/ [hidden] {
  display: none !important;
}

html /deep/ [relative] {
  position: relative;
}

html /deep/ [fit] {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

body[fullbleed] {
  margin: 0;
  height: 100vh;
}

/*******************************
            Other
*******************************/

html /deep/ [segment], html /deep/ segment {
  display: block;
  position: relative;
  -webkit-box-sizing: border-box;
  -ms-box-sizing: border-box;
  box-sizing: border-box;
  margin: 1em 0.5em;
  padding: 1em;
  background-color: white;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  border-radius: 5px 5px 5px 5px;
}

</style>

<script>/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.5.5
window.PolymerGestures = {};

(function(scope) {
  var hasFullPath = false;

  // test for full event path support
  var pathTest = document.createElement('meta');
  if (pathTest.createShadowRoot) {
    var sr = pathTest.createShadowRoot();
    var s = document.createElement('span');
    sr.appendChild(s);
    pathTest.addEventListener('testpath', function(ev) {
      if (ev.path) {
        // if the span is in the event path, then path[0] is the real source for all events
        hasFullPath = ev.path[0] === s;
      }
      ev.stopPropagation();
    });
    var ev = new CustomEvent('testpath', {bubbles: true});
    // must add node to DOM to trigger event listener
    document.head.appendChild(pathTest);
    s.dispatchEvent(ev);
    pathTest.parentNode.removeChild(pathTest);
    sr = s = null;
  }
  pathTest = null;

  var target = {
    shadow: function(inEl) {
      if (inEl) {
        return inEl.shadowRoot || inEl.webkitShadowRoot;
      }
    },
    canTarget: function(shadow) {
      return shadow && Boolean(shadow.elementFromPoint);
    },
    targetingShadow: function(inEl) {
      var s = this.shadow(inEl);
      if (this.canTarget(s)) {
        return s;
      }
    },
    olderShadow: function(shadow) {
      var os = shadow.olderShadowRoot;
      if (!os) {
        var se = shadow.querySelector('shadow');
        if (se) {
          os = se.olderShadowRoot;
        }
      }
      return os;
    },
    allShadows: function(element) {
      var shadows = [], s = this.shadow(element);
      while(s) {
        shadows.push(s);
        s = this.olderShadow(s);
      }
      return shadows;
    },
    searchRoot: function(inRoot, x, y) {
      var t, st, sr, os;
      if (inRoot) {
        t = inRoot.elementFromPoint(x, y);
        if (t) {
          // found element, check if it has a ShadowRoot
          sr = this.targetingShadow(t);
        } else if (inRoot !== document) {
          // check for sibling roots
          sr = this.olderShadow(inRoot);
        }
        // search other roots, fall back to light dom element
        return this.searchRoot(sr, x, y) || t;
      }
    },
    owner: function(element) {
      if (!element) {
        return document;
      }
      var s = element;
      // walk up until you hit the shadow root or document
      while (s.parentNode) {
        s = s.parentNode;
      }
      // the owner element is expected to be a Document or ShadowRoot
      if (s.nodeType != Node.DOCUMENT_NODE && s.nodeType != Node.DOCUMENT_FRAGMENT_NODE) {
        s = document;
      }
      return s;
    },
    findTarget: function(inEvent) {
      if (hasFullPath && inEvent.path && inEvent.path.length) {
        return inEvent.path[0];
      }
      var x = inEvent.clientX, y = inEvent.clientY;
      // if the listener is in the shadow root, it is much faster to start there
      var s = this.owner(inEvent.target);
      // if x, y is not in this root, fall back to document search
      if (!s.elementFromPoint(x, y)) {
        s = document;
      }
      return this.searchRoot(s, x, y);
    },
    findTouchAction: function(inEvent) {
      var n;
      if (hasFullPath && inEvent.path && inEvent.path.length) {
        var path = inEvent.path;
        for (var i = 0; i < path.length; i++) {
          n = path[i];
          if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {
            return n.getAttribute('touch-action');
          }
        }
      } else {
        n = inEvent.target;
        while(n) {
          if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {
            return n.getAttribute('touch-action');
          }
          n = n.parentNode || n.host;
        }
      }
      // auto is default
      return "auto";
    },
    LCA: function(a, b) {
      if (a === b) {
        return a;
      }
      if (a && !b) {
        return a;
      }
      if (b && !a) {
        return b;
      }
      if (!b && !a) {
        return document;
      }
      // fast case, a is a direct descendant of b or vice versa
      if (a.contains && a.contains(b)) {
        return a;
      }
      if (b.contains && b.contains(a)) {
        return b;
      }
      var adepth = this.depth(a);
      var bdepth = this.depth(b);
      var d = adepth - bdepth;
      if (d >= 0) {
        a = this.walk(a, d);
      } else {
        b = this.walk(b, -d);
      }
      while (a && b && a !== b) {
        a = a.parentNode || a.host;
        b = b.parentNode || b.host;
      }
      return a;
    },
    walk: function(n, u) {
      for (var i = 0; n && (i < u); i++) {
        n = n.parentNode || n.host;
      }
      return n;
    },
    depth: function(n) {
      var d = 0;
      while(n) {
        d++;
        n = n.parentNode || n.host;
      }
      return d;
    },
    deepContains: function(a, b) {
      var common = this.LCA(a, b);
      // if a is the common ancestor, it must "deeply" contain b
      return common === a;
    },
    insideNode: function(node, x, y) {
      var rect = node.getBoundingClientRect();
      return (rect.left <= x) && (x <= rect.right) && (rect.top <= y) && (y <= rect.bottom);
    },
    path: function(event) {
      var p;
      if (hasFullPath && event.path && event.path.length) {
        p = event.path;
      } else {
        p = [];
        var n = this.findTarget(event);
        while (n) {
          p.push(n);
          n = n.parentNode || n.host;
        }
      }
      return p;
    }
  };
  scope.targetFinding = target;
  /**
   * Given an event, finds the "deepest" node that could have been the original target before ShadowDOM retargetting
   *
   * @param {Event} Event An event object with clientX and clientY properties
   * @return {Element} The probable event origninator
   */
  scope.findTarget = target.findTarget.bind(target);
  /**
   * Determines if the "container" node deeply contains the "containee" node, including situations where the "containee" is contained by one or more ShadowDOM
   * roots.
   *
   * @param {Node} container
   * @param {Node} containee
   * @return {Boolean}
   */
  scope.deepContains = target.deepContains.bind(target);

  /**
   * Determines if the x/y position is inside the given node.
   *
   * Example:
   *
   *     function upHandler(event) {
   *       var innode = PolymerGestures.insideNode(event.target, event.clientX, event.clientY);
   *       if (innode) {
   *         // wait for tap?
   *       } else {
   *         // tap will never happen
   *       }
   *     }
   *
   * @param {Node} node
   * @param {Number} x Screen X position
   * @param {Number} y screen Y position
   * @return {Boolean}
   */
  scope.insideNode = target.insideNode;

})(window.PolymerGestures);

(function() {
  function shadowSelector(v) {
    return 'html /deep/ ' + selector(v);
  }
  function selector(v) {
    return '[touch-action="' + v + '"]';
  }
  function rule(v) {
    return '{ -ms-touch-action: ' + v + '; touch-action: ' + v + ';}';
  }
  var attrib2css = [
    'none',
    'auto',
    'pan-x',
    'pan-y',
    {
      rule: 'pan-x pan-y',
      selectors: [
        'pan-x pan-y',
        'pan-y pan-x'
      ]
    },
    'manipulation'
  ];
  var styles = '';
  // only install stylesheet if the browser has touch action support
  var hasTouchAction = typeof document.head.style.touchAction === 'string';
  // only add shadow selectors if shadowdom is supported
  var hasShadowRoot = !window.ShadowDOMPolyfill && document.head.createShadowRoot;

  if (hasTouchAction) {
    attrib2css.forEach(function(r) {
      if (String(r) === r) {
        styles += selector(r) + rule(r) + '\n';
        if (hasShadowRoot) {
          styles += shadowSelector(r) + rule(r) + '\n';
        }
      } else {
        styles += r.selectors.map(selector) + rule(r.rule) + '\n';
        if (hasShadowRoot) {
          styles += r.selectors.map(shadowSelector) + rule(r.rule) + '\n';
        }
      }
    });

    var el = document.createElement('style');
    el.textContent = styles;
    document.head.appendChild(el);
  }
})();

/**
 * This is the constructor for new PointerEvents.
 *
 * New Pointer Events must be given a type, and an optional dictionary of
 * initialization properties.
 *
 * Due to certain platform requirements, events returned from the constructor
 * identify as MouseEvents.
 *
 * @constructor
 * @param {String} inType The type of the event to create.
 * @param {Object} [inDict] An optional dictionary of initial event properties.
 * @return {Event} A new PointerEvent of type `inType` and initialized with properties from `inDict`.
 */
(function(scope) {

  var MOUSE_PROPS = [
    'bubbles',
    'cancelable',
    'view',
    'detail',
    'screenX',
    'screenY',
    'clientX',
    'clientY',
    'ctrlKey',
    'altKey',
    'shiftKey',
    'metaKey',
    'button',
    'relatedTarget',
    'pageX',
    'pageY'
  ];

  var MOUSE_DEFAULTS = [
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    0,
    0
  ];

  var NOP_FACTORY = function(){ return function(){}; };

  var eventFactory = {
    // TODO(dfreedm): this is overridden by tap recognizer, needs review
    preventTap: NOP_FACTORY,
    makeBaseEvent: function(inType, inDict) {
      var e = document.createEvent('Event');
      e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);
      e.preventTap = eventFactory.preventTap(e);
      return e;
    },
    makeGestureEvent: function(inType, inDict) {
      inDict = inDict || Object.create(null);

      var e = this.makeBaseEvent(inType, inDict);
      for (var i = 0, keys = Object.keys(inDict), k; i < keys.length; i++) {
        k = keys[i];
        if( k !== 'bubbles' && k !== 'cancelable' ) {
           e[k] = inDict[k];
        }
      }
      return e;
    },
    makePointerEvent: function(inType, inDict) {
      inDict = inDict || Object.create(null);

      var e = this.makeBaseEvent(inType, inDict);
      // define inherited MouseEvent properties
      for(var i = 2, p; i < MOUSE_PROPS.length; i++) {
        p = MOUSE_PROPS[i];
        e[p] = inDict[p] || MOUSE_DEFAULTS[i];
      }
      e.buttons = inDict.buttons || 0;

      // Spec requires that pointers without pressure specified use 0.5 for down
      // state and 0 for up state.
      var pressure = 0;
      if (inDict.pressure) {
        pressure = inDict.pressure;
      } else {
        pressure = e.buttons ? 0.5 : 0;
      }

      // add x/y properties aliased to clientX/Y
      e.x = e.clientX;
      e.y = e.clientY;

      // define the properties of the PointerEvent interface
      e.pointerId = inDict.pointerId || 0;
      e.width = inDict.width || 0;
      e.height = inDict.height || 0;
      e.pressure = pressure;
      e.tiltX = inDict.tiltX || 0;
      e.tiltY = inDict.tiltY || 0;
      e.pointerType = inDict.pointerType || '';
      e.hwTimestamp = inDict.hwTimestamp || 0;
      e.isPrimary = inDict.isPrimary || false;
      e._source = inDict._source || '';
      return e;
    }
  };

  scope.eventFactory = eventFactory;
})(window.PolymerGestures);

/**
 * This module implements an map of pointer states
 */
(function(scope) {
  var USE_MAP = window.Map && window.Map.prototype.forEach;
  var POINTERS_FN = function(){ return this.size; };
  function PointerMap() {
    if (USE_MAP) {
      var m = new Map();
      m.pointers = POINTERS_FN;
      return m;
    } else {
      this.keys = [];
      this.values = [];
    }
  }

  PointerMap.prototype = {
    set: function(inId, inEvent) {
      var i = this.keys.indexOf(inId);
      if (i > -1) {
        this.values[i] = inEvent;
      } else {
        this.keys.push(inId);
        this.values.push(inEvent);
      }
    },
    has: function(inId) {
      return this.keys.indexOf(inId) > -1;
    },
    'delete': function(inId) {
      var i = this.keys.indexOf(inId);
      if (i > -1) {
        this.keys.splice(i, 1);
        this.values.splice(i, 1);
      }
    },
    get: function(inId) {
      var i = this.keys.indexOf(inId);
      return this.values[i];
    },
    clear: function() {
      this.keys.length = 0;
      this.values.length = 0;
    },
    // return value, key, map
    forEach: function(callback, thisArg) {
      this.values.forEach(function(v, i) {
        callback.call(thisArg, v, this.keys[i], this);
      }, this);
    },
    pointers: function() {
      return this.keys.length;
    }
  };

  scope.PointerMap = PointerMap;
})(window.PolymerGestures);

(function(scope) {
  var CLONE_PROPS = [
    // MouseEvent
    'bubbles',
    'cancelable',
    'view',
    'detail',
    'screenX',
    'screenY',
    'clientX',
    'clientY',
    'ctrlKey',
    'altKey',
    'shiftKey',
    'metaKey',
    'button',
    'relatedTarget',
    // DOM Level 3
    'buttons',
    // PointerEvent
    'pointerId',
    'width',
    'height',
    'pressure',
    'tiltX',
    'tiltY',
    'pointerType',
    'hwTimestamp',
    'isPrimary',
    // event instance
    'type',
    'target',
    'currentTarget',
    'which',
    'pageX',
    'pageY',
    'timeStamp',
    // gesture addons
    'preventTap',
    'tapPrevented',
    '_source'
  ];

  var CLONE_DEFAULTS = [
    // MouseEvent
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    // DOM Level 3
    0,
    // PointerEvent
    0,
    0,
    0,
    0,
    0,
    0,
    '',
    0,
    false,
    // event instance
    '',
    null,
    null,
    0,
    0,
    0,
    0,
    function(){},
    false
  ];

  var HAS_SVG_INSTANCE = (typeof SVGElementInstance !== 'undefined');

  var eventFactory = scope.eventFactory;

  // set of recognizers to run for the currently handled event
  var currentGestures;

  /**
   * This module is for normalizing events. Mouse and Touch events will be
   * collected here, and fire PointerEvents that have the same semantics, no
   * matter the source.
   * Events fired:
   *   - pointerdown: a pointing is added
   *   - pointerup: a pointer is removed
   *   - pointermove: a pointer is moved
   *   - pointerover: a pointer crosses into an element
   *   - pointerout: a pointer leaves an element
   *   - pointercancel: a pointer will no longer generate events
   */
  var dispatcher = {
    IS_IOS: false,
    pointermap: new scope.PointerMap(),
    requiredGestures: new scope.PointerMap(),
    eventMap: Object.create(null),
    // Scope objects for native events.
    // This exists for ease of testing.
    eventSources: Object.create(null),
    eventSourceList: [],
    gestures: [],
    // map gesture event -> {listeners: int, index: gestures[int]}
    dependencyMap: {
      // make sure down and up are in the map to trigger "register"
      down: {listeners: 0, index: -1},
      up: {listeners: 0, index: -1}
    },
    gestureQueue: [],
    /**
     * Add a new event source that will generate pointer events.
     *
     * `inSource` must contain an array of event names named `events`, and
     * functions with the names specified in the `events` array.
     * @param {string} name A name for the event source
     * @param {Object} source A new source of platform events.
     */
    registerSource: function(name, source) {
      var s = source;
      var newEvents = s.events;
      if (newEvents) {
        newEvents.forEach(function(e) {
          if (s[e]) {
            this.eventMap[e] = s[e].bind(s);
          }
        }, this);
        this.eventSources[name] = s;
        this.eventSourceList.push(s);
      }
    },
    registerGesture: function(name, source) {
      var obj = Object.create(null);
      obj.listeners = 0;
      obj.index = this.gestures.length;
      for (var i = 0, g; i < source.exposes.length; i++) {
        g = source.exposes[i].toLowerCase();
        this.dependencyMap[g] = obj;
      }
      this.gestures.push(source);
    },
    register: function(element, initial) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.register.call(es, element, initial);
      }
    },
    unregister: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.unregister.call(es, element);
      }
    },
    // EVENTS
    down: function(inEvent) {
      this.requiredGestures.set(inEvent.pointerId, currentGestures);
      this.fireEvent('down', inEvent);
    },
    move: function(inEvent) {
      // pipe move events into gesture queue directly
      inEvent.type = 'move';
      this.fillGestureQueue(inEvent);
    },
    up: function(inEvent) {
      this.fireEvent('up', inEvent);
      this.requiredGestures.delete(inEvent.pointerId);
    },
    cancel: function(inEvent) {
      inEvent.tapPrevented = true;
      this.fireEvent('up', inEvent);
      this.requiredGestures.delete(inEvent.pointerId);
    },
    addGestureDependency: function(node, currentGestures) {
      var gesturesWanted = node._pgEvents;
      if (gesturesWanted && currentGestures) {
        var gk = Object.keys(gesturesWanted);
        for (var i = 0, r, ri, g; i < gk.length; i++) {
          // gesture
          g = gk[i];
          if (gesturesWanted[g] > 0) {
            // lookup gesture recognizer
            r = this.dependencyMap[g];
            // recognizer index
            ri = r ? r.index : -1;
            currentGestures[ri] = true;
          }
        }
      }
    },
    // LISTENER LOGIC
    eventHandler: function(inEvent) {
      // This is used to prevent multiple dispatch of events from
      // platform events. This can happen when two elements in different scopes
      // are set up to create pointer events, which is relevant to Shadow DOM.

      var type = inEvent.type;

      // only generate the list of desired events on "down"
      if (type === 'touchstart' || type === 'mousedown' || type === 'pointerdown' || type === 'MSPointerDown') {
        if (!inEvent._handledByPG) {
          currentGestures = {};
        }

        // in IOS mode, there is only a listener on the document, so this is not re-entrant
        if (this.IS_IOS) {
          var ev = inEvent;
          if (type === 'touchstart') {
            var ct = inEvent.changedTouches[0];
            // set up a fake event to give to the path builder
            ev = {target: inEvent.target, clientX: ct.clientX, clientY: ct.clientY, path: inEvent.path};
          }
          // use event path if available, otherwise build a path from target finding
          var nodes = inEvent.path || scope.targetFinding.path(ev);
          for (var i = 0, n; i < nodes.length; i++) {
            n = nodes[i];
            this.addGestureDependency(n, currentGestures);
          }
        } else {
          this.addGestureDependency(inEvent.currentTarget, currentGestures);
        }
      }

      if (inEvent._handledByPG) {
        return;
      }
      var fn = this.eventMap && this.eventMap[type];
      if (fn) {
        fn(inEvent);
      }
      inEvent._handledByPG = true;
    },
    // set up event listeners
    listen: function(target, events) {
      for (var i = 0, l = events.length, e; (i < l) && (e = events[i]); i++) {
        this.addEvent(target, e);
      }
    },
    // remove event listeners
    unlisten: function(target, events) {
      for (var i = 0, l = events.length, e; (i < l) && (e = events[i]); i++) {
        this.removeEvent(target, e);
      }
    },
    addEvent: function(target, eventName) {
      target.addEventListener(eventName, this.boundHandler);
    },
    removeEvent: function(target, eventName) {
      target.removeEventListener(eventName, this.boundHandler);
    },
    // EVENT CREATION AND TRACKING
    /**
     * Creates a new Event of type `inType`, based on the information in
     * `inEvent`.
     *
     * @param {string} inType A string representing the type of event to create
     * @param {Event} inEvent A platform event with a target
     * @return {Event} A PointerEvent of type `inType`
     */
    makeEvent: function(inType, inEvent) {
      var e = eventFactory.makePointerEvent(inType, inEvent);
      e.preventDefault = inEvent.preventDefault;
      e.tapPrevented = inEvent.tapPrevented;
      e._target = e._target || inEvent.target;
      return e;
    },
    // make and dispatch an event in one call
    fireEvent: function(inType, inEvent) {
      var e = this.makeEvent(inType, inEvent);
      return this.dispatchEvent(e);
    },
    /**
     * Returns a snapshot of inEvent, with writable properties.
     *
     * @param {Event} inEvent An event that contains properties to copy.
     * @return {Object} An object containing shallow copies of `inEvent`'s
     *    properties.
     */
    cloneEvent: function(inEvent) {
      var eventCopy = Object.create(null), p;
      for (var i = 0; i < CLONE_PROPS.length; i++) {
        p = CLONE_PROPS[i];
        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];
        // Work around SVGInstanceElement shadow tree
        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
        // This is the behavior implemented by Firefox.
        if (p === 'target' || p === 'relatedTarget') {
          if (HAS_SVG_INSTANCE && eventCopy[p] instanceof SVGElementInstance) {
            eventCopy[p] = eventCopy[p].correspondingUseElement;
          }
        }
      }
      // keep the semantics of preventDefault
      eventCopy.preventDefault = function() {
        inEvent.preventDefault();
      };
      return eventCopy;
    },
    /**
     * Dispatches the event to its target.
     *
     * @param {Event} inEvent The event to be dispatched.
     * @return {Boolean} True if an event handler returns true, false otherwise.
     */
    dispatchEvent: function(inEvent) {
      var t = inEvent._target;
      if (t) {
        t.dispatchEvent(inEvent);
        // clone the event for the gesture system to process
        // clone after dispatch to pick up gesture prevention code
        var clone = this.cloneEvent(inEvent);
        clone.target = t;
        this.fillGestureQueue(clone);
      }
    },
    gestureTrigger: function() {
      // process the gesture queue
      for (var i = 0, e, rg; i < this.gestureQueue.length; i++) {
        e = this.gestureQueue[i];
        rg = e._requiredGestures;
        if (rg) {
          for (var j = 0, g, fn; j < this.gestures.length; j++) {
            // only run recognizer if an element in the source event's path is listening for those gestures
            if (rg[j]) {
              g = this.gestures[j];
              fn = g[e.type];
              if (fn) {
                fn.call(g, e);
              }
            }
          }
        }
      }
      this.gestureQueue.length = 0;
    },
    fillGestureQueue: function(ev) {
      // only trigger the gesture queue once
      if (!this.gestureQueue.length) {
        requestAnimationFrame(this.boundGestureTrigger);
      }
      ev._requiredGestures = this.requiredGestures.get(ev.pointerId);
      this.gestureQueue.push(ev);
    }
  };
  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);
  dispatcher.boundGestureTrigger = dispatcher.gestureTrigger.bind(dispatcher);
  scope.dispatcher = dispatcher;

  /**
   * Listen for `gesture` on `node` with the `handler` function
   *
   * If `handler` is the first listener for `gesture`, the underlying gesture recognizer is then enabled.
   *
   * @param {Element} node
   * @param {string} gesture
   * @return Boolean `gesture` is a valid gesture
   */
  scope.activateGesture = function(node, gesture) {
    var g = gesture.toLowerCase();
    var dep = dispatcher.dependencyMap[g];
    if (dep) {
      var recognizer = dispatcher.gestures[dep.index];
      if (!node._pgListeners) {
        dispatcher.register(node);
        node._pgListeners = 0;
      }
      // TODO(dfreedm): re-evaluate bookkeeping to avoid using attributes
      if (recognizer) {
        var touchAction = recognizer.defaultActions && recognizer.defaultActions[g];
        var actionNode;
        switch(node.nodeType) {
          case Node.ELEMENT_NODE:
            actionNode = node;
          break;
          case Node.DOCUMENT_FRAGMENT_NODE:
            actionNode = node.host;
          break;
          default:
            actionNode = null;
          break;
        }
        if (touchAction && actionNode && !actionNode.hasAttribute('touch-action')) {
          actionNode.setAttribute('touch-action', touchAction);
        }
      }
      if (!node._pgEvents) {
        node._pgEvents = {};
      }
      node._pgEvents[g] = (node._pgEvents[g] || 0) + 1;
      node._pgListeners++;
    }
    return Boolean(dep);
  };

  /**
   *
   * Listen for `gesture` from `node` with `handler` function.
   *
   * @param {Element} node
   * @param {string} gesture
   * @param {Function} handler
   * @param {Boolean} capture
   */
  scope.addEventListener = function(node, gesture, handler, capture) {
    if (handler) {
      scope.activateGesture(node, gesture);
      node.addEventListener(gesture, handler, capture);
    }
  };

  /**
   * Tears down the gesture configuration for `node`
   *
   * If `handler` is the last listener for `gesture`, the underlying gesture recognizer is disabled.
   *
   * @param {Element} node
   * @param {string} gesture
   * @return Boolean `gesture` is a valid gesture
   */
  scope.deactivateGesture = function(node, gesture) {
    var g = gesture.toLowerCase();
    var dep = dispatcher.dependencyMap[g];
    if (dep) {
      if (node._pgListeners > 0) {
        node._pgListeners--;
      }
      if (node._pgListeners === 0) {
        dispatcher.unregister(node);
      }
      if (node._pgEvents) {
        if (node._pgEvents[g] > 0) {
          node._pgEvents[g]--;
        } else {
          node._pgEvents[g] = 0;
        }
      }
    }
    return Boolean(dep);
  };

  /**
   * Stop listening for `gesture` from `node` with `handler` function.
   *
   * @param {Element} node
   * @param {string} gesture
   * @param {Function} handler
   * @param {Boolean} capture
   */
  scope.removeEventListener = function(node, gesture, handler, capture) {
    if (handler) {
      scope.deactivateGesture(node, gesture);
      node.removeEventListener(gesture, handler, capture);
    }
  };
})(window.PolymerGestures);

(function(scope) {
  var dispatcher = scope.dispatcher;
  var pointermap = dispatcher.pointermap;
  // radius around touchend that swallows mouse events
  var DEDUP_DIST = 25;

  var WHICH_TO_BUTTONS = [0, 1, 4, 2];

  var currentButtons = 0;

  var FIREFOX_LINUX = /Linux.*Firefox\//i;

  var HAS_BUTTONS = (function() {
    // firefox on linux returns spec-incorrect values for mouseup.buttons
    // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.buttons#See_also
    // https://codereview.chromium.org/727593003/#msg16
    if (FIREFOX_LINUX.test(navigator.userAgent)) {
      return false;
    }
    try {
      return new MouseEvent('test', {buttons: 1}).buttons === 1;
    } catch (e) {
      return false;
    }
  })();

  // handler block for native mouse events
  var mouseEvents = {
    POINTER_ID: 1,
    POINTER_TYPE: 'mouse',
    events: [
      'mousedown',
      'mousemove',
      'mouseup'
    ],
    exposes: [
      'down',
      'up',
      'move'
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      if (target.nodeType === Node.DOCUMENT_NODE) {
        return;
      }
      dispatcher.unlisten(target, this.events);
    },
    lastTouches: [],
    // collide with the global mouse listener
    isEventSimulatedFromTouch: function(inEvent) {
      var lts = this.lastTouches;
      var x = inEvent.clientX, y = inEvent.clientY;
      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
        // simulated mouse events will be swallowed near a primary touchend
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
          return true;
        }
      }
    },
    prepareEvent: function(inEvent) {
      var e = dispatcher.cloneEvent(inEvent);
      e.pointerId = this.POINTER_ID;
      e.isPrimary = true;
      e.pointerType = this.POINTER_TYPE;
      e._source = 'mouse';
      if (!HAS_BUTTONS) {
        var type = inEvent.type;
        var bit = WHICH_TO_BUTTONS[inEvent.which] || 0;
        if (type === 'mousedown') {
          currentButtons |= bit;
        } else if (type === 'mouseup') {
          currentButtons &= ~bit;
        }
        e.buttons = currentButtons;
      }
      return e;
    },
    mousedown: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.has(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        e.target = scope.findTarget(inEvent);
        pointermap.set(this.POINTER_ID, e.target);
        dispatcher.down(e);
      }
    },
    mousemove: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var target = pointermap.get(this.POINTER_ID);
        if (target) {
          var e = this.prepareEvent(inEvent);
          e.target = target;
          // handle case where we missed a mouseup
          if ((HAS_BUTTONS ? e.buttons : e.which) === 0) {
            if (!HAS_BUTTONS) {
              currentButtons = e.buttons = 0;
            }
            dispatcher.cancel(e);
            this.cleanupMouse(e.buttons);
          } else {
            dispatcher.move(e);
          }
        }
      }
    },
    mouseup: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        e.relatedTarget = scope.findTarget(inEvent);
        e.target = pointermap.get(this.POINTER_ID);
        dispatcher.up(e);
        this.cleanupMouse(e.buttons);
      }
    },
    cleanupMouse: function(buttons) {
      if (buttons === 0) {
        pointermap.delete(this.POINTER_ID);
      }
    }
  };

  scope.mouseEvents = mouseEvents;
})(window.PolymerGestures);

(function(scope) {
  var dispatcher = scope.dispatcher;
  var allShadows = scope.targetFinding.allShadows.bind(scope.targetFinding);
  var pointermap = dispatcher.pointermap;
  var touchMap = Array.prototype.map.call.bind(Array.prototype.map);
  // This should be long enough to ignore compat mouse events made by touch
  var DEDUP_TIMEOUT = 2500;
  var DEDUP_DIST = 25;
  var CLICK_COUNT_TIMEOUT = 200;
  var HYSTERESIS = 20;
  var ATTRIB = 'touch-action';
  // TODO(dfreedm): disable until http://crbug.com/399765 is resolved
  // var HAS_TOUCH_ACTION = ATTRIB in document.head.style;
  var HAS_TOUCH_ACTION = false;

  // handler block for native touch events
  var touchEvents = {
    IS_IOS: false,
    events: [
      'touchstart',
      'touchmove',
      'touchend',
      'touchcancel'
    ],
    exposes: [
      'down',
      'up',
      'move'
    ],
    register: function(target, initial) {
      if (this.IS_IOS ? initial : !initial) {
        dispatcher.listen(target, this.events);
      }
    },
    unregister: function(target) {
      if (!this.IS_IOS) {
        dispatcher.unlisten(target, this.events);
      }
    },
    scrollTypes: {
      EMITTER: 'none',
      XSCROLLER: 'pan-x',
      YSCROLLER: 'pan-y',
    },
    touchActionToScrollType: function(touchAction) {
      var t = touchAction;
      var st = this.scrollTypes;
      if (t === st.EMITTER) {
        return 'none';
      } else if (t === st.XSCROLLER) {
        return 'X';
      } else if (t === st.YSCROLLER) {
        return 'Y';
      } else {
        return 'XY';
      }
    },
    POINTER_TYPE: 'touch',
    firstTouch: null,
    isPrimaryTouch: function(inTouch) {
      return this.firstTouch === inTouch.identifier;
    },
    setPrimaryTouch: function(inTouch) {
      // set primary touch if there no pointers, or the only pointer is the mouse
      if (pointermap.pointers() === 0 || (pointermap.pointers() === 1 && pointermap.has(1))) {
        this.firstTouch = inTouch.identifier;
        this.firstXY = {X: inTouch.clientX, Y: inTouch.clientY};
        this.firstTarget = inTouch.target;
        this.scrolling = null;
        this.cancelResetClickCount();
      }
    },
    removePrimaryPointer: function(inPointer) {
      if (inPointer.isPrimary) {
        this.firstTouch = null;
        this.firstXY = null;
        this.resetClickCount();
      }
    },
    clickCount: 0,
    resetId: null,
    resetClickCount: function() {
      var fn = function() {
        this.clickCount = 0;
        this.resetId = null;
      }.bind(this);
      this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
    },
    cancelResetClickCount: function() {
      if (this.resetId) {
        clearTimeout(this.resetId);
      }
    },
    typeToButtons: function(type) {
      var ret = 0;
      if (type === 'touchstart' || type === 'touchmove') {
        ret = 1;
      }
      return ret;
    },
    findTarget: function(touch, id) {
      if (this.currentTouchEvent.type === 'touchstart') {
        if (this.isPrimaryTouch(touch)) {
          var fastPath = {
            clientX: touch.clientX,
            clientY: touch.clientY,
            path: this.currentTouchEvent.path,
            target: this.currentTouchEvent.target
          };
          return scope.findTarget(fastPath);
        } else {
          return scope.findTarget(touch);
        }
      }
      // reuse target we found in touchstart
      return pointermap.get(id);
    },
    touchToPointer: function(inTouch) {
      var cte = this.currentTouchEvent;
      var e = dispatcher.cloneEvent(inTouch);
      // Spec specifies that pointerId 1 is reserved for Mouse.
      // Touch identifiers can start at 0.
      // Add 2 to the touch identifier for compatibility.
      var id = e.pointerId = inTouch.identifier + 2;
      e.target = this.findTarget(inTouch, id);
      e.bubbles = true;
      e.cancelable = true;
      e.detail = this.clickCount;
      e.buttons = this.typeToButtons(cte.type);
      e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
      e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
      e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
      e.isPrimary = this.isPrimaryTouch(inTouch);
      e.pointerType = this.POINTER_TYPE;
      e._source = 'touch';
      // forward touch preventDefaults
      var self = this;
      e.preventDefault = function() {
        self.scrolling = false;
        self.firstXY = null;
        cte.preventDefault();
      };
      return e;
    },
    processTouches: function(inEvent, inFunction) {
      var tl = inEvent.changedTouches;
      this.currentTouchEvent = inEvent;
      for (var i = 0, t, p; i < tl.length; i++) {
        t = tl[i];
        p = this.touchToPointer(t);
        if (inEvent.type === 'touchstart') {
          pointermap.set(p.pointerId, p.target);
        }
        if (pointermap.has(p.pointerId)) {
          inFunction.call(this, p);
        }
        if (inEvent.type === 'touchend' || inEvent._cancel) {
          this.cleanUpPointer(p);
        }
      }
    },
    // For single axis scrollers, determines whether the element should emit
    // pointer events or behave as a scroller
    shouldScroll: function(inEvent) {
      if (this.firstXY) {
        var ret;
        var touchAction = scope.targetFinding.findTouchAction(inEvent);
        var scrollAxis = this.touchActionToScrollType(touchAction);
        if (scrollAxis === 'none') {
          // this element is a touch-action: none, should never scroll
          ret = false;
        } else if (scrollAxis === 'XY') {
          // this element should always scroll
          ret = true;
        } else {
          var t = inEvent.changedTouches[0];
          // check the intended scroll axis, and other axis
          var a = scrollAxis;
          var oa = scrollAxis === 'Y' ? 'X' : 'Y';
          var da = Math.abs(t['client' + a] - this.firstXY[a]);
          var doa = Math.abs(t['client' + oa] - this.firstXY[oa]);
          // if delta in the scroll axis > delta other axis, scroll instead of
          // making events
          ret = da >= doa;
        }
        return ret;
      }
    },
    findTouch: function(inTL, inId) {
      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
        if (t.identifier === inId) {
          return true;
        }
      }
    },
    // In some instances, a touchstart can happen without a touchend. This
    // leaves the pointermap in a broken state.
    // Therefore, on every touchstart, we remove the touches that did not fire a
    // touchend event.
    // To keep state globally consistent, we fire a
    // pointercancel for this "abandoned" touch
    vacuumTouches: function(inEvent) {
      var tl = inEvent.touches;
      // pointermap.pointers() should be < tl.length here, as the touchstart has not
      // been processed yet.
      if (pointermap.pointers() >= tl.length) {
        var d = [];
        pointermap.forEach(function(value, key) {
          // Never remove pointerId == 1, which is mouse.
          // Touch identifiers are 2 smaller than their pointerId, which is the
          // index in pointermap.
          if (key !== 1 && !this.findTouch(tl, key - 2)) {
            var p = value;
            d.push(p);
          }
        }, this);
        d.forEach(function(p) {
          this.cancel(p);
          pointermap.delete(p.pointerId);
        }, this);
      }
    },
    touchstart: function(inEvent) {
      this.vacuumTouches(inEvent);
      this.setPrimaryTouch(inEvent.changedTouches[0]);
      this.dedupSynthMouse(inEvent);
      if (!this.scrolling) {
        this.clickCount++;
        this.processTouches(inEvent, this.down);
      }
    },
    down: function(inPointer) {
      dispatcher.down(inPointer);
    },
    touchmove: function(inEvent) {
      if (HAS_TOUCH_ACTION) {
        // touchevent.cancelable == false is sent when the page is scrolling under native Touch Action in Chrome 36
        // https://groups.google.com/a/chromium.org/d/msg/input-dev/wHnyukcYBcA/b9kmtwM1jJQJ
        if (inEvent.cancelable) {
          this.processTouches(inEvent, this.move);
        }
      } else {
        if (!this.scrolling) {
          if (this.scrolling === null && this.shouldScroll(inEvent)) {
            this.scrolling = true;
          } else {
            this.scrolling = false;
            inEvent.preventDefault();
            this.processTouches(inEvent, this.move);
          }
        } else if (this.firstXY) {
          var t = inEvent.changedTouches[0];
          var dx = t.clientX - this.firstXY.X;
          var dy = t.clientY - this.firstXY.Y;
          var dd = Math.sqrt(dx * dx + dy * dy);
          if (dd >= HYSTERESIS) {
            this.touchcancel(inEvent);
            this.scrolling = true;
            this.firstXY = null;
          }
        }
      }
    },
    move: function(inPointer) {
      dispatcher.move(inPointer);
    },
    touchend: function(inEvent) {
      this.dedupSynthMouse(inEvent);
      this.processTouches(inEvent, this.up);
    },
    up: function(inPointer) {
      inPointer.relatedTarget = scope.findTarget(inPointer);
      dispatcher.up(inPointer);
    },
    cancel: function(inPointer) {
      dispatcher.cancel(inPointer);
    },
    touchcancel: function(inEvent) {
      inEvent._cancel = true;
      this.processTouches(inEvent, this.cancel);
    },
    cleanUpPointer: function(inPointer) {
      pointermap['delete'](inPointer.pointerId);
      this.removePrimaryPointer(inPointer);
    },
    // prevent synth mouse events from creating pointer events
    dedupSynthMouse: function(inEvent) {
      var lts = scope.mouseEvents.lastTouches;
      var t = inEvent.changedTouches[0];
      // only the primary finger will synth mouse events
      if (this.isPrimaryTouch(t)) {
        // remember x/y of last touch
        var lt = {x: t.clientX, y: t.clientY};
        lts.push(lt);
        var fn = (function(lts, lt){
          var i = lts.indexOf(lt);
          if (i > -1) {
            lts.splice(i, 1);
          }
        }).bind(null, lts, lt);
        setTimeout(fn, DEDUP_TIMEOUT);
      }
    }
  };

  // prevent "ghost clicks" that come from elements that were removed in a touch handler
  var STOP_PROP_FN = Event.prototype.stopImmediatePropagation || Event.prototype.stopPropagation;
  document.addEventListener('click', function(ev) {
    var x = ev.clientX, y = ev.clientY;
    // check if a click is within DEDUP_DIST px radius of the touchstart
    var closeTo = function(touch) {
      var dx = Math.abs(x - touch.x), dy = Math.abs(y - touch.y);
      return (dx <= DEDUP_DIST && dy <= DEDUP_DIST);
    };
    // if click coordinates are close to touch coordinates, assume the click came from a touch
    var wasTouched = scope.mouseEvents.lastTouches.some(closeTo);
    // if the click came from touch, and the touchstart target is not in the path of the click event,
    // then the touchstart target was probably removed, and the click should be "busted"
    var path = scope.targetFinding.path(ev);
    if (wasTouched) {
      for (var i = 0; i < path.length; i++) {
        if (path[i] === touchEvents.firstTarget) {
          return;
        }
      }
      ev.preventDefault();
      STOP_PROP_FN.call(ev);
    }
  }, true);

  scope.touchEvents = touchEvents;
})(window.PolymerGestures);

(function(scope) {
  var dispatcher = scope.dispatcher;
  var pointermap = dispatcher.pointermap;
  var HAS_BITMAP_TYPE = window.MSPointerEvent && typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === 'number';
  var msEvents = {
    events: [
      'MSPointerDown',
      'MSPointerMove',
      'MSPointerUp',
      'MSPointerCancel',
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      if (target.nodeType === Node.DOCUMENT_NODE) {
        return;
      }
      dispatcher.unlisten(target, this.events);
    },
    POINTER_TYPES: [
      '',
      'unavailable',
      'touch',
      'pen',
      'mouse'
    ],
    prepareEvent: function(inEvent) {
      var e = inEvent;
      e = dispatcher.cloneEvent(inEvent);
      if (HAS_BITMAP_TYPE) {
        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
      }
      e._source = 'ms';
      return e;
    },
    cleanup: function(id) {
      pointermap['delete'](id);
    },
    MSPointerDown: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      e.target = scope.findTarget(inEvent);
      pointermap.set(inEvent.pointerId, e.target);
      dispatcher.down(e);
    },
    MSPointerMove: function(inEvent) {
      var target = pointermap.get(inEvent.pointerId);
      if (target) {
        var e = this.prepareEvent(inEvent);
        e.target = target;
        dispatcher.move(e);
      }
    },
    MSPointerUp: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      e.relatedTarget = scope.findTarget(inEvent);
      e.target = pointermap.get(e.pointerId);
      dispatcher.up(e);
      this.cleanup(inEvent.pointerId);
    },
    MSPointerCancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      e.relatedTarget = scope.findTarget(inEvent);
      e.target = pointermap.get(e.pointerId);
      dispatcher.cancel(e);
      this.cleanup(inEvent.pointerId);
    }
  };

  scope.msEvents = msEvents;
})(window.PolymerGestures);

(function(scope) {
  var dispatcher = scope.dispatcher;
  var pointermap = dispatcher.pointermap;
  var pointerEvents = {
    events: [
      'pointerdown',
      'pointermove',
      'pointerup',
      'pointercancel'
    ],
    prepareEvent: function(inEvent) {
      var e = dispatcher.cloneEvent(inEvent);
      e._source = 'pointer';
      return e;
    },
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      if (target.nodeType === Node.DOCUMENT_NODE) {
        return;
      }
      dispatcher.unlisten(target, this.events);
    },
    cleanup: function(id) {
      pointermap['delete'](id);
    },
    pointerdown: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      e.target = scope.findTarget(inEvent);
      pointermap.set(e.pointerId, e.target);
      dispatcher.down(e);
    },
    pointermove: function(inEvent) {
      var target = pointermap.get(inEvent.pointerId);
      if (target) {
        var e = this.prepareEvent(inEvent);
        e.target = target;
        dispatcher.move(e);
      }
    },
    pointerup: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      e.relatedTarget = scope.findTarget(inEvent);
      e.target = pointermap.get(e.pointerId);
      dispatcher.up(e);
      this.cleanup(inEvent.pointerId);
    },
    pointercancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      e.relatedTarget = scope.findTarget(inEvent);
      e.target = pointermap.get(e.pointerId);
      dispatcher.cancel(e);
      this.cleanup(inEvent.pointerId);
    }
  };

  scope.pointerEvents = pointerEvents;
})(window.PolymerGestures);

/**
 * This module contains the handlers for native platform events.
 * From here, the dispatcher is called to create unified pointer events.
 * Included are touch events (v1), mouse events, and MSPointerEvents.
 */
(function(scope) {

  var dispatcher = scope.dispatcher;
  var nav = window.navigator;

  if (window.PointerEvent) {
    dispatcher.registerSource('pointer', scope.pointerEvents);
  } else if (nav.msPointerEnabled) {
    dispatcher.registerSource('ms', scope.msEvents);
  } else {
    dispatcher.registerSource('mouse', scope.mouseEvents);
    if (window.ontouchstart !== undefined) {
      dispatcher.registerSource('touch', scope.touchEvents);
    }
  }

  // Work around iOS bugs https://bugs.webkit.org/show_bug.cgi?id=135628 and https://bugs.webkit.org/show_bug.cgi?id=136506
  var ua = navigator.userAgent;
  var IS_IOS = ua.match(/iPad|iPhone|iPod/) && 'ontouchstart' in window;

  dispatcher.IS_IOS = IS_IOS;
  scope.touchEvents.IS_IOS = IS_IOS;

  dispatcher.register(document, true);
})(window.PolymerGestures);

/**
 * This event denotes the beginning of a series of tracking events.
 *
 * @module PointerGestures
 * @submodule Events
 * @class trackstart
 */
/**
 * Pixels moved in the x direction since trackstart.
 * @type Number
 * @property dx
 */
/**
 * Pixes moved in the y direction since trackstart.
 * @type Number
 * @property dy
 */
/**
 * Pixels moved in the x direction since the last track.
 * @type Number
 * @property ddx
 */
/**
 * Pixles moved in the y direction since the last track.
 * @type Number
 * @property ddy
 */
/**
 * The clientX position of the track gesture.
 * @type Number
 * @property clientX
 */
/**
 * The clientY position of the track gesture.
 * @type Number
 * @property clientY
 */
/**
 * The pageX position of the track gesture.
 * @type Number
 * @property pageX
 */
/**
 * The pageY position of the track gesture.
 * @type Number
 * @property pageY
 */
/**
 * The screenX position of the track gesture.
 * @type Number
 * @property screenX
 */
/**
 * The screenY position of the track gesture.
 * @type Number
 * @property screenY
 */
/**
 * The last x axis direction of the pointer.
 * @type Number
 * @property xDirection
 */
/**
 * The last y axis direction of the pointer.
 * @type Number
 * @property yDirection
 */
/**
 * A shared object between all tracking events.
 * @type Object
 * @property trackInfo
 */
/**
 * The element currently under the pointer.
 * @type Element
 * @property relatedTarget
 */
/**
 * The type of pointer that make the track gesture.
 * @type String
 * @property pointerType
 */
/**
 *
 * This event fires for all pointer movement being tracked.
 *
 * @class track
 * @extends trackstart
 */
/**
 * This event fires when the pointer is no longer being tracked.
 *
 * @class trackend
 * @extends trackstart
 */

 (function(scope) {
   var dispatcher = scope.dispatcher;
   var eventFactory = scope.eventFactory;
   var pointermap = new scope.PointerMap();
   var track = {
     events: [
       'down',
       'move',
       'up',
     ],
     exposes: [
      'trackstart',
      'track',
      'trackx',
      'tracky',
      'trackend'
     ],
     defaultActions: {
       'track': 'none',
       'trackx': 'pan-y',
       'tracky': 'pan-x'
     },
     WIGGLE_THRESHOLD: 4,
     clampDir: function(inDelta) {
       return inDelta > 0 ? 1 : -1;
     },
     calcPositionDelta: function(inA, inB) {
       var x = 0, y = 0;
       if (inA && inB) {
         x = inB.pageX - inA.pageX;
         y = inB.pageY - inA.pageY;
       }
       return {x: x, y: y};
     },
     fireTrack: function(inType, inEvent, inTrackingData) {
       var t = inTrackingData;
       var d = this.calcPositionDelta(t.downEvent, inEvent);
       var dd = this.calcPositionDelta(t.lastMoveEvent, inEvent);
       if (dd.x) {
         t.xDirection = this.clampDir(dd.x);
       } else if (inType === 'trackx') {
         return;
       }
       if (dd.y) {
         t.yDirection = this.clampDir(dd.y);
       } else if (inType === 'tracky') {
         return;
       }
       var gestureProto = {
         bubbles: true,
         cancelable: true,
         trackInfo: t.trackInfo,
         relatedTarget: inEvent.relatedTarget,
         pointerType: inEvent.pointerType,
         pointerId: inEvent.pointerId,
         _source: 'track'
       };
       if (inType !== 'tracky') {
         gestureProto.x = inEvent.x;
         gestureProto.dx = d.x;
         gestureProto.ddx = dd.x;
         gestureProto.clientX = inEvent.clientX;
         gestureProto.pageX = inEvent.pageX;
         gestureProto.screenX = inEvent.screenX;
         gestureProto.xDirection = t.xDirection;
       }
       if (inType !== 'trackx') {
         gestureProto.dy = d.y;
         gestureProto.ddy = dd.y;
         gestureProto.y = inEvent.y;
         gestureProto.clientY = inEvent.clientY;
         gestureProto.pageY = inEvent.pageY;
         gestureProto.screenY = inEvent.screenY;
         gestureProto.yDirection = t.yDirection;
       }
       var e = eventFactory.makeGestureEvent(inType, gestureProto);
       t.downTarget.dispatchEvent(e);
     },
     down: function(inEvent) {
       if (inEvent.isPrimary && (inEvent.pointerType === 'mouse' ? inEvent.buttons === 1 : true)) {
         var p = {
           downEvent: inEvent,
           downTarget: inEvent.target,
           trackInfo: {},
           lastMoveEvent: null,
           xDirection: 0,
           yDirection: 0,
           tracking: false
         };
         pointermap.set(inEvent.pointerId, p);
       }
     },
     move: function(inEvent) {
       var p = pointermap.get(inEvent.pointerId);
       if (p) {
         if (!p.tracking) {
           var d = this.calcPositionDelta(p.downEvent, inEvent);
           var move = d.x * d.x + d.y * d.y;
           // start tracking only if finger moves more than WIGGLE_THRESHOLD
           if (move > this.WIGGLE_THRESHOLD) {
             p.tracking = true;
             p.lastMoveEvent = p.downEvent;
             this.fireTrack('trackstart', inEvent, p);
           }
         }
         if (p.tracking) {
           this.fireTrack('track', inEvent, p);
           this.fireTrack('trackx', inEvent, p);
           this.fireTrack('tracky', inEvent, p);
         }
         p.lastMoveEvent = inEvent;
       }
     },
     up: function(inEvent) {
       var p = pointermap.get(inEvent.pointerId);
       if (p) {
         if (p.tracking) {
           this.fireTrack('trackend', inEvent, p);
         }
         pointermap.delete(inEvent.pointerId);
       }
     }
   };
   dispatcher.registerGesture('track', track);
 })(window.PolymerGestures);

/**
 * This event is fired when a pointer is held down for 200ms.
 *
 * @module PointerGestures
 * @submodule Events
 * @class hold
 */
/**
 * Type of pointer that made the holding event.
 * @type String
 * @property pointerType
 */
/**
 * Screen X axis position of the held pointer
 * @type Number
 * @property clientX
 */
/**
 * Screen Y axis position of the held pointer
 * @type Number
 * @property clientY
 */
/**
 * Type of pointer that made the holding event.
 * @type String
 * @property pointerType
 */
/**
 * This event is fired every 200ms while a pointer is held down.
 *
 * @class holdpulse
 * @extends hold
 */
/**
 * Milliseconds pointer has been held down.
 * @type Number
 * @property holdTime
 */
/**
 * This event is fired when a held pointer is released or moved.
 *
 * @class release
 */

(function(scope) {
  var dispatcher = scope.dispatcher;
  var eventFactory = scope.eventFactory;
  var hold = {
    // wait at least HOLD_DELAY ms between hold and pulse events
    HOLD_DELAY: 200,
    // pointer can move WIGGLE_THRESHOLD pixels before not counting as a hold
    WIGGLE_THRESHOLD: 16,
    events: [
      'down',
      'move',
      'up',
    ],
    exposes: [
      'hold',
      'holdpulse',
      'release'
    ],
    heldPointer: null,
    holdJob: null,
    pulse: function() {
      var hold = Date.now() - this.heldPointer.timeStamp;
      var type = this.held ? 'holdpulse' : 'hold';
      this.fireHold(type, hold);
      this.held = true;
    },
    cancel: function() {
      clearInterval(this.holdJob);
      if (this.held) {
        this.fireHold('release');
      }
      this.held = false;
      this.heldPointer = null;
      this.target = null;
      this.holdJob = null;
    },
    down: function(inEvent) {
      if (inEvent.isPrimary && !this.heldPointer) {
        this.heldPointer = inEvent;
        this.target = inEvent.target;
        this.holdJob = setInterval(this.pulse.bind(this), this.HOLD_DELAY);
      }
    },
    up: function(inEvent) {
      if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {
        this.cancel();
      }
    },
    move: function(inEvent) {
      if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {
        var x = inEvent.clientX - this.heldPointer.clientX;
        var y = inEvent.clientY - this.heldPointer.clientY;
        if ((x * x + y * y) > this.WIGGLE_THRESHOLD) {
          this.cancel();
        }
      }
    },
    fireHold: function(inType, inHoldTime) {
      var p = {
        bubbles: true,
        cancelable: true,
        pointerType: this.heldPointer.pointerType,
        pointerId: this.heldPointer.pointerId,
        x: this.heldPointer.clientX,
        y: this.heldPointer.clientY,
        _source: 'hold'
      };
      if (inHoldTime) {
        p.holdTime = inHoldTime;
      }
      var e = eventFactory.makeGestureEvent(inType, p);
      this.target.dispatchEvent(e);
    }
  };
  dispatcher.registerGesture('hold', hold);
})(window.PolymerGestures);

/**
 * This event is fired when a pointer quickly goes down and up, and is used to
 * denote activation.
 *
 * Any gesture event can prevent the tap event from being created by calling
 * `event.preventTap`.
 *
 * Any pointer event can prevent the tap by setting the `tapPrevented` property
 * on itself.
 *
 * @module PointerGestures
 * @submodule Events
 * @class tap
 */
/**
 * X axis position of the tap.
 * @property x
 * @type Number
 */
/**
 * Y axis position of the tap.
 * @property y
 * @type Number
 */
/**
 * Type of the pointer that made the tap.
 * @property pointerType
 * @type String
 */
(function(scope) {
  var dispatcher = scope.dispatcher;
  var eventFactory = scope.eventFactory;
  var pointermap = new scope.PointerMap();
  var tap = {
    events: [
      'down',
      'up'
    ],
    exposes: [
      'tap'
    ],
    down: function(inEvent) {
      if (inEvent.isPrimary && !inEvent.tapPrevented) {
        pointermap.set(inEvent.pointerId, {
          target: inEvent.target,
          buttons: inEvent.buttons,
          x: inEvent.clientX,
          y: inEvent.clientY
        });
      }
    },
    shouldTap: function(e, downState) {
      var tap = true;
      if (e.pointerType === 'mouse') {
        // only allow left click to tap for mouse
        tap = (e.buttons ^ 1) && (downState.buttons & 1);
      }
      return tap && !e.tapPrevented;
    },
    up: function(inEvent) {
      var start = pointermap.get(inEvent.pointerId);
      if (start && this.shouldTap(inEvent, start)) {
        // up.relatedTarget is target currently under finger
        var t = scope.targetFinding.LCA(start.target, inEvent.relatedTarget);
        if (t) {
          var e = eventFactory.makeGestureEvent('tap', {
            bubbles: true,
            cancelable: true,
            x: inEvent.clientX,
            y: inEvent.clientY,
            detail: inEvent.detail,
            pointerType: inEvent.pointerType,
            pointerId: inEvent.pointerId,
            altKey: inEvent.altKey,
            ctrlKey: inEvent.ctrlKey,
            metaKey: inEvent.metaKey,
            shiftKey: inEvent.shiftKey,
            _source: 'tap'
          });
          t.dispatchEvent(e);
        }
      }
      pointermap.delete(inEvent.pointerId);
    }
  };
  // patch eventFactory to remove id from tap's pointermap for preventTap calls
  eventFactory.preventTap = function(e) {
    return function() {
      e.tapPrevented = true;
      pointermap.delete(e.pointerId);
    };
  };
  dispatcher.registerGesture('tap', tap);
})(window.PolymerGestures);

/*
 * Basic strategy: find the farthest apart points, use as diameter of circle
 * react to size change and rotation of the chord
 */

/**
 * @module pointer-gestures
 * @submodule Events
 * @class pinch
 */
/**
 * Scale of the pinch zoom gesture
 * @property scale
 * @type Number
 */
/**
 * Center X position of pointers causing pinch
 * @property centerX
 * @type Number
 */
/**
 * Center Y position of pointers causing pinch
 * @property centerY
 * @type Number
 */

/**
 * @module pointer-gestures
 * @submodule Events
 * @class rotate
 */
/**
 * Angle (in degrees) of rotation. Measured from starting positions of pointers.
 * @property angle
 * @type Number
 */
/**
 * Center X position of pointers causing rotation
 * @property centerX
 * @type Number
 */
/**
 * Center Y position of pointers causing rotation
 * @property centerY
 * @type Number
 */
(function(scope) {
  var dispatcher = scope.dispatcher;
  var eventFactory = scope.eventFactory;
  var pointermap = new scope.PointerMap();
  var RAD_TO_DEG = 180 / Math.PI;
  var pinch = {
    events: [
      'down',
      'up',
      'move',
      'cancel'
    ],
    exposes: [
      'pinchstart',
      'pinch',
      'pinchend',
      'rotate'
    ],
    defaultActions: {
      'pinch': 'none',
      'rotate': 'none'
    },
    reference: {},
    down: function(inEvent) {
      pointermap.set(inEvent.pointerId, inEvent);
      if (pointermap.pointers() == 2) {
        var points = this.calcChord();
        var angle = this.calcAngle(points);
        this.reference = {
          angle: angle,
          diameter: points.diameter,
          target: scope.targetFinding.LCA(points.a.target, points.b.target)
        };

        this.firePinch('pinchstart', points.diameter, points);
      }
    },
    up: function(inEvent) {
      var p = pointermap.get(inEvent.pointerId);
      var num = pointermap.pointers();
      if (p) {
        if (num === 2) {
          // fire 'pinchend' before deleting pointer
          var points = this.calcChord();
          this.firePinch('pinchend', points.diameter, points);
        }
        pointermap.delete(inEvent.pointerId);
      }
    },
    move: function(inEvent) {
      if (pointermap.has(inEvent.pointerId)) {
        pointermap.set(inEvent.pointerId, inEvent);
        if (pointermap.pointers() > 1) {
          this.calcPinchRotate();
        }
      }
    },
    cancel: function(inEvent) {
        this.up(inEvent);
    },
    firePinch: function(type, diameter, points) {
      var zoom = diameter / this.reference.diameter;
      var e = eventFactory.makeGestureEvent(type, {
        bubbles: true,
        cancelable: true,
        scale: zoom,
        centerX: points.center.x,
        centerY: points.center.y,
        _source: 'pinch'
      });
      this.reference.target.dispatchEvent(e);
    },
    fireRotate: function(angle, points) {
      var diff = Math.round((angle - this.reference.angle) % 360);
      var e = eventFactory.makeGestureEvent('rotate', {
        bubbles: true,
        cancelable: true,
        angle: diff,
        centerX: points.center.x,
        centerY: points.center.y,
        _source: 'pinch'
      });
      this.reference.target.dispatchEvent(e);
    },
    calcPinchRotate: function() {
      var points = this.calcChord();
      var diameter = points.diameter;
      var angle = this.calcAngle(points);
      if (diameter != this.reference.diameter) {
        this.firePinch('pinch', diameter, points);
      }
      if (angle != this.reference.angle) {
        this.fireRotate(angle, points);
      }
    },
    calcChord: function() {
      var pointers = [];
      pointermap.forEach(function(p) {
        pointers.push(p);
      });
      var dist = 0;
      // start with at least two pointers
      var points = {a: pointers[0], b: pointers[1]};
      var x, y, d;
      for (var i = 0; i < pointers.length; i++) {
        var a = pointers[i];
        for (var j = i + 1; j < pointers.length; j++) {
          var b = pointers[j];
          x = Math.abs(a.clientX - b.clientX);
          y = Math.abs(a.clientY - b.clientY);
          d = x + y;
          if (d > dist) {
            dist = d;
            points = {a: a, b: b};
          }
        }
      }
      x = Math.abs(points.a.clientX + points.b.clientX) / 2;
      y = Math.abs(points.a.clientY + points.b.clientY) / 2;
      points.center = { x: x, y: y };
      points.diameter = dist;
      return points;
    },
    calcAngle: function(points) {
      var x = points.a.clientX - points.b.clientX;
      var y = points.a.clientY - points.b.clientY;
      return (360 + Math.atan2(y, x) * RAD_TO_DEG) % 360;
    }
  };
  dispatcher.registerGesture('pinch', pinch);
})(window.PolymerGestures);

(function (global) {
    'use strict';

    var Token,
        TokenName,
        Syntax,
        Messages,
        source,
        index,
        length,
        delegate,
        lookahead,
        state;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';

    Syntax = {
        ArrayExpression: 'ArrayExpression',
        BinaryExpression: 'BinaryExpression',
        CallExpression: 'CallExpression',
        ConditionalExpression: 'ConditionalExpression',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        Identifier: 'Identifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ThisExpression: 'ThisExpression',
        UnaryExpression: 'UnaryExpression'
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken:  'Unexpected token %0',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared'
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 32) ||  // space
            (ch === 9) ||      // tab
            (ch === 0xB) ||
            (ch === 0xC) ||
            (ch === 0xA0) ||
            (ch >= 0x1680 && '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122);          // a..z
    }

    function isIdentifierPart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch >= 48 && ch <= 57);           // 0..9
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        return (id === 'this')
    }

    // 7.4 Comments

    function skipWhitespace() {
        while (index < length && isWhiteSpace(source.charCodeAt(index))) {
           ++index;
        }
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        id = getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            range: [start, index]
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2;

        switch (code) {

        // Check for most common single-character punctuators.
        case 46:   // . dot
        case 40:   // ( open bracket
        case 41:   // ) close bracket
        case 59:   // ; semicolon
        case 44:   // , comma
        case 123:  // { open curly brace
        case 125:  // } close curly brace
        case 91:   // [
        case 93:   // ]
        case 58:   // :
        case 63:   // ?
            ++index;
            return {
                type: Token.Punctuator,
                value: String.fromCharCode(code),
                range: [start, index]
            };

        default:
            code2 = source.charCodeAt(index + 1);

            // '=' (char #61) marks an assignment or comparison operator.
            if (code2 === 61) {
                switch (code) {
                case 37:  // %
                case 38:  // &
                case 42:  // *:
                case 43:  // +
                case 45:  // -
                case 47:  // /
                case 60:  // <
                case 62:  // >
                case 124: // |
                    index += 2;
                    return {
                        type: Token.Punctuator,
                        value: String.fromCharCode(code) + String.fromCharCode(code2),
                        range: [start, index]
                    };

                case 33: // !
                case 61: // =
                    index += 2;

                    // !== and ===
                    if (source.charCodeAt(index) === 61) {
                        ++index;
                    }
                    return {
                        type: Token.Punctuator,
                        value: source.slice(start, index),
                        range: [start, index]
                    };
                default:
                    break;
                }
            }
            break;
        }

        // Peek more characters.

        ch2 = source[index + 1];

        // Other 2-character punctuators: && ||

        if (ch1 === ch2 && ('&|'.indexOf(ch1) >= 0)) {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch1 + ch2,
                range: [start, index]
            };
        }

        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                range: [start, index]
            };
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    // 7.8.3 Numeric Literals
    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            if (number === '0') {
                // decimal number starts with '0' such as '09' is illegal.
                if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            range: [start, index]
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;

                    default:
                        str += ch;
                        break;
                    }
                } else {
                    if (ch ===  '\r' && source[index] === '\n') {
                        ++index;
                    }
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            range: [start, index]
        };
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advance() {
        var ch;

        skipWhitespace();

        if (index >= length) {
            return {
                type: Token.EOF,
                range: [index, index]
            };
        }

        ch = source.charCodeAt(index);

        // Very common: ( and ) and ;
        if (ch === 40 || ch === 41 || ch === 58) {
            return scanPunctuator();
        }

        // String literal starts with single quote (#39) or double quote (#34).
        if (ch === 39 || ch === 34) {
            return scanStringLiteral();
        }

        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Dot (.) char #46 can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 46) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        return scanPunctuator();
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.range[1];

        lookahead = advance();

        index = token.range[1];

        return token;
    }

    function peek() {
        var pos;

        pos = index;
        lookahead = advance();
        index = pos;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, index) {
                    assert(index < args.length, 'Message reference must be in range');
                    return args[index];
                }
            );

        error = new Error(msg);
        error.index = index;
        error.description = msg;
        throw error;
    }

    // Throw an exception because of the token.

    function throwUnexpected(token) {
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    function consumeSemicolon() {
        // Catch the very common case first: immediately a semicolon (char #59).
        if (source.charCodeAt(index) === 59) {
            lex();
            return;
        }

        skipWhitespace();

        if (match(';')) {
            lex();
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpected(lookahead);
        }
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [];

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        expect(']');

        return delegate.createArrayExpression(elements);
    }

    // 11.1.5 Object Initialiser

    function parseObjectPropertyKey() {
        var token;

        skipWhitespace();
        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.
        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            return delegate.createLiteral(token);
        }

        return delegate.createIdentifier(token.value);
    }

    function parseObjectProperty() {
        var token, key;

        token = lookahead;
        skipWhitespace();

        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpected(token);
        }

        key = parseObjectPropertyKey();
        expect(':');
        return delegate.createProperty('init', key, parseExpression());
    }

    function parseObjectInitialiser() {
        var properties = [];

        expect('{');

        while (!match('}')) {
            properties.push(parseObjectProperty());

            if (!match('}')) {
                expect(',');
            }
        }

        expect('}');

        return delegate.createObjectExpression(properties);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr;

        if (match('(')) {
            return parseGroupExpression();
        }

        type = lookahead.type;

        if (type === Token.Identifier) {
            expr = delegate.createIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            expr = delegate.createLiteral(lex());
        } else if (type === Token.Keyword) {
            if (matchKeyword('this')) {
                lex();
                expr = delegate.createThisExpression();
            }
        } else if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = (token.value === 'true');
            expr = delegate.createLiteral(token);
        } else if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            expr = delegate.createLiteral(token);
        } else if (match('[')) {
            expr = parseArrayInitialiser();
        } else if (match('{')) {
            expr = parseObjectInitialiser();
        }

        if (expr) {
            return expr;
        }

        throwUnexpected(lex());
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseExpression());
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token;

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return delegate.createIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseLeftHandSideExpression() {
        var expr, args, property;

        expr = parsePrimaryExpression();

        while (true) {
            if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
            } else if (match('.')) {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
            } else if (match('(')) {
                args = parseArguments();
                expr = delegate.createCallExpression(expr, args);
            } else {
                break;
            }
        }

        return expr;
    }

    // 11.3 Postfix Expressions

    var parsePostfixExpression = parseLeftHandSideExpression;

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('+') || match('-') || match('!')) {
            token = lex();
            expr = parseUnaryExpression();
            expr = delegate.createUnaryExpression(token.value, expr);
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            throwError({}, Messages.UnexpectedToken);
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = 7;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var expr, token, prec, stack, right, operator, left, i;

        left = parseUnaryExpression();

        token = lookahead;
        prec = binaryPrecedence(token);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();

        right = parseUnaryExpression();

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                expr = delegate.createBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            expr = parseUnaryExpression();
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        while (i > 1) {
            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, consequent, alternate;

        expr = parseBinaryExpression();

        if (match('?')) {
            lex();
            consequent = parseConditionalExpression();
            expect(':');
            alternate = parseConditionalExpression();

            expr = delegate.createConditionalExpression(expr, consequent, alternate);
        }

        return expr;
    }

    // Simplification since we do not support AssignmentExpression.
    var parseExpression = parseConditionalExpression;

    // Polymer Syntax extensions

    // Filter ::
    //   Identifier
    //   Identifier "(" ")"
    //   Identifier "(" FilterArguments ")"

    function parseFilter() {
        var identifier, args;

        identifier = lex();

        if (identifier.type !== Token.Identifier) {
            throwUnexpected(identifier);
        }

        args = match('(') ? parseArguments() : [];

        return delegate.createFilter(identifier.value, args);
    }

    // Filters ::
    //   "|" Filter
    //   Filters "|" Filter

    function parseFilters() {
        while (match('|')) {
            lex();
            parseFilter();
        }
    }

    // TopLevel ::
    //   LabelledExpressions
    //   AsExpression
    //   InExpression
    //   FilterExpression

    // AsExpression ::
    //   FilterExpression as Identifier

    // InExpression ::
    //   Identifier, Identifier in FilterExpression
    //   Identifier in FilterExpression

    // FilterExpression ::
    //   Expression
    //   Expression Filters

    function parseTopLevel() {
        skipWhitespace();
        peek();

        var expr = parseExpression();
        if (expr) {
            if (lookahead.value === ',' || lookahead.value == 'in' &&
                       expr.type === Syntax.Identifier) {
                parseInExpression(expr);
            } else {
                parseFilters();
                if (lookahead.value === 'as') {
                    parseAsExpression(expr);
                } else {
                    delegate.createTopLevel(expr);
                }
            }
        }

        if (lookahead.type !== Token.EOF) {
            throwUnexpected(lookahead);
        }
    }

    function parseAsExpression(expr) {
        lex();  // as
        var identifier = lex().value;
        delegate.createAsExpression(expr, identifier);
    }

    function parseInExpression(identifier) {
        var indexName;
        if (lookahead.value === ',') {
            lex();
            if (lookahead.type !== Token.Identifier)
                throwUnexpected(lookahead);
            indexName = lex().value;
        }

        lex();  // in
        var expr = parseExpression();
        parseFilters();
        delegate.createInExpression(identifier.name, indexName, expr);
    }

    function parse(code, inDelegate) {
        delegate = inDelegate;
        source = code;
        index = 0;
        length = source.length;
        lookahead = null;
        state = {
            labelSet: {}
        };

        return parseTopLevel();
    }

    global.esprima = {
        parse: parse
    };
})(this);

// Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
// This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
// The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
// The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
// Code distributed by Google as part of the polymer project is also
// subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt

(function (global) {
  'use strict';

  function prepareBinding(expressionText, name, node, filterRegistry) {
    var expression;
    try {
      expression = getExpression(expressionText);
      if (expression.scopeIdent &&
          (node.nodeType !== Node.ELEMENT_NODE ||
           node.tagName !== 'TEMPLATE' ||
           (name !== 'bind' && name !== 'repeat'))) {
        throw Error('as and in can only be used within <template bind/repeat>');
      }
    } catch (ex) {
      console.error('Invalid expression syntax: ' + expressionText, ex);
      return;
    }

    return function(model, node, oneTime) {
      var binding = expression.getBinding(model, filterRegistry, oneTime);
      if (expression.scopeIdent && binding) {
        node.polymerExpressionScopeIdent_ = expression.scopeIdent;
        if (expression.indexIdent)
          node.polymerExpressionIndexIdent_ = expression.indexIdent;
      }

      return binding;
    }
  }

  // TODO(rafaelw): Implement simple LRU.
  var expressionParseCache = Object.create(null);

  function getExpression(expressionText) {
    var expression = expressionParseCache[expressionText];
    if (!expression) {
      var delegate = new ASTDelegate();
      esprima.parse(expressionText, delegate);
      expression = new Expression(delegate);
      expressionParseCache[expressionText] = expression;
    }
    return expression;
  }

  function Literal(value) {
    this.value = value;
    this.valueFn_ = undefined;
  }

  Literal.prototype = {
    valueFn: function() {
      if (!this.valueFn_) {
        var value = this.value;
        this.valueFn_ = function() {
          return value;
        }
      }

      return this.valueFn_;
    }
  }

  function IdentPath(name) {
    this.name = name;
    this.path = Path.get(name);
  }

  IdentPath.prototype = {
    valueFn: function() {
      if (!this.valueFn_) {
        var name = this.name;
        var path = this.path;
        this.valueFn_ = function(model, observer) {
          if (observer)
            observer.addPath(model, path);

          return path.getValueFrom(model);
        }
      }

      return this.valueFn_;
    },

    setValue: function(model, newValue) {
      if (this.path.length == 1)
        model = findScope(model, this.path[0]);

      return this.path.setValueFrom(model, newValue);
    }
  };

  function MemberExpression(object, property, accessor) {
    this.computed = accessor == '[';

    this.dynamicDeps = typeof object == 'function' ||
                       object.dynamicDeps ||
                       (this.computed && !(property instanceof Literal));

    this.simplePath =
        !this.dynamicDeps &&
        (property instanceof IdentPath || property instanceof Literal) &&
        (object instanceof MemberExpression || object instanceof IdentPath);

    this.object = this.simplePath ? object : getFn(object);
    this.property = !this.computed || this.simplePath ?
        property : getFn(property);
  }

  MemberExpression.prototype = {
    get fullPath() {
      if (!this.fullPath_) {

        var parts = this.object instanceof MemberExpression ?
            this.object.fullPath.slice() : [this.object.name];
        parts.push(this.property instanceof IdentPath ?
            this.property.name : this.property.value);
        this.fullPath_ = Path.get(parts);
      }

      return this.fullPath_;
    },

    valueFn: function() {
      if (!this.valueFn_) {
        var object = this.object;

        if (this.simplePath) {
          var path = this.fullPath;

          this.valueFn_ = function(model, observer) {
            if (observer)
              observer.addPath(model, path);

            return path.getValueFrom(model);
          };
        } else if (!this.computed) {
          var path = Path.get(this.property.name);

          this.valueFn_ = function(model, observer, filterRegistry) {
            var context = object(model, observer, filterRegistry);

            if (observer)
              observer.addPath(context, path);

            return path.getValueFrom(context);
          }
        } else {
          // Computed property.
          var property = this.property;

          this.valueFn_ = function(model, observer, filterRegistry) {
            var context = object(model, observer, filterRegistry);
            var propName = property(model, observer, filterRegistry);
            if (observer)
              observer.addPath(context, [propName]);

            return context ? context[propName] : undefined;
          };
        }
      }
      return this.valueFn_;
    },

    setValue: function(model, newValue) {
      if (this.simplePath) {
        this.fullPath.setValueFrom(model, newValue);
        return newValue;
      }

      var object = this.object(model);
      var propName = this.property instanceof IdentPath ? this.property.name :
          this.property(model);
      return object[propName] = newValue;
    }
  };

  function Filter(name, args) {
    this.name = name;
    this.args = [];
    for (var i = 0; i < args.length; i++) {
      this.args[i] = getFn(args[i]);
    }
  }

  Filter.prototype = {
    transform: function(model, observer, filterRegistry, toModelDirection,
                        initialArgs) {
      var context = model;
      var fn = context[this.name];

      if (!fn) {
        fn = filterRegistry[this.name];
        if (!fn) {
          console.error('Cannot find function or filter: ' + this.name);
          return;
        }
      }

      // If toModelDirection is falsey, then the "normal" (dom-bound) direction
      // is used. Otherwise, it looks for a 'toModel' property function on the
      // object.
      if (toModelDirection) {
        fn = fn.toModel;
      } else if (typeof fn.toDOM == 'function') {
        fn = fn.toDOM;
      }

      if (typeof fn != 'function') {
        console.error('Cannot find function or filter: ' + this.name);
        return;
      }

      var args = initialArgs || [];
      for (var i = 0; i < this.args.length; i++) {
        args.push(getFn(this.args[i])(model, observer, filterRegistry));
      }

      return fn.apply(context, args);
    }
  };

  function notImplemented() { throw Error('Not Implemented'); }

  var unaryOperators = {
    '+': function(v) { return +v; },
    '-': function(v) { return -v; },
    '!': function(v) { return !v; }
  };

  var binaryOperators = {
    '+': function(l, r) { return l+r; },
    '-': function(l, r) { return l-r; },
    '*': function(l, r) { return l*r; },
    '/': function(l, r) { return l/r; },
    '%': function(l, r) { return l%r; },
    '<': function(l, r) { return l<r; },
    '>': function(l, r) { return l>r; },
    '<=': function(l, r) { return l<=r; },
    '>=': function(l, r) { return l>=r; },
    '==': function(l, r) { return l==r; },
    '!=': function(l, r) { return l!=r; },
    '===': function(l, r) { return l===r; },
    '!==': function(l, r) { return l!==r; },
    '&&': function(l, r) { return l&&r; },
    '||': function(l, r) { return l||r; },
  };

  function getFn(arg) {
    return typeof arg == 'function' ? arg : arg.valueFn();
  }

  function ASTDelegate() {
    this.expression = null;
    this.filters = [];
    this.deps = {};
    this.currentPath = undefined;
    this.scopeIdent = undefined;
    this.indexIdent = undefined;
    this.dynamicDeps = false;
  }

  ASTDelegate.prototype = {
    createUnaryExpression: function(op, argument) {
      if (!unaryOperators[op])
        throw Error('Disallowed operator: ' + op);

      argument = getFn(argument);

      return function(model, observer, filterRegistry) {
        return unaryOperators[op](argument(model, observer, filterRegistry));
      };
    },

    createBinaryExpression: function(op, left, right) {
      if (!binaryOperators[op])
        throw Error('Disallowed operator: ' + op);

      left = getFn(left);
      right = getFn(right);

      switch (op) {
        case '||':
          this.dynamicDeps = true;
          return function(model, observer, filterRegistry) {
            return left(model, observer, filterRegistry) ||
                right(model, observer, filterRegistry);
          };
        case '&&':
          this.dynamicDeps = true;
          return function(model, observer, filterRegistry) {
            return left(model, observer, filterRegistry) &&
                right(model, observer, filterRegistry);
          };
      }

      return function(model, observer, filterRegistry) {
        return binaryOperators[op](left(model, observer, filterRegistry),
                                   right(model, observer, filterRegistry));
      };
    },

    createConditionalExpression: function(test, consequent, alternate) {
      test = getFn(test);
      consequent = getFn(consequent);
      alternate = getFn(alternate);

      this.dynamicDeps = true;

      return function(model, observer, filterRegistry) {
        return test(model, observer, filterRegistry) ?
            consequent(model, observer, filterRegistry) :
            alternate(model, observer, filterRegistry);
      }
    },

    createIdentifier: function(name) {
      var ident = new IdentPath(name);
      ident.type = 'Identifier';
      return ident;
    },

    createMemberExpression: function(accessor, object, property) {
      var ex = new MemberExpression(object, property, accessor);
      if (ex.dynamicDeps)
        this.dynamicDeps = true;
      return ex;
    },

    createCallExpression: function(expression, args) {
      if (!(expression instanceof IdentPath))
        throw Error('Only identifier function invocations are allowed');

      var filter = new Filter(expression.name, args);

      return function(model, observer, filterRegistry) {
        return filter.transform(model, observer, filterRegistry, false);
      };
    },

    createLiteral: function(token) {
      return new Literal(token.value);
    },

    createArrayExpression: function(elements) {
      for (var i = 0; i < elements.length; i++)
        elements[i] = getFn(elements[i]);

      return function(model, observer, filterRegistry) {
        var arr = []
        for (var i = 0; i < elements.length; i++)
          arr.push(elements[i](model, observer, filterRegistry));
        return arr;
      }
    },

    createProperty: function(kind, key, value) {
      return {
        key: key instanceof IdentPath ? key.name : key.value,
        value: value
      };
    },

    createObjectExpression: function(properties) {
      for (var i = 0; i < properties.length; i++)
        properties[i].value = getFn(properties[i].value);

      return function(model, observer, filterRegistry) {
        var obj = {};
        for (var i = 0; i < properties.length; i++)
          obj[properties[i].key] =
              properties[i].value(model, observer, filterRegistry);
        return obj;
      }
    },

    createFilter: function(name, args) {
      this.filters.push(new Filter(name, args));
    },

    createAsExpression: function(expression, scopeIdent) {
      this.expression = expression;
      this.scopeIdent = scopeIdent;
    },

    createInExpression: function(scopeIdent, indexIdent, expression) {
      this.expression = expression;
      this.scopeIdent = scopeIdent;
      this.indexIdent = indexIdent;
    },

    createTopLevel: function(expression) {
      this.expression = expression;
    },

    createThisExpression: notImplemented
  }

  function ConstantObservable(value) {
    this.value_ = value;
  }

  ConstantObservable.prototype = {
    open: function() { return this.value_; },
    discardChanges: function() { return this.value_; },
    deliver: function() {},
    close: function() {},
  }

  function Expression(delegate) {
    this.scopeIdent = delegate.scopeIdent;
    this.indexIdent = delegate.indexIdent;

    if (!delegate.expression)
      throw Error('No expression found.');

    this.expression = delegate.expression;
    getFn(this.expression); // forces enumeration of path dependencies

    this.filters = delegate.filters;
    this.dynamicDeps = delegate.dynamicDeps;
  }

  Expression.prototype = {
    getBinding: function(model, filterRegistry, oneTime) {
      if (oneTime)
        return this.getValue(model, undefined, filterRegistry);

      var observer = new CompoundObserver();
      // captures deps.
      var firstValue = this.getValue(model, observer, filterRegistry);
      var firstTime = true;
      var self = this;

      function valueFn() {
        // deps cannot have changed on first value retrieval.
        if (firstTime) {
          firstTime = false;
          return firstValue;
        }

        if (self.dynamicDeps)
          observer.startReset();

        var value = self.getValue(model,
                                  self.dynamicDeps ? observer : undefined,
                                  filterRegistry);
        if (self.dynamicDeps)
          observer.finishReset();

        return value;
      }

      function setValueFn(newValue) {
        self.setValue(model, newValue, filterRegistry);
        return newValue;
      }

      return new ObserverTransform(observer, valueFn, setValueFn, true);
    },

    getValue: function(model, observer, filterRegistry) {
      var value = getFn(this.expression)(model, observer, filterRegistry);
      for (var i = 0; i < this.filters.length; i++) {
        value = this.filters[i].transform(model, observer, filterRegistry,
            false, [value]);
      }

      return value;
    },

    setValue: function(model, newValue, filterRegistry) {
      var count = this.filters ? this.filters.length : 0;
      while (count-- > 0) {
        newValue = this.filters[count].transform(model, undefined,
            filterRegistry, true, [newValue]);
      }

      if (this.expression.setValue)
        return this.expression.setValue(model, newValue);
    }
  }

  /**
   * Converts a style property name to a css property name. For example:
   * "WebkitUserSelect" to "-webkit-user-select"
   */
  function convertStylePropertyName(name) {
    return String(name).replace(/[A-Z]/g, function(c) {
      return '-' + c.toLowerCase();
    });
  }

  var parentScopeName = '@' + Math.random().toString(36).slice(2);

  // Single ident paths must bind directly to the appropriate scope object.
  // I.e. Pushed values in two-bindings need to be assigned to the actual model
  // object.
  function findScope(model, prop) {
    while (model[parentScopeName] &&
           !Object.prototype.hasOwnProperty.call(model, prop)) {
      model = model[parentScopeName];
    }

    return model;
  }

  function isLiteralExpression(pathString) {
    switch (pathString) {
      case '':
        return false;

      case 'false':
      case 'null':
      case 'true':
        return true;
    }

    if (!isNaN(Number(pathString)))
      return true;

    return false;
  };

  function PolymerExpressions() {}

  PolymerExpressions.prototype = {
    // "built-in" filters
    styleObject: function(value) {
      var parts = [];
      for (var key in value) {
        parts.push(convertStylePropertyName(key) + ': ' + value[key]);
      }
      return parts.join('; ');
    },

    tokenList: function(value) {
      var tokens = [];
      for (var key in value) {
        if (value[key])
          tokens.push(key);
      }
      return tokens.join(' ');
    },

    // binding delegate API
    prepareInstancePositionChanged: function(template) {
      var indexIdent = template.polymerExpressionIndexIdent_;
      if (!indexIdent)
        return;

      return function(templateInstance, index) {
        templateInstance.model[indexIdent] = index;
      };
    },

    prepareBinding: function(pathString, name, node) {
      var path = Path.get(pathString);

      if (!isLiteralExpression(pathString) && path.valid) {
        if (path.length == 1) {
          return function(model, node, oneTime) {
            if (oneTime)
              return path.getValueFrom(model);

            var scope = findScope(model, path[0]);
            return new PathObserver(scope, path);
          };
        }
        return; // bail out early if pathString is simple path.
      }

      return prepareBinding(pathString, name, node, this);
    },

    prepareInstanceModel: function(template) {
      var scopeName = template.polymerExpressionScopeIdent_;
      if (!scopeName)
        return;

      var parentScope = template.templateInstance ?
          template.templateInstance.model :
          template.model;

      var indexName = template.polymerExpressionIndexIdent_;

      return function(model) {
        return createScopeObject(parentScope, model, scopeName, indexName);
      };
    }
  };

  var createScopeObject = ('__proto__' in {}) ?
    function(parentScope, model, scopeName, indexName) {
      var scope = {};
      scope[scopeName] = model;
      scope[indexName] = undefined;
      scope[parentScopeName] = parentScope;
      scope.__proto__ = parentScope;
      return scope;
    } :
    function(parentScope, model, scopeName, indexName) {
      var scope = Object.create(parentScope);
      Object.defineProperty(scope, scopeName,
          { value: model, configurable: true, writable: true });
      Object.defineProperty(scope, indexName,
          { value: undefined, configurable: true, writable: true });
      Object.defineProperty(scope, parentScopeName,
          { value: parentScope, configurable: true, writable: true });
      return scope;
    };

  global.PolymerExpressions = PolymerExpressions;
  PolymerExpressions.getExpression = getExpression;
})(this);

Polymer = {
  version: '0.5.5'
};

// TODO(sorvell): this ensures Polymer is an object and not a function
// Platform is currently defining it as a function to allow for async loading
// of polymer; once we refine the loading process this likely goes away.
if (typeof window.Polymer === 'function') {
  Polymer = {};
}


(function(scope) {

  function withDependencies(task, depends) {
    depends = depends || [];
    if (!depends.map) {
      depends = [depends];
    }
    return task.apply(this, depends.map(marshal));
  }

  function module(name, dependsOrFactory, moduleFactory) {
    var module;
    switch (arguments.length) {
      case 0:
        return;
      case 1:
        module = null;
        break;
      case 2:
        // dependsOrFactory is `factory` in this case
        module = dependsOrFactory.apply(this);
        break;
      default:
        // dependsOrFactory is `depends` in this case
        module = withDependencies(moduleFactory, dependsOrFactory);
        break;
    }
    modules[name] = module;
  };

  function marshal(name) {
    return modules[name];
  }

  var modules = {};

  function using(depends, task) {
    HTMLImports.whenImportsReady(function() {
      withDependencies(task, depends);
    });
  };

  // exports

  scope.marshal = marshal;
  // `module` confuses commonjs detectors
  scope.modularize = module;
  scope.using = using;

})(window);

/*
	Build only script.

  Ensures scripts needed for basic x-platform compatibility
  will be run when platform.js is not loaded.
 */
if (!window.WebComponents) {

/*
	On supported platforms, platform.js is not needed. To retain compatibility
	with the polyfills, we stub out minimal functionality.
 */
if (!window.WebComponents) {

  WebComponents = {
  	flush: function() {},
    flags: {log: {}}
  };

  Platform = WebComponents;

  CustomElements = {
  	useNative: true,
    ready: true,
    takeRecords: function() {},
    instanceof: function(obj, base) {
      return obj instanceof base;
    }
  };

  HTMLImports = {
  	useNative: true
  };


  addEventListener('HTMLImportsLoaded', function() {
    document.dispatchEvent(
      new CustomEvent('WebComponentsReady', {bubbles: true})
    );
  });


  // ShadowDOM
  ShadowDOMPolyfill = null;
  wrap = unwrap = function(n){
    return n;
  };

}

/*
  Create polyfill scope and feature detect native support.
*/
window.HTMLImports = window.HTMLImports || {flags:{}};

(function(scope) {

/**
  Basic setup and simple module executer. We collect modules and then execute
  the code later, only if it's necessary for polyfilling.
*/
var IMPORT_LINK_TYPE = 'import';
var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement('link'));

/**
  Support `currentScript` on all browsers as `document._currentScript.`

  NOTE: We cannot polyfill `document.currentScript` because it's not possible
  both to override and maintain the ability to capture the native value.
  Therefore we choose to expose `_currentScript` both when native imports
  and the polyfill are in use.
*/
// NOTE: ShadowDOMPolyfill intrusion.
var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);
var wrap = function(node) {
  return hasShadowDOMPolyfill ? ShadowDOMPolyfill.wrapIfNeeded(node) : node;
};
var rootDocument = wrap(document);

var currentScriptDescriptor = {
  get: function() {
    var script = HTMLImports.currentScript || document.currentScript ||
        // NOTE: only works when called in synchronously executing code.
        // readyState should check if `loading` but IE10 is
        // interactive when scripts run so we cheat.
        (document.readyState !== 'complete' ?
        document.scripts[document.scripts.length - 1] : null);
    return wrap(script);
  },
  configurable: true
};

Object.defineProperty(document, '_currentScript', currentScriptDescriptor);
Object.defineProperty(rootDocument, '_currentScript', currentScriptDescriptor);

/**
  Add support for the `HTMLImportsLoaded` event and the `HTMLImports.whenReady`
  method. This api is necessary because unlike the native implementation,
  script elements do not force imports to resolve. Instead, users should wrap
  code in either an `HTMLImportsLoaded` hander or after load time in an
  `HTMLImports.whenReady(callback)` call.

  NOTE: This module also supports these apis under the native implementation.
  Therefore, if this file is loaded, the same code can be used under both
  the polyfill and native implementation.
 */

var isIE = /Trident/.test(navigator.userAgent);

// call a callback when all HTMLImports in the document at call time
// (or at least document ready) have loaded.
// 1. ensure the document is in a ready state (has dom), then
// 2. watch for loading of imports and call callback when done
function whenReady(callback, doc) {
  doc = doc || rootDocument;
  // if document is loading, wait and try again
  whenDocumentReady(function() {
    watchImportsLoad(callback, doc);
  }, doc);
}

// call the callback when the document is in a ready state (has dom)
var requiredReadyState = isIE ? 'complete' : 'interactive';
var READY_EVENT = 'readystatechange';
function isDocumentReady(doc) {
  return (doc.readyState === 'complete' ||
      doc.readyState === requiredReadyState);
}

// call <callback> when we ensure the document is in a ready state
function whenDocumentReady(callback, doc) {
  if (!isDocumentReady(doc)) {
    var checkReady = function() {
      if (doc.readyState === 'complete' ||
          doc.readyState === requiredReadyState) {
        doc.removeEventListener(READY_EVENT, checkReady);
        whenDocumentReady(callback, doc);
      }
    };
    doc.addEventListener(READY_EVENT, checkReady);
  } else if (callback) {
    callback();
  }
}

function markTargetLoaded(event) {
  event.target.__loaded = true;
}

// call <callback> when we ensure all imports have loaded
function watchImportsLoad(callback, doc) {
  var imports = doc.querySelectorAll('link[rel=import]');
  var loaded = 0, l = imports.length;
  function checkDone(d) {
    if ((loaded == l) && callback) {
       callback();
    }
  }
  function loadedImport(e) {
    markTargetLoaded(e);
    loaded++;
    checkDone();
  }
  if (l) {
    for (var i=0, imp; (i<l) && (imp=imports[i]); i++) {
      if (isImportLoaded(imp)) {
        loadedImport.call(imp, {target: imp});
      } else {
        imp.addEventListener('load', loadedImport);
        imp.addEventListener('error', loadedImport);
      }
    }
  } else {
    checkDone();
  }
}

// NOTE: test for native imports loading is based on explicitly watching
// all imports (see below).
// However, we cannot rely on this entirely without watching the entire document
// for import links. For perf reasons, currently only head is watched.
// Instead, we fallback to checking if the import property is available
// and the document is not itself loading.
function isImportLoaded(link) {
  return useNative ? link.__loaded ||
      (link.import && link.import.readyState !== 'loading') :
      link.__importParsed;
}

// TODO(sorvell): Workaround for
// https://www.w3.org/Bugs/Public/show_bug.cgi?id=25007, should be removed when
// this bug is addressed.
// (1) Install a mutation observer to see when HTMLImports have loaded
// (2) if this script is run during document load it will watch any existing
// imports for loading.
//
// NOTE: The workaround has restricted functionality: (1) it's only compatible
// with imports that are added to document.head since the mutation observer
// watches only head for perf reasons, (2) it requires this script
// to run before any imports have completed loading.
if (useNative) {
  new MutationObserver(function(mxns) {
    for (var i=0, l=mxns.length, m; (i < l) && (m=mxns[i]); i++) {
      if (m.addedNodes) {
        handleImports(m.addedNodes);
      }
    }
  }).observe(document.head, {childList: true});

  function handleImports(nodes) {
    for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {
      if (isImport(n)) {
        handleImport(n);
      }
    }
  }

  function isImport(element) {
    return element.localName === 'link' && element.rel === 'import';
  }

  function handleImport(element) {
    var loaded = element.import;
    if (loaded) {
      markTargetLoaded({target: element});
    } else {
      element.addEventListener('load', markTargetLoaded);
      element.addEventListener('error', markTargetLoaded);
    }
  }

  // make sure to catch any imports that are in the process of loading
  // when this script is run.
  (function() {
    if (document.readyState === 'loading') {
      var imports = document.querySelectorAll('link[rel=import]');
      for (var i=0, l=imports.length, imp; (i<l) && (imp=imports[i]); i++) {
        handleImport(imp);
      }
    }
  })();

}

// Fire the 'HTMLImportsLoaded' event when imports in document at load time
// have loaded. This event is required to simulate the script blocking
// behavior of native imports. A main document script that needs to be sure
// imports have loaded should wait for this event.
whenReady(function() {
  HTMLImports.ready = true;
  HTMLImports.readyTime = new Date().getTime();
  rootDocument.dispatchEvent(
    new CustomEvent('HTMLImportsLoaded', {bubbles: true})
  );
});

// exports
scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;
scope.useNative = useNative;
scope.rootDocument = rootDocument;
scope.whenReady = whenReady;
scope.isIE = isIE;

})(HTMLImports);

(function(scope) {

  // TODO(sorvell): It's desireable to provide a default stylesheet
  // that's convenient for styling unresolved elements, but
  // it's cumbersome to have to include this manually in every page.
  // It would make sense to put inside some HTMLImport but
  // the HTMLImports polyfill does not allow loading of stylesheets
  // that block rendering. Therefore this injection is tolerated here.
  var style = document.createElement('style');
  style.textContent = ''
      + 'body {'
      + 'transition: opacity ease-in 0.2s;'
      + ' } \n'
      + 'body[unresolved] {'
      + 'opacity: 0; display: block; overflow: hidden;'
      + ' } \n'
      ;
  var head = document.querySelector('head');
  head.insertBefore(style, head.firstChild);

})(Platform);

/*
	Build only script.

  Ensures scripts needed for basic x-platform compatibility
  will be run when platform.js is not loaded.
 */
}
(function(global) {
  'use strict';

  var testingExposeCycleCount = global.testingExposeCycleCount;

  // Detect and do basic sanity checking on Object/Array.observe.
  function detectObjectObserve() {
    if (typeof Object.observe !== 'function' ||
        typeof Array.observe !== 'function') {
      return false;
    }

    var records = [];

    function callback(recs) {
      records = recs;
    }

    var test = {};
    var arr = [];
    Object.observe(test, callback);
    Array.observe(arr, callback);
    test.id = 1;
    test.id = 2;
    delete test.id;
    arr.push(1, 2);
    arr.length = 0;

    Object.deliverChangeRecords(callback);
    if (records.length !== 5)
      return false;

    if (records[0].type != 'add' ||
        records[1].type != 'update' ||
        records[2].type != 'delete' ||
        records[3].type != 'splice' ||
        records[4].type != 'splice') {
      return false;
    }

    Object.unobserve(test, callback);
    Array.unobserve(arr, callback);

    return true;
  }

  var hasObserve = detectObjectObserve();

  function detectEval() {
    // Don't test for eval if we're running in a Chrome App environment.
    // We check for APIs set that only exist in a Chrome App context.
    if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {
      return false;
    }

    // Firefox OS Apps do not allow eval. This feature detection is very hacky
    // but even if some other platform adds support for this function this code
    // will continue to work.
    if (typeof navigator != 'undefined' && navigator.getDeviceStorage) {
      return false;
    }

    try {
      var f = new Function('', 'return true;');
      return f();
    } catch (ex) {
      return false;
    }
  }

  var hasEval = detectEval();

  function isIndex(s) {
    return +s === s >>> 0 && s !== '';
  }

  function toNumber(s) {
    return +s;
  }

  function isObject(obj) {
    return obj === Object(obj);
  }

  var numberIsNaN = global.Number.isNaN || function(value) {
    return typeof value === 'number' && global.isNaN(value);
  }

  function areSameValue(left, right) {
    if (left === right)
      return left !== 0 || 1 / left === 1 / right;
    if (numberIsNaN(left) && numberIsNaN(right))
      return true;

    return left !== left && right !== right;
  }

  var createObject = ('__proto__' in {}) ?
    function(obj) { return obj; } :
    function(obj) {
      var proto = obj.__proto__;
      if (!proto)
        return obj;
      var newObject = Object.create(proto);
      Object.getOwnPropertyNames(obj).forEach(function(name) {
        Object.defineProperty(newObject, name,
                             Object.getOwnPropertyDescriptor(obj, name));
      });
      return newObject;
    };

  var identStart = '[\$_a-zA-Z]';
  var identPart = '[\$_a-zA-Z0-9]';
  var identRegExp = new RegExp('^' + identStart + '+' + identPart + '*' + '$');

  function getPathCharType(char) {
    if (char === undefined)
      return 'eof';

    var code = char.charCodeAt(0);

    switch(code) {
      case 0x5B: // [
      case 0x5D: // ]
      case 0x2E: // .
      case 0x22: // "
      case 0x27: // '
      case 0x30: // 0
        return char;

      case 0x5F: // _
      case 0x24: // $
        return 'ident';

      case 0x20: // Space
      case 0x09: // Tab
      case 0x0A: // Newline
      case 0x0D: // Return
      case 0xA0:  // No-break space
      case 0xFEFF:  // Byte Order Mark
      case 0x2028:  // Line Separator
      case 0x2029:  // Paragraph Separator
        return 'ws';
    }

    // a-z, A-Z
    if ((0x61 <= code && code <= 0x7A) || (0x41 <= code && code <= 0x5A))
      return 'ident';

    // 1-9
    if (0x31 <= code && code <= 0x39)
      return 'number';

    return 'else';
  }

  var pathStateMachine = {
    'beforePath': {
      'ws': ['beforePath'],
      'ident': ['inIdent', 'append'],
      '[': ['beforeElement'],
      'eof': ['afterPath']
    },

    'inPath': {
      'ws': ['inPath'],
      '.': ['beforeIdent'],
      '[': ['beforeElement'],
      'eof': ['afterPath']
    },

    'beforeIdent': {
      'ws': ['beforeIdent'],
      'ident': ['inIdent', 'append']
    },

    'inIdent': {
      'ident': ['inIdent', 'append'],
      '0': ['inIdent', 'append'],
      'number': ['inIdent', 'append'],
      'ws': ['inPath', 'push'],
      '.': ['beforeIdent', 'push'],
      '[': ['beforeElement', 'push'],
      'eof': ['afterPath', 'push']
    },

    'beforeElement': {
      'ws': ['beforeElement'],
      '0': ['afterZero', 'append'],
      'number': ['inIndex', 'append'],
      "'": ['inSingleQuote', 'append', ''],
      '"': ['inDoubleQuote', 'append', '']
    },

    'afterZero': {
      'ws': ['afterElement', 'push'],
      ']': ['inPath', 'push']
    },

    'inIndex': {
      '0': ['inIndex', 'append'],
      'number': ['inIndex', 'append'],
      'ws': ['afterElement'],
      ']': ['inPath', 'push']
    },

    'inSingleQuote': {
      "'": ['afterElement'],
      'eof': ['error'],
      'else': ['inSingleQuote', 'append']
    },

    'inDoubleQuote': {
      '"': ['afterElement'],
      'eof': ['error'],
      'else': ['inDoubleQuote', 'append']
    },

    'afterElement': {
      'ws': ['afterElement'],
      ']': ['inPath', 'push']
    }
  }

  function noop() {}

  function parsePath(path) {
    var keys = [];
    var index = -1;
    var c, newChar, key, type, transition, action, typeMap, mode = 'beforePath';

    var actions = {
      push: function() {
        if (key === undefined)
          return;

        keys.push(key);
        key = undefined;
      },

      append: function() {
        if (key === undefined)
          key = newChar
        else
          key += newChar;
      }
    };

    function maybeUnescapeQuote() {
      if (index >= path.length)
        return;

      var nextChar = path[index + 1];
      if ((mode == 'inSingleQuote' && nextChar == "'") ||
          (mode == 'inDoubleQuote' && nextChar == '"')) {
        index++;
        newChar = nextChar;
        actions.append();
        return true;
      }
    }

    while (mode) {
      index++;
      c = path[index];

      if (c == '\\' && maybeUnescapeQuote(mode))
        continue;

      type = getPathCharType(c);
      typeMap = pathStateMachine[mode];
      transition = typeMap[type] || typeMap['else'] || 'error';

      if (transition == 'error')
        return; // parse error;

      mode = transition[0];
      action = actions[transition[1]] || noop;
      newChar = transition[2] === undefined ? c : transition[2];
      action();

      if (mode === 'afterPath') {
        return keys;
      }
    }

    return; // parse error
  }

  function isIdent(s) {
    return identRegExp.test(s);
  }

  var constructorIsPrivate = {};

  function Path(parts, privateToken) {
    if (privateToken !== constructorIsPrivate)
      throw Error('Use Path.get to retrieve path objects');

    for (var i = 0; i < parts.length; i++) {
      this.push(String(parts[i]));
    }

    if (hasEval && this.length) {
      this.getValueFrom = this.compiledGetValueFromFn();
    }
  }

  // TODO(rafaelw): Make simple LRU cache
  var pathCache = {};

  function getPath(pathString) {
    if (pathString instanceof Path)
      return pathString;

    if (pathString == null || pathString.length == 0)
      pathString = '';

    if (typeof pathString != 'string') {
      if (isIndex(pathString.length)) {
        // Constructed with array-like (pre-parsed) keys
        return new Path(pathString, constructorIsPrivate);
      }

      pathString = String(pathString);
    }

    var path = pathCache[pathString];
    if (path)
      return path;

    var parts = parsePath(pathString);
    if (!parts)
      return invalidPath;

    var path = new Path(parts, constructorIsPrivate);
    pathCache[pathString] = path;
    return path;
  }

  Path.get = getPath;

  function formatAccessor(key) {
    if (isIndex(key)) {
      return '[' + key + ']';
    } else {
      return '["' + key.replace(/"/g, '\\"') + '"]';
    }
  }

  Path.prototype = createObject({
    __proto__: [],
    valid: true,

    toString: function() {
      var pathString = '';
      for (var i = 0; i < this.length; i++) {
        var key = this[i];
        if (isIdent(key)) {
          pathString += i ? '.' + key : key;
        } else {
          pathString += formatAccessor(key);
        }
      }

      return pathString;
    },

    getValueFrom: function(obj, directObserver) {
      for (var i = 0; i < this.length; i++) {
        if (obj == null)
          return;
        obj = obj[this[i]];
      }
      return obj;
    },

    iterateObjects: function(obj, observe) {
      for (var i = 0; i < this.length; i++) {
        if (i)
          obj = obj[this[i - 1]];
        if (!isObject(obj))
          return;
        observe(obj, this[i]);
      }
    },

    compiledGetValueFromFn: function() {
      var str = '';
      var pathString = 'obj';
      str += 'if (obj != null';
      var i = 0;
      var key;
      for (; i < (this.length - 1); i++) {
        key = this[i];
        pathString += isIdent(key) ? '.' + key : formatAccessor(key);
        str += ' &&\n     ' + pathString + ' != null';
      }
      str += ')\n';

      var key = this[i];
      pathString += isIdent(key) ? '.' + key : formatAccessor(key);

      str += '  return ' + pathString + ';\nelse\n  return undefined;';
      return new Function('obj', str);
    },

    setValueFrom: function(obj, value) {
      if (!this.length)
        return false;

      for (var i = 0; i < this.length - 1; i++) {
        if (!isObject(obj))
          return false;
        obj = obj[this[i]];
      }

      if (!isObject(obj))
        return false;

      obj[this[i]] = value;
      return true;
    }
  });

  var invalidPath = new Path('', constructorIsPrivate);
  invalidPath.valid = false;
  invalidPath.getValueFrom = invalidPath.setValueFrom = function() {};

  var MAX_DIRTY_CHECK_CYCLES = 1000;

  function dirtyCheck(observer) {
    var cycles = 0;
    while (cycles < MAX_DIRTY_CHECK_CYCLES && observer.check_()) {
      cycles++;
    }
    if (testingExposeCycleCount)
      global.dirtyCheckCycleCount = cycles;

    return cycles > 0;
  }

  function objectIsEmpty(object) {
    for (var prop in object)
      return false;
    return true;
  }

  function diffIsEmpty(diff) {
    return objectIsEmpty(diff.added) &&
           objectIsEmpty(diff.removed) &&
           objectIsEmpty(diff.changed);
  }

  function diffObjectFromOldObject(object, oldObject) {
    var added = {};
    var removed = {};
    var changed = {};

    for (var prop in oldObject) {
      var newValue = object[prop];

      if (newValue !== undefined && newValue === oldObject[prop])
        continue;

      if (!(prop in object)) {
        removed[prop] = undefined;
        continue;
      }

      if (newValue !== oldObject[prop])
        changed[prop] = newValue;
    }

    for (var prop in object) {
      if (prop in oldObject)
        continue;

      added[prop] = object[prop];
    }

    if (Array.isArray(object) && object.length !== oldObject.length)
      changed.length = object.length;

    return {
      added: added,
      removed: removed,
      changed: changed
    };
  }

  var eomTasks = [];
  function runEOMTasks() {
    if (!eomTasks.length)
      return false;

    for (var i = 0; i < eomTasks.length; i++) {
      eomTasks[i]();
    }
    eomTasks.length = 0;
    return true;
  }

  var runEOM = hasObserve ? (function(){
    return function(fn) {
      return Promise.resolve().then(fn);
    }
  })() :
  (function() {
    return function(fn) {
      eomTasks.push(fn);
    };
  })();

  var observedObjectCache = [];

  function newObservedObject() {
    var observer;
    var object;
    var discardRecords = false;
    var first = true;

    function callback(records) {
      if (observer && observer.state_ === OPENED && !discardRecords)
        observer.check_(records);
    }

    return {
      open: function(obs) {
        if (observer)
          throw Error('ObservedObject in use');

        if (!first)
          Object.deliverChangeRecords(callback);

        observer = obs;
        first = false;
      },
      observe: function(obj, arrayObserve) {
        object = obj;
        if (arrayObserve)
          Array.observe(object, callback);
        else
          Object.observe(object, callback);
      },
      deliver: function(discard) {
        discardRecords = discard;
        Object.deliverChangeRecords(callback);
        discardRecords = false;
      },
      close: function() {
        observer = undefined;
        Object.unobserve(object, callback);
        observedObjectCache.push(this);
      }
    };
  }

  /*
   * The observedSet abstraction is a perf optimization which reduces the total
   * number of Object.observe observations of a set of objects. The idea is that
   * groups of Observers will have some object dependencies in common and this
   * observed set ensures that each object in the transitive closure of
   * dependencies is only observed once. The observedSet acts as a write barrier
   * such that whenever any change comes through, all Observers are checked for
   * changed values.
   *
   * Note that this optimization is explicitly moving work from setup-time to
   * change-time.
   *
   * TODO(rafaelw): Implement "garbage collection". In order to move work off
   * the critical path, when Observers are closed, their observed objects are
   * not Object.unobserve(d). As a result, it's possible that if the observedSet
   * is kept open, but some Observers have been closed, it could cause "leaks"
   * (prevent otherwise collectable objects from being collected). At some
   * point, we should implement incremental "gc" which keeps a list of
   * observedSets which may need clean-up and does small amounts of cleanup on a
   * timeout until all is clean.
   */

  function getObservedObject(observer, object, arrayObserve) {
    var dir = observedObjectCache.pop() || newObservedObject();
    dir.open(observer);
    dir.observe(object, arrayObserve);
    return dir;
  }

  var observedSetCache = [];

  function newObservedSet() {
    var observerCount = 0;
    var observers = [];
    var objects = [];
    var rootObj;
    var rootObjProps;

    function observe(obj, prop) {
      if (!obj)
        return;

      if (obj === rootObj)
        rootObjProps[prop] = true;

      if (objects.indexOf(obj) < 0) {
        objects.push(obj);
        Object.observe(obj, callback);
      }

      observe(Object.getPrototypeOf(obj), prop);
    }

    function allRootObjNonObservedProps(recs) {
      for (var i = 0; i < recs.length; i++) {
        var rec = recs[i];
        if (rec.object !== rootObj ||
            rootObjProps[rec.name] ||
            rec.type === 'setPrototype') {
          return false;
        }
      }
      return true;
    }

    function callback(recs) {
      if (allRootObjNonObservedProps(recs))
        return;

      var observer;
      for (var i = 0; i < observers.length; i++) {
        observer = observers[i];
        if (observer.state_ == OPENED) {
          observer.iterateObjects_(observe);
        }
      }

      for (var i = 0; i < observers.length; i++) {
        observer = observers[i];
        if (observer.state_ == OPENED) {
          observer.check_();
        }
      }
    }

    var record = {
      objects: objects,
      get rootObject() { return rootObj; },
      set rootObject(value) {
        rootObj = value;
        rootObjProps = {};
      },
      open: function(obs, object) {
        observers.push(obs);
        observerCount++;
        obs.iterateObjects_(observe);
      },
      close: function(obs) {
        observerCount--;
        if (observerCount > 0) {
          return;
        }

        for (var i = 0; i < objects.length; i++) {
          Object.unobserve(objects[i], callback);
          Observer.unobservedCount++;
        }

        observers.length = 0;
        objects.length = 0;
        rootObj = undefined;
        rootObjProps = undefined;
        observedSetCache.push(this);
        if (lastObservedSet === this)
          lastObservedSet = null;
      },
    };

    return record;
  }

  var lastObservedSet;

  function getObservedSet(observer, obj) {
    if (!lastObservedSet || lastObservedSet.rootObject !== obj) {
      lastObservedSet = observedSetCache.pop() || newObservedSet();
      lastObservedSet.rootObject = obj;
    }
    lastObservedSet.open(observer, obj);
    return lastObservedSet;
  }

  var UNOPENED = 0;
  var OPENED = 1;
  var CLOSED = 2;
  var RESETTING = 3;

  var nextObserverId = 1;

  function Observer() {
    this.state_ = UNOPENED;
    this.callback_ = undefined;
    this.target_ = undefined; // TODO(rafaelw): Should be WeakRef
    this.directObserver_ = undefined;
    this.value_ = undefined;
    this.id_ = nextObserverId++;
  }

  Observer.prototype = {
    open: function(callback, target) {
      if (this.state_ != UNOPENED)
        throw Error('Observer has already been opened.');

      addToAll(this);
      this.callback_ = callback;
      this.target_ = target;
      this.connect_();
      this.state_ = OPENED;
      return this.value_;
    },

    close: function() {
      if (this.state_ != OPENED)
        return;

      removeFromAll(this);
      this.disconnect_();
      this.value_ = undefined;
      this.callback_ = undefined;
      this.target_ = undefined;
      this.state_ = CLOSED;
    },

    deliver: function() {
      if (this.state_ != OPENED)
        return;

      dirtyCheck(this);
    },

    report_: function(changes) {
      try {
        this.callback_.apply(this.target_, changes);
      } catch (ex) {
        Observer._errorThrownDuringCallback = true;
        console.error('Exception caught during observer callback: ' +
                       (ex.stack || ex));
      }
    },

    discardChanges: function() {
      this.check_(undefined, true);
      return this.value_;
    }
  }

  var collectObservers = !hasObserve;
  var allObservers;
  Observer._allObserversCount = 0;

  if (collectObservers) {
    allObservers = [];
  }

  function addToAll(observer) {
    Observer._allObserversCount++;
    if (!collectObservers)
      return;

    allObservers.push(observer);
  }

  function removeFromAll(observer) {
    Observer._allObserversCount--;
  }

  var runningMicrotaskCheckpoint = false;

  global.Platform = global.Platform || {};

  global.Platform.performMicrotaskCheckpoint = function() {
    if (runningMicrotaskCheckpoint)
      return;

    if (!collectObservers)
      return;

    runningMicrotaskCheckpoint = true;

    var cycles = 0;
    var anyChanged, toCheck;

    do {
      cycles++;
      toCheck = allObservers;
      allObservers = [];
      anyChanged = false;

      for (var i = 0; i < toCheck.length; i++) {
        var observer = toCheck[i];
        if (observer.state_ != OPENED)
          continue;

        if (observer.check_())
          anyChanged = true;

        allObservers.push(observer);
      }
      if (runEOMTasks())
        anyChanged = true;
    } while (cycles < MAX_DIRTY_CHECK_CYCLES && anyChanged);

    if (testingExposeCycleCount)
      global.dirtyCheckCycleCount = cycles;

    runningMicrotaskCheckpoint = false;
  };

  if (collectObservers) {
    global.Platform.clearObservers = function() {
      allObservers = [];
    };
  }

  function ObjectObserver(object) {
    Observer.call(this);
    this.value_ = object;
    this.oldObject_ = undefined;
  }

  ObjectObserver.prototype = createObject({
    __proto__: Observer.prototype,

    arrayObserve: false,

    connect_: function(callback, target) {
      if (hasObserve) {
        this.directObserver_ = getObservedObject(this, this.value_,
                                                 this.arrayObserve);
      } else {
        this.oldObject_ = this.copyObject(this.value_);
      }

    },

    copyObject: function(object) {
      var copy = Array.isArray(object) ? [] : {};
      for (var prop in object) {
        copy[prop] = object[prop];
      };
      if (Array.isArray(object))
        copy.length = object.length;
      return copy;
    },

    check_: function(changeRecords, skipChanges) {
      var diff;
      var oldValues;
      if (hasObserve) {
        if (!changeRecords)
          return false;

        oldValues = {};
        diff = diffObjectFromChangeRecords(this.value_, changeRecords,
                                           oldValues);
      } else {
        oldValues = this.oldObject_;
        diff = diffObjectFromOldObject(this.value_, this.oldObject_);
      }

      if (diffIsEmpty(diff))
        return false;

      if (!hasObserve)
        this.oldObject_ = this.copyObject(this.value_);

      this.report_([
        diff.added || {},
        diff.removed || {},
        diff.changed || {},
        function(property) {
          return oldValues[property];
        }
      ]);

      return true;
    },

    disconnect_: function() {
      if (hasObserve) {
        this.directObserver_.close();
        this.directObserver_ = undefined;
      } else {
        this.oldObject_ = undefined;
      }
    },

    deliver: function() {
      if (this.state_ != OPENED)
        return;

      if (hasObserve)
        this.directObserver_.deliver(false);
      else
        dirtyCheck(this);
    },

    discardChanges: function() {
      if (this.directObserver_)
        this.directObserver_.deliver(true);
      else
        this.oldObject_ = this.copyObject(this.value_);

      return this.value_;
    }
  });

  function ArrayObserver(array) {
    if (!Array.isArray(array))
      throw Error('Provided object is not an Array');
    ObjectObserver.call(this, array);
  }

  ArrayObserver.prototype = createObject({

    __proto__: ObjectObserver.prototype,

    arrayObserve: true,

    copyObject: function(arr) {
      return arr.slice();
    },

    check_: function(changeRecords) {
      var splices;
      if (hasObserve) {
        if (!changeRecords)
          return false;
        splices = projectArraySplices(this.value_, changeRecords);
      } else {
        splices = calcSplices(this.value_, 0, this.value_.length,
                              this.oldObject_, 0, this.oldObject_.length);
      }

      if (!splices || !splices.length)
        return false;

      if (!hasObserve)
        this.oldObject_ = this.copyObject(this.value_);

      this.report_([splices]);
      return true;
    }
  });

  ArrayObserver.applySplices = function(previous, current, splices) {
    splices.forEach(function(splice) {
      var spliceArgs = [splice.index, splice.removed.length];
      var addIndex = splice.index;
      while (addIndex < splice.index + splice.addedCount) {
        spliceArgs.push(current[addIndex]);
        addIndex++;
      }

      Array.prototype.splice.apply(previous, spliceArgs);
    });
  };

  function PathObserver(object, path) {
    Observer.call(this);

    this.object_ = object;
    this.path_ = getPath(path);
    this.directObserver_ = undefined;
  }

  PathObserver.prototype = createObject({
    __proto__: Observer.prototype,

    get path() {
      return this.path_;
    },

    connect_: function() {
      if (hasObserve)
        this.directObserver_ = getObservedSet(this, this.object_);

      this.check_(undefined, true);
    },

    disconnect_: function() {
      this.value_ = undefined;

      if (this.directObserver_) {
        this.directObserver_.close(this);
        this.directObserver_ = undefined;
      }
    },

    iterateObjects_: function(observe) {
      this.path_.iterateObjects(this.object_, observe);
    },

    check_: function(changeRecords, skipChanges) {
      var oldValue = this.value_;
      this.value_ = this.path_.getValueFrom(this.object_);
      if (skipChanges || areSameValue(this.value_, oldValue))
        return false;

      this.report_([this.value_, oldValue, this]);
      return true;
    },

    setValue: function(newValue) {
      if (this.path_)
        this.path_.setValueFrom(this.object_, newValue);
    }
  });

  function CompoundObserver(reportChangesOnOpen) {
    Observer.call(this);

    this.reportChangesOnOpen_ = reportChangesOnOpen;
    this.value_ = [];
    this.directObserver_ = undefined;
    this.observed_ = [];
  }

  var observerSentinel = {};

  CompoundObserver.prototype = createObject({
    __proto__: Observer.prototype,

    connect_: function() {
      if (hasObserve) {
        var object;
        var needsDirectObserver = false;
        for (var i = 0; i < this.observed_.length; i += 2) {
          object = this.observed_[i]
          if (object !== observerSentinel) {
            needsDirectObserver = true;
            break;
          }
        }

        if (needsDirectObserver)
          this.directObserver_ = getObservedSet(this, object);
      }

      this.check_(undefined, !this.reportChangesOnOpen_);
    },

    disconnect_: function() {
      for (var i = 0; i < this.observed_.length; i += 2) {
        if (this.observed_[i] === observerSentinel)
          this.observed_[i + 1].close();
      }
      this.observed_.length = 0;
      this.value_.length = 0;

      if (this.directObserver_) {
        this.directObserver_.close(this);
        this.directObserver_ = undefined;
      }
    },

    addPath: function(object, path) {
      if (this.state_ != UNOPENED && this.state_ != RESETTING)
        throw Error('Cannot add paths once started.');

      var path = getPath(path);
      this.observed_.push(object, path);
      if (!this.reportChangesOnOpen_)
        return;
      var index = this.observed_.length / 2 - 1;
      this.value_[index] = path.getValueFrom(object);
    },

    addObserver: function(observer) {
      if (this.state_ != UNOPENED && this.state_ != RESETTING)
        throw Error('Cannot add observers once started.');

      this.observed_.push(observerSentinel, observer);
      if (!this.reportChangesOnOpen_)
        return;
      var index = this.observed_.length / 2 - 1;
      this.value_[index] = observer.open(this.deliver, this);
    },

    startReset: function() {
      if (this.state_ != OPENED)
        throw Error('Can only reset while open');

      this.state_ = RESETTING;
      this.disconnect_();
    },

    finishReset: function() {
      if (this.state_ != RESETTING)
        throw Error('Can only finishReset after startReset');
      this.state_ = OPENED;
      this.connect_();

      return this.value_;
    },

    iterateObjects_: function(observe) {
      var object;
      for (var i = 0; i < this.observed_.length; i += 2) {
        object = this.observed_[i]
        if (object !== observerSentinel)
          this.observed_[i + 1].iterateObjects(object, observe)
      }
    },

    check_: function(changeRecords, skipChanges) {
      var oldValues;
      for (var i = 0; i < this.observed_.length; i += 2) {
        var object = this.observed_[i];
        var path = this.observed_[i+1];
        var value;
        if (object === observerSentinel) {
          var observable = path;
          value = this.state_ === UNOPENED ?
              observable.open(this.deliver, this) :
              observable.discardChanges();
        } else {
          value = path.getValueFrom(object);
        }

        if (skipChanges) {
          this.value_[i / 2] = value;
          continue;
        }

        if (areSameValue(value, this.value_[i / 2]))
          continue;

        oldValues = oldValues || [];
        oldValues[i / 2] = this.value_[i / 2];
        this.value_[i / 2] = value;
      }

      if (!oldValues)
        return false;

      // TODO(rafaelw): Having observed_ as the third callback arg here is
      // pretty lame API. Fix.
      this.report_([this.value_, oldValues, this.observed_]);
      return true;
    }
  });

  function identFn(value) { return value; }

  function ObserverTransform(observable, getValueFn, setValueFn,
                             dontPassThroughSet) {
    this.callback_ = undefined;
    this.target_ = undefined;
    this.value_ = undefined;
    this.observable_ = observable;
    this.getValueFn_ = getValueFn || identFn;
    this.setValueFn_ = setValueFn || identFn;
    // TODO(rafaelw): This is a temporary hack. PolymerExpressions needs this
    // at the moment because of a bug in it's dependency tracking.
    this.dontPassThroughSet_ = dontPassThroughSet;
  }

  ObserverTransform.prototype = {
    open: function(callback, target) {
      this.callback_ = callback;
      this.target_ = target;
      this.value_ =
          this.getValueFn_(this.observable_.open(this.observedCallback_, this));
      return this.value_;
    },

    observedCallback_: function(value) {
      value = this.getValueFn_(value);
      if (areSameValue(value, this.value_))
        return;
      var oldValue = this.value_;
      this.value_ = value;
      this.callback_.call(this.target_, this.value_, oldValue);
    },

    discardChanges: function() {
      this.value_ = this.getValueFn_(this.observable_.discardChanges());
      return this.value_;
    },

    deliver: function() {
      return this.observable_.deliver();
    },

    setValue: function(value) {
      value = this.setValueFn_(value);
      if (!this.dontPassThroughSet_ && this.observable_.setValue)
        return this.observable_.setValue(value);
    },

    close: function() {
      if (this.observable_)
        this.observable_.close();
      this.callback_ = undefined;
      this.target_ = undefined;
      this.observable_ = undefined;
      this.value_ = undefined;
      this.getValueFn_ = undefined;
      this.setValueFn_ = undefined;
    }
  }

  var expectedRecordTypes = {
    add: true,
    update: true,
    delete: true
  };

  function diffObjectFromChangeRecords(object, changeRecords, oldValues) {
    var added = {};
    var removed = {};

    for (var i = 0; i < changeRecords.length; i++) {
      var record = changeRecords[i];
      if (!expectedRecordTypes[record.type]) {
        console.error('Unknown changeRecord type: ' + record.type);
        console.error(record);
        continue;
      }

      if (!(record.name in oldValues))
        oldValues[record.name] = record.oldValue;

      if (record.type == 'update')
        continue;

      if (record.type == 'add') {
        if (record.name in removed)
          delete removed[record.name];
        else
          added[record.name] = true;

        continue;
      }

      // type = 'delete'
      if (record.name in added) {
        delete added[record.name];
        delete oldValues[record.name];
      } else {
        removed[record.name] = true;
      }
    }

    for (var prop in added)
      added[prop] = object[prop];

    for (var prop in removed)
      removed[prop] = undefined;

    var changed = {};
    for (var prop in oldValues) {
      if (prop in added || prop in removed)
        continue;

      var newValue = object[prop];
      if (oldValues[prop] !== newValue)
        changed[prop] = newValue;
    }

    return {
      added: added,
      removed: removed,
      changed: changed
    };
  }

  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }

  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;

  function ArraySplice() {}

  ArraySplice.prototype = {

    // Note: This function is *based* on the computation of the Levenshtein
    // "edit" distance. The one change is that "updates" are treated as two
    // edits - not one. With Array splices, an update is really a delete
    // followed by an add. By retaining this, we optimize for "keeping" the
    // maximum array items in the original array. For example:
    //
    //   'xxxx123' -> '123yyyy'
    //
    // With 1-edit updates, the shortest path would be just to update all seven
    // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
    // leaves the substring '123' intact.
    calcEditDistances: function(current, currentStart, currentEnd,
                                old, oldStart, oldEnd) {
      // "Deletion" columns
      var rowCount = oldEnd - oldStart + 1;
      var columnCount = currentEnd - currentStart + 1;
      var distances = new Array(rowCount);

      // "Addition" rows. Initialize null column.
      for (var i = 0; i < rowCount; i++) {
        distances[i] = new Array(columnCount);
        distances[i][0] = i;
      }

      // Initialize null row
      for (var j = 0; j < columnCount; j++)
        distances[0][j] = j;

      for (var i = 1; i < rowCount; i++) {
        for (var j = 1; j < columnCount; j++) {
          if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
            distances[i][j] = distances[i - 1][j - 1];
          else {
            var north = distances[i - 1][j] + 1;
            var west = distances[i][j - 1] + 1;
            distances[i][j] = north < west ? north : west;
          }
        }
      }

      return distances;
    },

    // This starts at the final weight, and walks "backward" by finding
    // the minimum previous weight recursively until the origin of the weight
    // matrix.
    spliceOperationsFromEditDistances: function(distances) {
      var i = distances.length - 1;
      var j = distances[0].length - 1;
      var current = distances[i][j];
      var edits = [];
      while (i > 0 || j > 0) {
        if (i == 0) {
          edits.push(EDIT_ADD);
          j--;
          continue;
        }
        if (j == 0) {
          edits.push(EDIT_DELETE);
          i--;
          continue;
        }
        var northWest = distances[i - 1][j - 1];
        var west = distances[i - 1][j];
        var north = distances[i][j - 1];

        var min;
        if (west < north)
          min = west < northWest ? west : northWest;
        else
          min = north < northWest ? north : northWest;

        if (min == northWest) {
          if (northWest == current) {
            edits.push(EDIT_LEAVE);
          } else {
            edits.push(EDIT_UPDATE);
            current = northWest;
          }
          i--;
          j--;
        } else if (min == west) {
          edits.push(EDIT_DELETE);
          i--;
          current = west;
        } else {
          edits.push(EDIT_ADD);
          j--;
          current = north;
        }
      }

      edits.reverse();
      return edits;
    },

    /**
     * Splice Projection functions:
     *
     * A splice map is a representation of how a previous array of items
     * was transformed into a new array of items. Conceptually it is a list of
     * tuples of
     *
     *   <index, removed, addedCount>
     *
     * which are kept in ascending index order of. The tuple represents that at
     * the |index|, |removed| sequence of items were removed, and counting forward
     * from |index|, |addedCount| items were added.
     */

    /**
     * Lacking individual splice mutation information, the minimal set of
     * splices can be synthesized given the previous state and final state of an
     * array. The basic approach is to calculate the edit distance matrix and
     * choose the shortest path through it.
     *
     * Complexity: O(l * p)
     *   l: The length of the current array
     *   p: The length of the old array
     */
    calcSplices: function(current, currentStart, currentEnd,
                          old, oldStart, oldEnd) {
      var prefixCount = 0;
      var suffixCount = 0;

      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
      if (currentStart == 0 && oldStart == 0)
        prefixCount = this.sharedPrefix(current, old, minLength);

      if (currentEnd == current.length && oldEnd == old.length)
        suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);

      currentStart += prefixCount;
      oldStart += prefixCount;
      currentEnd -= suffixCount;
      oldEnd -= suffixCount;

      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
        return [];

      if (currentStart == currentEnd) {
        var splice = newSplice(currentStart, [], 0);
        while (oldStart < oldEnd)
          splice.removed.push(old[oldStart++]);

        return [ splice ];
      } else if (oldStart == oldEnd)
        return [ newSplice(currentStart, [], currentEnd - currentStart) ];

      var ops = this.spliceOperationsFromEditDistances(
          this.calcEditDistances(current, currentStart, currentEnd,
                                 old, oldStart, oldEnd));

      var splice = undefined;
      var splices = [];
      var index = currentStart;
      var oldIndex = oldStart;
      for (var i = 0; i < ops.length; i++) {
        switch(ops[i]) {
          case EDIT_LEAVE:
            if (splice) {
              splices.push(splice);
              splice = undefined;
            }

            index++;
            oldIndex++;
            break;
          case EDIT_UPDATE:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.addedCount++;
            index++;

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
          case EDIT_ADD:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.addedCount++;
            index++;
            break;
          case EDIT_DELETE:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
        }
      }

      if (splice) {
        splices.push(splice);
      }
      return splices;
    },

    sharedPrefix: function(current, old, searchLength) {
      for (var i = 0; i < searchLength; i++)
        if (!this.equals(current[i], old[i]))
          return i;
      return searchLength;
    },

    sharedSuffix: function(current, old, searchLength) {
      var index1 = current.length;
      var index2 = old.length;
      var count = 0;
      while (count < searchLength && this.equals(current[--index1], old[--index2]))
        count++;

      return count;
    },

    calculateSplices: function(current, previous) {
      return this.calcSplices(current, 0, current.length, previous, 0,
                              previous.length);
    },

    equals: function(currentValue, previousValue) {
      return currentValue === previousValue;
    }
  };

  var arraySplice = new ArraySplice();

  function calcSplices(current, currentStart, currentEnd,
                       old, oldStart, oldEnd) {
    return arraySplice.calcSplices(current, currentStart, currentEnd,
                                   old, oldStart, oldEnd);
  }

  function intersect(start1, end1, start2, end2) {
    // Disjoint
    if (end1 < start2 || end2 < start1)
      return -1;

    // Adjacent
    if (end1 == start2 || end2 == start1)
      return 0;

    // Non-zero intersect, span1 first
    if (start1 < start2) {
      if (end1 < end2)
        return end1 - start2; // Overlap
      else
        return end2 - start2; // Contained
    } else {
      // Non-zero intersect, span2 first
      if (end2 < end1)
        return end2 - start1; // Overlap
      else
        return end1 - start1; // Contained
    }
  }

  function mergeSplice(splices, index, removed, addedCount) {

    var splice = newSplice(index, removed, addedCount);

    var inserted = false;
    var insertionOffset = 0;

    for (var i = 0; i < splices.length; i++) {
      var current = splices[i];
      current.index += insertionOffset;

      if (inserted)
        continue;

      var intersectCount = intersect(splice.index,
                                     splice.index + splice.removed.length,
                                     current.index,
                                     current.index + current.addedCount);

      if (intersectCount >= 0) {
        // Merge the two splices

        splices.splice(i, 1);
        i--;

        insertionOffset -= current.addedCount - current.removed.length;

        splice.addedCount += current.addedCount - intersectCount;
        var deleteCount = splice.removed.length +
                          current.removed.length - intersectCount;

        if (!splice.addedCount && !deleteCount) {
          // merged splice is a noop. discard.
          inserted = true;
        } else {
          var removed = current.removed;

          if (splice.index < current.index) {
            // some prefix of splice.removed is prepended to current.removed.
            var prepend = splice.removed.slice(0, current.index - splice.index);
            Array.prototype.push.apply(prepend, removed);
            removed = prepend;
          }

          if (splice.index + splice.removed.length > current.index + current.addedCount) {
            // some suffix of splice.removed is appended to current.removed.
            var append = splice.removed.slice(current.index + current.addedCount - splice.index);
            Array.prototype.push.apply(removed, append);
          }

          splice.removed = removed;
          if (current.index < splice.index) {
            splice.index = current.index;
          }
        }
      } else if (splice.index < current.index) {
        // Insert splice here.

        inserted = true;

        splices.splice(i, 0, splice);
        i++;

        var offset = splice.addedCount - splice.removed.length
        current.index += offset;
        insertionOffset += offset;
      }
    }

    if (!inserted)
      splices.push(splice);
  }

  function createInitialSplices(array, changeRecords) {
    var splices = [];

    for (var i = 0; i < changeRecords.length; i++) {
      var record = changeRecords[i];
      switch(record.type) {
        case 'splice':
          mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);
          break;
        case 'add':
        case 'update':
        case 'delete':
          if (!isIndex(record.name))
            continue;
          var index = toNumber(record.name);
          if (index < 0)
            continue;
          mergeSplice(splices, index, [record.oldValue], 1);
          break;
        default:
          console.error('Unexpected record type: ' + JSON.stringify(record));
          break;
      }
    }

    return splices;
  }

  function projectArraySplices(array, changeRecords) {
    var splices = [];

    createInitialSplices(array, changeRecords).forEach(function(splice) {
      if (splice.addedCount == 1 && splice.removed.length == 1) {
        if (splice.removed[0] !== array[splice.index])
          splices.push(splice);

        return
      };

      splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount,
                                           splice.removed, 0, splice.removed.length));
    });

    return splices;
  }

  // Export the observe-js object for **Node.js**, with backwards-compatibility
  // for the old `require()` API. Also ensure `exports` is not a DOM Element.
  // If we're in the browser, export as a global object.

  var expose = global;

  if (typeof exports !== 'undefined' && !exports.nodeType) {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports;
    }
    expose = exports;
  }

  expose.Observer = Observer;
  expose.Observer.runEOM_ = runEOM;
  expose.Observer.observerSentinel_ = observerSentinel; // for testing.
  expose.Observer.hasObjectObserve = hasObserve;
  expose.ArrayObserver = ArrayObserver;
  expose.ArrayObserver.calculateSplices = function(current, previous) {
    return arraySplice.calculateSplices(current, previous);
  };

  expose.ArraySplice = ArraySplice;
  expose.ObjectObserver = ObjectObserver;
  expose.PathObserver = PathObserver;
  expose.CompoundObserver = CompoundObserver;
  expose.Path = Path;
  expose.ObserverTransform = ObserverTransform;

})(typeof global !== 'undefined' && global && typeof module !== 'undefined' && module ? global : this || window);

// Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
// This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
// The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
// The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
// Code distributed by Google as part of the polymer project is also
// subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt

(function(global) {
  'use strict';

  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);

  function getTreeScope(node) {
    while (node.parentNode) {
      node = node.parentNode;
    }

    return typeof node.getElementById === 'function' ? node : null;
  }

  Node.prototype.bind = function(name, observable) {
    console.error('Unhandled binding to Node: ', this, name, observable);
  };

  Node.prototype.bindFinished = function() {};

  function updateBindings(node, name, binding) {
    var bindings = node.bindings_;
    if (!bindings)
      bindings = node.bindings_ = {};

    if (bindings[name])
      binding[name].close();

    return bindings[name] = binding;
  }

  function returnBinding(node, name, binding) {
    return binding;
  }

  function sanitizeValue(value) {
    return value == null ? '' : value;
  }

  function updateText(node, value) {
    node.data = sanitizeValue(value);
  }

  function textBinding(node) {
    return function(value) {
      return updateText(node, value);
    };
  }

  var maybeUpdateBindings = returnBinding;

  Object.defineProperty(Platform, 'enableBindingsReflection', {
    get: function() {
      return maybeUpdateBindings === updateBindings;
    },
    set: function(enable) {
      maybeUpdateBindings = enable ? updateBindings : returnBinding;
      return enable;
    },
    configurable: true
  });

  Text.prototype.bind = function(name, value, oneTime) {
    if (name !== 'textContent')
      return Node.prototype.bind.call(this, name, value, oneTime);

    if (oneTime)
      return updateText(this, value);

    var observable = value;
    updateText(this, observable.open(textBinding(this)));
    return maybeUpdateBindings(this, name, observable);
  }

  function updateAttribute(el, name, conditional, value) {
    if (conditional) {
      if (value)
        el.setAttribute(name, '');
      else
        el.removeAttribute(name);
      return;
    }

    el.setAttribute(name, sanitizeValue(value));
  }

  function attributeBinding(el, name, conditional) {
    return function(value) {
      updateAttribute(el, name, conditional, value);
    };
  }

  Element.prototype.bind = function(name, value, oneTime) {
    var conditional = name[name.length - 1] == '?';
    if (conditional) {
      this.removeAttribute(name);
      name = name.slice(0, -1);
    }

    if (oneTime)
      return updateAttribute(this, name, conditional, value);


    var observable = value;
    updateAttribute(this, name, conditional,
        observable.open(attributeBinding(this, name, conditional)));

    return maybeUpdateBindings(this, name, observable);
  };

  var checkboxEventType;
  (function() {
    // Attempt to feature-detect which event (change or click) is fired first
    // for checkboxes.
    var div = document.createElement('div');
    var checkbox = div.appendChild(document.createElement('input'));
    checkbox.setAttribute('type', 'checkbox');
    var first;
    var count = 0;
    checkbox.addEventListener('click', function(e) {
      count++;
      first = first || 'click';
    });
    checkbox.addEventListener('change', function() {
      count++;
      first = first || 'change';
    });

    var event = document.createEvent('MouseEvent');
    event.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false,
        false, false, false, 0, null);
    checkbox.dispatchEvent(event);
    // WebKit/Blink don't fire the change event if the element is outside the
    // document, so assume 'change' for that case.
    checkboxEventType = count == 1 ? 'change' : first;
  })();

  function getEventForInputType(element) {
    switch (element.type) {
      case 'checkbox':
        return checkboxEventType;
      case 'radio':
      case 'select-multiple':
      case 'select-one':
        return 'change';
      case 'range':
        if (/Trident|MSIE/.test(navigator.userAgent))
          return 'change';
      default:
        return 'input';
    }
  }

  function updateInput(input, property, value, santizeFn) {
    input[property] = (santizeFn || sanitizeValue)(value);
  }

  function inputBinding(input, property, santizeFn) {
    return function(value) {
      return updateInput(input, property, value, santizeFn);
    }
  }

  function noop() {}

  function bindInputEvent(input, property, observable, postEventFn) {
    var eventType = getEventForInputType(input);

    function eventHandler() {
      var isNum = property == 'value' && input.type == 'number';
      observable.setValue(isNum ? input.valueAsNumber : input[property]);
      observable.discardChanges();
      (postEventFn || noop)(input);
      Platform.performMicrotaskCheckpoint();
    }
    input.addEventListener(eventType, eventHandler);

    return {
      close: function() {
        input.removeEventListener(eventType, eventHandler);
        observable.close();
      },

      observable_: observable
    }
  }

  function booleanSanitize(value) {
    return Boolean(value);
  }

  // |element| is assumed to be an HTMLInputElement with |type| == 'radio'.
  // Returns an array containing all radio buttons other than |element| that
  // have the same |name|, either in the form that |element| belongs to or,
  // if no form, in the document tree to which |element| belongs.
  //
  // This implementation is based upon the HTML spec definition of a
  // "radio button group":
  //   http://www.whatwg.org/specs/web-apps/current-work/multipage/number-state.html#radio-button-group
  //
  function getAssociatedRadioButtons(element) {
    if (element.form) {
      return filter(element.form.elements, function(el) {
        return el != element &&
            el.tagName == 'INPUT' &&
            el.type == 'radio' &&
            el.name == element.name;
      });
    } else {
      var treeScope = getTreeScope(element);
      if (!treeScope)
        return [];
      var radios = treeScope.querySelectorAll(
          'input[type="radio"][name="' + element.name + '"]');
      return filter(radios, function(el) {
        return el != element && !el.form;
      });
    }
  }

  function checkedPostEvent(input) {
    // Only the radio button that is getting checked gets an event. We
    // therefore find all the associated radio buttons and update their
    // check binding manually.
    if (input.tagName === 'INPUT' &&
        input.type === 'radio') {
      getAssociatedRadioButtons(input).forEach(function(radio) {
        var checkedBinding = radio.bindings_.checked;
        if (checkedBinding) {
          // Set the value directly to avoid an infinite call stack.
          checkedBinding.observable_.setValue(false);
        }
      });
    }
  }

  HTMLInputElement.prototype.bind = function(name, value, oneTime) {
    if (name !== 'value' && name !== 'checked')
      return HTMLElement.prototype.bind.call(this, name, value, oneTime);

    this.removeAttribute(name);
    var sanitizeFn = name == 'checked' ? booleanSanitize : sanitizeValue;
    var postEventFn = name == 'checked' ? checkedPostEvent : noop;

    if (oneTime)
      return updateInput(this, name, value, sanitizeFn);


    var observable = value;
    var binding = bindInputEvent(this, name, observable, postEventFn);
    updateInput(this, name,
                observable.open(inputBinding(this, name, sanitizeFn)),
                sanitizeFn);

    // Checkboxes may need to update bindings of other checkboxes.
    return updateBindings(this, name, binding);
  }

  HTMLTextAreaElement.prototype.bind = function(name, value, oneTime) {
    if (name !== 'value')
      return HTMLElement.prototype.bind.call(this, name, value, oneTime);

    this.removeAttribute('value');

    if (oneTime)
      return updateInput(this, 'value', value);

    var observable = value;
    var binding = bindInputEvent(this, 'value', observable);
    updateInput(this, 'value',
                observable.open(inputBinding(this, 'value', sanitizeValue)));
    return maybeUpdateBindings(this, name, binding);
  }

  function updateOption(option, value) {
    var parentNode = option.parentNode;;
    var select;
    var selectBinding;
    var oldValue;
    if (parentNode instanceof HTMLSelectElement &&
        parentNode.bindings_ &&
        parentNode.bindings_.value) {
      select = parentNode;
      selectBinding = select.bindings_.value;
      oldValue = select.value;
    }

    option.value = sanitizeValue(value);

    if (select && select.value != oldValue) {
      selectBinding.observable_.setValue(select.value);
      selectBinding.observable_.discardChanges();
      Platform.performMicrotaskCheckpoint();
    }
  }

  function optionBinding(option) {
    return function(value) {
      updateOption(option, value);
    }
  }

  HTMLOptionElement.prototype.bind = function(name, value, oneTime) {
    if (name !== 'value')
      return HTMLElement.prototype.bind.call(this, name, value, oneTime);

    this.removeAttribute('value');

    if (oneTime)
      return updateOption(this, value);

    var observable = value;
    var binding = bindInputEvent(this, 'value', observable);
    updateOption(this, observable.open(optionBinding(this)));
    return maybeUpdateBindings(this, name, binding);
  }

  HTMLSelectElement.prototype.bind = function(name, value, oneTime) {
    if (name === 'selectedindex')
      name = 'selectedIndex';

    if (name !== 'selectedIndex' && name !== 'value')
      return HTMLElement.prototype.bind.call(this, name, value, oneTime);

    this.removeAttribute(name);

    if (oneTime)
      return updateInput(this, name, value);

    var observable = value;
    var binding = bindInputEvent(this, name, observable);
    updateInput(this, name,
                observable.open(inputBinding(this, name)));

    // Option update events may need to access select bindings.
    return updateBindings(this, name, binding);
  }
})(this);

// Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
// This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
// The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
// The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
// Code distributed by Google as part of the polymer project is also
// subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt

(function(global) {
  'use strict';

  function assert(v) {
    if (!v)
      throw new Error('Assertion failed');
  }

  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);

  function getFragmentRoot(node) {
    var p;
    while (p = node.parentNode) {
      node = p;
    }

    return node;
  }

  function searchRefId(node, id) {
    if (!id)
      return;

    var ref;
    var selector = '#' + id;
    while (!ref) {
      node = getFragmentRoot(node);

      if (node.protoContent_)
        ref = node.protoContent_.querySelector(selector);
      else if (node.getElementById)
        ref = node.getElementById(id);

      if (ref || !node.templateCreator_)
        break

      node = node.templateCreator_;
    }

    return ref;
  }

  function getInstanceRoot(node) {
    while (node.parentNode) {
      node = node.parentNode;
    }
    return node.templateCreator_ ? node : null;
  }

  var Map;
  if (global.Map && typeof global.Map.prototype.forEach === 'function') {
    Map = global.Map;
  } else {
    Map = function() {
      this.keys = [];
      this.values = [];
    };

    Map.prototype = {
      set: function(key, value) {
        var index = this.keys.indexOf(key);
        if (index < 0) {
          this.keys.push(key);
          this.values.push(value);
        } else {
          this.values[index] = value;
        }
      },

      get: function(key) {
        var index = this.keys.indexOf(key);
        if (index < 0)
          return;

        return this.values[index];
      },

      delete: function(key, value) {
        var index = this.keys.indexOf(key);
        if (index < 0)
          return false;

        this.keys.splice(index, 1);
        this.values.splice(index, 1);
        return true;
      },

      forEach: function(f, opt_this) {
        for (var i = 0; i < this.keys.length; i++)
          f.call(opt_this || this, this.values[i], this.keys[i], this);
      }
    };
  }

  // JScript does not have __proto__. We wrap all object literals with
  // createObject which uses Object.create, Object.defineProperty and
  // Object.getOwnPropertyDescriptor to create a new object that does the exact
  // same thing. The main downside to this solution is that we have to extract
  // all those property descriptors for IE.
  var createObject = ('__proto__' in {}) ?
      function(obj) { return obj; } :
      function(obj) {
        var proto = obj.__proto__;
        if (!proto)
          return obj;
        var newObject = Object.create(proto);
        Object.getOwnPropertyNames(obj).forEach(function(name) {
          Object.defineProperty(newObject, name,
                               Object.getOwnPropertyDescriptor(obj, name));
        });
        return newObject;
      };

  // IE does not support have Document.prototype.contains.
  if (typeof document.contains != 'function') {
    Document.prototype.contains = function(node) {
      if (node === this || node.parentNode === this)
        return true;
      return this.documentElement.contains(node);
    }
  }

  var BIND = 'bind';
  var REPEAT = 'repeat';
  var IF = 'if';

  var templateAttributeDirectives = {
    'template': true,
    'repeat': true,
    'bind': true,
    'ref': true,
    'if': true
  };

  var semanticTemplateElements = {
    'THEAD': true,
    'TBODY': true,
    'TFOOT': true,
    'TH': true,
    'TR': true,
    'TD': true,
    'COLGROUP': true,
    'COL': true,
    'CAPTION': true,
    'OPTION': true,
    'OPTGROUP': true
  };

  var hasTemplateElement = typeof HTMLTemplateElement !== 'undefined';
  if (hasTemplateElement) {
    // TODO(rafaelw): Remove when fix for
    // https://codereview.chromium.org/164803002/
    // makes it to Chrome release.
    (function() {
      var t = document.createElement('template');
      var d = t.content.ownerDocument;
      var html = d.appendChild(d.createElement('html'));
      var head = html.appendChild(d.createElement('head'));
      var base = d.createElement('base');
      base.href = document.baseURI;
      head.appendChild(base);
    })();
  }

  var allTemplatesSelectors = 'template, ' +
      Object.keys(semanticTemplateElements).map(function(tagName) {
        return tagName.toLowerCase() + '[template]';
      }).join(', ');

  function isSVGTemplate(el) {
    return el.tagName == 'template' &&
           el.namespaceURI == 'http://www.w3.org/2000/svg';
  }

  function isHTMLTemplate(el) {
    return el.tagName == 'TEMPLATE' &&
           el.namespaceURI == 'http://www.w3.org/1999/xhtml';
  }

  function isAttributeTemplate(el) {
    return Boolean(semanticTemplateElements[el.tagName] &&
                   el.hasAttribute('template'));
  }

  function isTemplate(el) {
    if (el.isTemplate_ === undefined)
      el.isTemplate_ = el.tagName == 'TEMPLATE' || isAttributeTemplate(el);

    return el.isTemplate_;
  }

  // FIXME: Observe templates being added/removed from documents
  // FIXME: Expose imperative API to decorate and observe templates in
  // "disconnected tress" (e.g. ShadowRoot)
  document.addEventListener('DOMContentLoaded', function(e) {
    bootstrapTemplatesRecursivelyFrom(document);
    // FIXME: Is this needed? Seems like it shouldn't be.
    Platform.performMicrotaskCheckpoint();
  }, false);

  function forAllTemplatesFrom(node, fn) {
    var subTemplates = node.querySelectorAll(allTemplatesSelectors);

    if (isTemplate(node))
      fn(node)
    forEach(subTemplates, fn);
  }

  function bootstrapTemplatesRecursivelyFrom(node) {
    function bootstrap(template) {
      if (!HTMLTemplateElement.decorate(template))
        bootstrapTemplatesRecursivelyFrom(template.content);
    }

    forAllTemplatesFrom(node, bootstrap);
  }

  if (!hasTemplateElement) {
    /**
     * This represents a <template> element.
     * @constructor
     * @extends {HTMLElement}
     */
    global.HTMLTemplateElement = function() {
      throw TypeError('Illegal constructor');
    };
  }

  var hasProto = '__proto__' in {};

  function mixin(to, from) {
    Object.getOwnPropertyNames(from).forEach(function(name) {
      Object.defineProperty(to, name,
                            Object.getOwnPropertyDescriptor(from, name));
    });
  }

  // http://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html#dfn-template-contents-owner
  function getOrCreateTemplateContentsOwner(template) {
    var doc = template.ownerDocument
    if (!doc.defaultView)
      return doc;
    var d = doc.templateContentsOwner_;
    if (!d) {
      // TODO(arv): This should either be a Document or HTMLDocument depending
      // on doc.
      d = doc.implementation.createHTMLDocument('');
      while (d.lastChild) {
        d.removeChild(d.lastChild);
      }
      doc.templateContentsOwner_ = d;
    }
    return d;
  }

  function getTemplateStagingDocument(template) {
    if (!template.stagingDocument_) {
      var owner = template.ownerDocument;
      if (!owner.stagingDocument_) {
        owner.stagingDocument_ = owner.implementation.createHTMLDocument('');
        owner.stagingDocument_.isStagingDocument = true;
        // TODO(rafaelw): Remove when fix for
        // https://codereview.chromium.org/164803002/
        // makes it to Chrome release.
        var base = owner.stagingDocument_.createElement('base');
        base.href = document.baseURI;
        owner.stagingDocument_.head.appendChild(base);

        owner.stagingDocument_.stagingDocument_ = owner.stagingDocument_;
      }

      template.stagingDocument_ = owner.stagingDocument_;
    }

    return template.stagingDocument_;
  }

  // For non-template browsers, the parser will disallow <template> in certain
  // locations, so we allow "attribute templates" which combine the template
  // element with the top-level container node of the content, e.g.
  //
  //   <tr template repeat="{{ foo }}"" class="bar"><td>Bar</td></tr>
  //
  // becomes
  //
  //   <template repeat="{{ foo }}">
  //   + #document-fragment
  //     + <tr class="bar">
  //       + <td>Bar</td>
  //
  function extractTemplateFromAttributeTemplate(el) {
    var template = el.ownerDocument.createElement('template');
    el.parentNode.insertBefore(template, el);

    var attribs = el.attributes;
    var count = attribs.length;
    while (count-- > 0) {
      var attrib = attribs[count];
      if (templateAttributeDirectives[attrib.name]) {
        if (attrib.name !== 'template')
          template.setAttribute(attrib.name, attrib.value);
        el.removeAttribute(attrib.name);
      }
    }

    return template;
  }

  function extractTemplateFromSVGTemplate(el) {
    var template = el.ownerDocument.createElement('template');
    el.parentNode.insertBefore(template, el);

    var attribs = el.attributes;
    var count = attribs.length;
    while (count-- > 0) {
      var attrib = attribs[count];
      template.setAttribute(attrib.name, attrib.value);
      el.removeAttribute(attrib.name);
    }

    el.parentNode.removeChild(el);
    return template;
  }

  function liftNonNativeTemplateChildrenIntoContent(template, el, useRoot) {
    var content = template.content;
    if (useRoot) {
      content.appendChild(el);
      return;
    }

    var child;
    while (child = el.firstChild) {
      content.appendChild(child);
    }
  }

  var templateObserver;
  if (typeof MutationObserver == 'function') {
    templateObserver = new MutationObserver(function(records) {
      for (var i = 0; i < records.length; i++) {
        records[i].target.refChanged_();
      }
    });
  }

  /**
   * Ensures proper API and content model for template elements.
   * @param {HTMLTemplateElement} opt_instanceRef The template element which
   *     |el| template element will return as the value of its ref(), and whose
   *     content will be used as source when createInstance() is invoked.
   */
  HTMLTemplateElement.decorate = function(el, opt_instanceRef) {
    if (el.templateIsDecorated_)
      return false;

    var templateElement = el;
    templateElement.templateIsDecorated_ = true;

    var isNativeHTMLTemplate = isHTMLTemplate(templateElement) &&
                               hasTemplateElement;
    var bootstrapContents = isNativeHTMLTemplate;
    var liftContents = !isNativeHTMLTemplate;
    var liftRoot = false;

    if (!isNativeHTMLTemplate) {
      if (isAttributeTemplate(templateElement)) {
        assert(!opt_instanceRef);
        templateElement = extractTemplateFromAttributeTemplate(el);
        templateElement.templateIsDecorated_ = true;
        isNativeHTMLTemplate = hasTemplateElement;
        liftRoot = true;
      } else if (isSVGTemplate(templateElement)) {
        templateElement = extractTemplateFromSVGTemplate(el);
        templateElement.templateIsDecorated_ = true;
        isNativeHTMLTemplate = hasTemplateElement;
      }
    }

    if (!isNativeHTMLTemplate) {
      fixTemplateElementPrototype(templateElement);
      var doc = getOrCreateTemplateContentsOwner(templateElement);
      templateElement.content_ = doc.createDocumentFragment();
    }

    if (opt_instanceRef) {
      // template is contained within an instance, its direct content must be
      // empty
      templateElement.instanceRef_ = opt_instanceRef;
    } else if (liftContents) {
      liftNonNativeTemplateChildrenIntoContent(templateElement,
                                               el,
                                               liftRoot);
    } else if (bootstrapContents) {
      bootstrapTemplatesRecursivelyFrom(templateElement.content);
    }

    return true;
  };

  // TODO(rafaelw): This used to decorate recursively all templates from a given
  // node. This happens by default on 'DOMContentLoaded', but may be needed
  // in subtrees not descendent from document (e.g. ShadowRoot).
  // Review whether this is the right public API.
  HTMLTemplateElement.bootstrap = bootstrapTemplatesRecursivelyFrom;

  var htmlElement = global.HTMLUnknownElement || HTMLElement;

  var contentDescriptor = {
    get: function() {
      return this.content_;
    },
    enumerable: true,
    configurable: true
  };

  if (!hasTemplateElement) {
    // Gecko is more picky with the prototype than WebKit. Make sure to use the
    // same prototype as created in the constructor.
    HTMLTemplateElement.prototype = Object.create(htmlElement.prototype);

    Object.defineProperty(HTMLTemplateElement.prototype, 'content',
                          contentDescriptor);
  }

  function fixTemplateElementPrototype(el) {
    if (hasProto)
      el.__proto__ = HTMLTemplateElement.prototype;
    else
      mixin(el, HTMLTemplateElement.prototype);
  }

  function ensureSetModelScheduled(template) {
    if (!template.setModelFn_) {
      template.setModelFn_ = function() {
        template.setModelFnScheduled_ = false;
        var map = getBindings(template,
            template.delegate_ && template.delegate_.prepareBinding);
        processBindings(template, map, template.model_);
      };
    }

    if (!template.setModelFnScheduled_) {
      template.setModelFnScheduled_ = true;
      Observer.runEOM_(template.setModelFn_);
    }
  }

  mixin(HTMLTemplateElement.prototype, {
    bind: function(name, value, oneTime) {
      if (name != 'ref')
        return Element.prototype.bind.call(this, name, value, oneTime);

      var self = this;
      var ref = oneTime ? value : value.open(function(ref) {
        self.setAttribute('ref', ref);
        self.refChanged_();
      });

      this.setAttribute('ref', ref);
      this.refChanged_();
      if (oneTime)
        return;

      if (!this.bindings_) {
        this.bindings_ = { ref: value };
      } else {
        this.bindings_.ref = value;
      }

      return value;
    },

    processBindingDirectives_: function(directives) {
      if (this.iterator_)
        this.iterator_.closeDeps();

      if (!directives.if && !directives.bind && !directives.repeat) {
        if (this.iterator_) {
          this.iterator_.close();
          this.iterator_ = undefined;
        }

        return;
      }

      if (!this.iterator_) {
        this.iterator_ = new TemplateIterator(this);
      }

      this.iterator_.updateDependencies(directives, this.model_);

      if (templateObserver) {
        templateObserver.observe(this, { attributes: true,
                                         attributeFilter: ['ref'] });
      }

      return this.iterator_;
    },

    createInstance: function(model, bindingDelegate, delegate_) {
      if (bindingDelegate)
        delegate_ = this.newDelegate_(bindingDelegate);
      else if (!delegate_)
        delegate_ = this.delegate_;

      if (!this.refContent_)
        this.refContent_ = this.ref_.content;
      var content = this.refContent_;
      if (content.firstChild === null)
        return emptyInstance;

      var map = getInstanceBindingMap(content, delegate_);
      var stagingDocument = getTemplateStagingDocument(this);
      var instance = stagingDocument.createDocumentFragment();
      instance.templateCreator_ = this;
      instance.protoContent_ = content;
      instance.bindings_ = [];
      instance.terminator_ = null;
      var instanceRecord = instance.templateInstance_ = {
        firstNode: null,
        lastNode: null,
        model: model
      };

      var i = 0;
      var collectTerminator = false;
      for (var child = content.firstChild; child; child = child.nextSibling) {
        // The terminator of the instance is the clone of the last child of the
        // content. If the last child is an active template, it may produce
        // instances as a result of production, so simply collecting the last
        // child of the instance after it has finished producing may be wrong.
        if (child.nextSibling === null)
          collectTerminator = true;

        var clone = cloneAndBindInstance(child, instance, stagingDocument,
                                         map.children[i++],
                                         model,
                                         delegate_,
                                         instance.bindings_);
        clone.templateInstance_ = instanceRecord;
        if (collectTerminator)
          instance.terminator_ = clone;
      }

      instanceRecord.firstNode = instance.firstChild;
      instanceRecord.lastNode = instance.lastChild;
      instance.templateCreator_ = undefined;
      instance.protoContent_ = undefined;
      return instance;
    },

    get model() {
      return this.model_;
    },

    set model(model) {
      this.model_ = model;
      ensureSetModelScheduled(this);
    },

    get bindingDelegate() {
      return this.delegate_ && this.delegate_.raw;
    },

    refChanged_: function() {
      if (!this.iterator_ || this.refContent_ === this.ref_.content)
        return;

      this.refContent_ = undefined;
      this.iterator_.valueChanged();
      this.iterator_.updateIteratedValue(this.iterator_.getUpdatedValue());
    },

    clear: function() {
      this.model_ = undefined;
      this.delegate_ = undefined;
      if (this.bindings_ && this.bindings_.ref)
        this.bindings_.ref.close()
      this.refContent_ = undefined;
      if (!this.iterator_)
        return;
      this.iterator_.valueChanged();
      this.iterator_.close()
      this.iterator_ = undefined;
    },

    setDelegate_: function(delegate) {
      this.delegate_ = delegate;
      this.bindingMap_ = undefined;
      if (this.iterator_) {
        this.iterator_.instancePositionChangedFn_ = undefined;
        this.iterator_.instanceModelFn_ = undefined;
      }
    },

    newDelegate_: function(bindingDelegate) {
      if (!bindingDelegate)
        return;

      function delegateFn(name) {
        var fn = bindingDelegate && bindingDelegate[name];
        if (typeof fn != 'function')
          return;

        return function() {
          return fn.apply(bindingDelegate, arguments);
        };
      }

      return {
        bindingMaps: {},
        raw: bindingDelegate,
        prepareBinding: delegateFn('prepareBinding'),
        prepareInstanceModel: delegateFn('prepareInstanceModel'),
        prepareInstancePositionChanged:
            delegateFn('prepareInstancePositionChanged')
      };
    },

    set bindingDelegate(bindingDelegate) {
      if (this.delegate_) {
        throw Error('Template must be cleared before a new bindingDelegate ' +
                    'can be assigned');
      }

      this.setDelegate_(this.newDelegate_(bindingDelegate));
    },

    get ref_() {
      var ref = searchRefId(this, this.getAttribute('ref'));
      if (!ref)
        ref = this.instanceRef_;

      if (!ref)
        return this;

      var nextRef = ref.ref_;
      return nextRef ? nextRef : ref;
    }
  });

  // Returns
  //   a) undefined if there are no mustaches.
  //   b) [TEXT, (ONE_TIME?, PATH, DELEGATE_FN, TEXT)+] if there is at least one mustache.
  function parseMustaches(s, name, node, prepareBindingFn) {
    if (!s || !s.length)
      return;

    var tokens;
    var length = s.length;
    var startIndex = 0, lastIndex = 0, endIndex = 0;
    var onlyOneTime = true;
    while (lastIndex < length) {
      var startIndex = s.indexOf('{{', lastIndex);
      var oneTimeStart = s.indexOf('[[', lastIndex);
      var oneTime = false;
      var terminator = '}}';

      if (oneTimeStart >= 0 &&
          (startIndex < 0 || oneTimeStart < startIndex)) {
        startIndex = oneTimeStart;
        oneTime = true;
        terminator = ']]';
      }

      endIndex = startIndex < 0 ? -1 : s.indexOf(terminator, startIndex + 2);

      if (endIndex < 0) {
        if (!tokens)
          return;

        tokens.push(s.slice(lastIndex)); // TEXT
        break;
      }

      tokens = tokens || [];
      tokens.push(s.slice(lastIndex, startIndex)); // TEXT
      var pathString = s.slice(startIndex + 2, endIndex).trim();
      tokens.push(oneTime); // ONE_TIME?
      onlyOneTime = onlyOneTime && oneTime;
      var delegateFn = prepareBindingFn &&
                       prepareBindingFn(pathString, name, node);
      // Don't try to parse the expression if there's a prepareBinding function
      if (delegateFn == null) {
        tokens.push(Path.get(pathString)); // PATH
      } else {
        tokens.push(null);
      }
      tokens.push(delegateFn); // DELEGATE_FN
      lastIndex = endIndex + 2;
    }

    if (lastIndex === length)
      tokens.push(''); // TEXT

    tokens.hasOnePath = tokens.length === 5;
    tokens.isSimplePath = tokens.hasOnePath &&
                          tokens[0] == '' &&
                          tokens[4] == '';
    tokens.onlyOneTime = onlyOneTime;

    tokens.combinator = function(values) {
      var newValue = tokens[0];

      for (var i = 1; i < tokens.length; i += 4) {
        var value = tokens.hasOnePath ? values : values[(i - 1) / 4];
        if (value !== undefined)
          newValue += value;
        newValue += tokens[i + 3];
      }

      return newValue;
    }

    return tokens;
  };

  function processOneTimeBinding(name, tokens, node, model) {
    if (tokens.hasOnePath) {
      var delegateFn = tokens[3];
      var value = delegateFn ? delegateFn(model, node, true) :
                               tokens[2].getValueFrom(model);
      return tokens.isSimplePath ? value : tokens.combinator(value);
    }

    var values = [];
    for (var i = 1; i < tokens.length; i += 4) {
      var delegateFn = tokens[i + 2];
      values[(i - 1) / 4] = delegateFn ? delegateFn(model, node) :
          tokens[i + 1].getValueFrom(model);
    }

    return tokens.combinator(values);
  }

  function processSinglePathBinding(name, tokens, node, model) {
    var delegateFn = tokens[3];
    var observer = delegateFn ? delegateFn(model, node, false) :
        new PathObserver(model, tokens[2]);

    return tokens.isSimplePath ? observer :
        new ObserverTransform(observer, tokens.combinator);
  }

  function processBinding(name, tokens, node, model) {
    if (tokens.onlyOneTime)
      return processOneTimeBinding(name, tokens, node, model);

    if (tokens.hasOnePath)
      return processSinglePathBinding(name, tokens, node, model);

    var observer = new CompoundObserver();

    for (var i = 1; i < tokens.length; i += 4) {
      var oneTime = tokens[i];
      var delegateFn = tokens[i + 2];

      if (delegateFn) {
        var value = delegateFn(model, node, oneTime);
        if (oneTime)
          observer.addPath(value)
        else
          observer.addObserver(value);
        continue;
      }

      var path = tokens[i + 1];
      if (oneTime)
        observer.addPath(path.getValueFrom(model))
      else
        observer.addPath(model, path);
    }

    return new ObserverTransform(observer, tokens.combinator);
  }

  function processBindings(node, bindings, model, instanceBindings) {
    for (var i = 0; i < bindings.length; i += 2) {
      var name = bindings[i]
      var tokens = bindings[i + 1];
      var value = processBinding(name, tokens, node, model);
      var binding = node.bind(name, value, tokens.onlyOneTime);
      if (binding && instanceBindings)
        instanceBindings.push(binding);
    }

    node.bindFinished();
    if (!bindings.isTemplate)
      return;

    node.model_ = model;
    var iter = node.processBindingDirectives_(bindings);
    if (instanceBindings && iter)
      instanceBindings.push(iter);
  }

  function parseWithDefault(el, name, prepareBindingFn) {
    var v = el.getAttribute(name);
    return parseMustaches(v == '' ? '{{}}' : v, name, el, prepareBindingFn);
  }

  function parseAttributeBindings(element, prepareBindingFn) {
    assert(element);

    var bindings = [];
    var ifFound = false;
    var bindFound = false;

    for (var i = 0; i < element.attributes.length; i++) {
      var attr = element.attributes[i];
      var name = attr.name;
      var value = attr.value;

      // Allow bindings expressed in attributes to be prefixed with underbars.
      // We do this to allow correct semantics for browsers that don't implement
      // <template> where certain attributes might trigger side-effects -- and
      // for IE which sanitizes certain attributes, disallowing mustache
      // replacements in their text.
      while (name[0] === '_') {
        name = name.substring(1);
      }

      if (isTemplate(element) &&
          (name === IF || name === BIND || name === REPEAT)) {
        continue;
      }

      var tokens = parseMustaches(value, name, element,
                                  prepareBindingFn);
      if (!tokens)
        continue;

      bindings.push(name, tokens);
    }

    if (isTemplate(element)) {
      bindings.isTemplate = true;
      bindings.if = parseWithDefault(element, IF, prepareBindingFn);
      bindings.bind = parseWithDefault(element, BIND, prepareBindingFn);
      bindings.repeat = parseWithDefault(element, REPEAT, prepareBindingFn);

      if (bindings.if && !bindings.bind && !bindings.repeat)
        bindings.bind = parseMustaches('{{}}', BIND, element, prepareBindingFn);
    }

    return bindings;
  }

  function getBindings(node, prepareBindingFn) {
    if (node.nodeType === Node.ELEMENT_NODE)
      return parseAttributeBindings(node, prepareBindingFn);

    if (node.nodeType === Node.TEXT_NODE) {
      var tokens = parseMustaches(node.data, 'textContent', node,
                                  prepareBindingFn);
      if (tokens)
        return ['textContent', tokens];
    }

    return [];
  }

  function cloneAndBindInstance(node, parent, stagingDocument, bindings, model,
                                delegate,
                                instanceBindings,
                                instanceRecord) {
    var clone = parent.appendChild(stagingDocument.importNode(node, false));

    var i = 0;
    for (var child = node.firstChild; child; child = child.nextSibling) {
      cloneAndBindInstance(child, clone, stagingDocument,
                            bindings.children[i++],
                            model,
                            delegate,
                            instanceBindings);
    }

    if (bindings.isTemplate) {
      HTMLTemplateElement.decorate(clone, node);
      if (delegate)
        clone.setDelegate_(delegate);
    }

    processBindings(clone, bindings, model, instanceBindings);
    return clone;
  }

  function createInstanceBindingMap(node, prepareBindingFn) {
    var map = getBindings(node, prepareBindingFn);
    map.children = {};
    var index = 0;
    for (var child = node.firstChild; child; child = child.nextSibling) {
      map.children[index++] = createInstanceBindingMap(child, prepareBindingFn);
    }

    return map;
  }

  var contentUidCounter = 1;

  // TODO(rafaelw): Setup a MutationObserver on content which clears the id
  // so that bindingMaps regenerate when the template.content changes.
  function getContentUid(content) {
    var id = content.id_;
    if (!id)
      id = content.id_ = contentUidCounter++;
    return id;
  }

  // Each delegate is associated with a set of bindingMaps, one for each
  // content which may be used by a template. The intent is that each binding
  // delegate gets the opportunity to prepare the instance (via the prepare*
  // delegate calls) once across all uses.
  // TODO(rafaelw): Separate out the parse map from the binding map. In the
  // current implementation, if two delegates need a binding map for the same
  // content, the second will have to reparse.
  function getInstanceBindingMap(content, delegate_) {
    var contentId = getContentUid(content);
    if (delegate_) {
      var map = delegate_.bindingMaps[contentId];
      if (!map) {
        map = delegate_.bindingMaps[contentId] =
            createInstanceBindingMap(content, delegate_.prepareBinding) || [];
      }
      return map;
    }

    var map = content.bindingMap_;
    if (!map) {
      map = content.bindingMap_ =
          createInstanceBindingMap(content, undefined) || [];
    }
    return map;
  }

  Object.defineProperty(Node.prototype, 'templateInstance', {
    get: function() {
      var instance = this.templateInstance_;
      return instance ? instance :
          (this.parentNode ? this.parentNode.templateInstance : undefined);
    }
  });

  var emptyInstance = document.createDocumentFragment();
  emptyInstance.bindings_ = [];
  emptyInstance.terminator_ = null;

  function TemplateIterator(templateElement) {
    this.closed = false;
    this.templateElement_ = templateElement;
    this.instances = [];
    this.deps = undefined;
    this.iteratedValue = [];
    this.presentValue = undefined;
    this.arrayObserver = undefined;
  }

  TemplateIterator.prototype = {
    closeDeps: function() {
      var deps = this.deps;
      if (deps) {
        if (deps.ifOneTime === false)
          deps.ifValue.close();
        if (deps.oneTime === false)
          deps.value.close();
      }
    },

    updateDependencies: function(directives, model) {
      this.closeDeps();

      var deps = this.deps = {};
      var template = this.templateElement_;

      var ifValue = true;
      if (directives.if) {
        deps.hasIf = true;
        deps.ifOneTime = directives.if.onlyOneTime;
        deps.ifValue = processBinding(IF, directives.if, template, model);

        ifValue = deps.ifValue;

        // oneTime if & predicate is false. nothing else to do.
        if (deps.ifOneTime && !ifValue) {
          this.valueChanged();
          return;
        }

        if (!deps.ifOneTime)
          ifValue = ifValue.open(this.updateIfValue, this);
      }

      if (directives.repeat) {
        deps.repeat = true;
        deps.oneTime = directives.repeat.onlyOneTime;
        deps.value = processBinding(REPEAT, directives.repeat, template, model);
      } else {
        deps.repeat = false;
        deps.oneTime = directives.bind.onlyOneTime;
        deps.value = processBinding(BIND, directives.bind, template, model);
      }

      var value = deps.value;
      if (!deps.oneTime)
        value = value.open(this.updateIteratedValue, this);

      if (!ifValue) {
        this.valueChanged();
        return;
      }

      this.updateValue(value);
    },

    /**
     * Gets the updated value of the bind/repeat. This can potentially call
     * user code (if a bindingDelegate is set up) so we try to avoid it if we
     * already have the value in hand (from Observer.open).
     */
    getUpdatedValue: function() {
      var value = this.deps.value;
      if (!this.deps.oneTime)
        value = value.discardChanges();
      return value;
    },

    updateIfValue: function(ifValue) {
      if (!ifValue) {
        this.valueChanged();
        return;
      }

      this.updateValue(this.getUpdatedValue());
    },

    updateIteratedValue: function(value) {
      if (this.deps.hasIf) {
        var ifValue = this.deps.ifValue;
        if (!this.deps.ifOneTime)
          ifValue = ifValue.discardChanges();
        if (!ifValue) {
          this.valueChanged();
          return;
        }
      }

      this.updateValue(value);
    },

    updateValue: function(value) {
      if (!this.deps.repeat)
        value = [value];
      var observe = this.deps.repeat &&
                    !this.deps.oneTime &&
                    Array.isArray(value);
      this.valueChanged(value, observe);
    },

    valueChanged: function(value, observeValue) {
      if (!Array.isArray(value))
        value = [];

      if (value === this.iteratedValue)
        return;

      this.unobserve();
      this.presentValue = value;
      if (observeValue) {
        this.arrayObserver = new ArrayObserver(this.presentValue);
        this.arrayObserver.open(this.handleSplices, this);
      }

      this.handleSplices(ArrayObserver.calculateSplices(this.presentValue,
                                                        this.iteratedValue));
    },

    getLastInstanceNode: function(index) {
      if (index == -1)
        return this.templateElement_;
      var instance = this.instances[index];
      var terminator = instance.terminator_;
      if (!terminator)
        return this.getLastInstanceNode(index - 1);

      if (terminator.nodeType !== Node.ELEMENT_NODE ||
          this.templateElement_ === terminator) {
        return terminator;
      }

      var subtemplateIterator = terminator.iterator_;
      if (!subtemplateIterator)
        return terminator;

      return subtemplateIterator.getLastTemplateNode();
    },

    getLastTemplateNode: function() {
      return this.getLastInstanceNode(this.instances.length - 1);
    },

    insertInstanceAt: function(index, fragment) {
      var previousInstanceLast = this.getLastInstanceNode(index - 1);
      var parent = this.templateElement_.parentNode;
      this.instances.splice(index, 0, fragment);

      parent.insertBefore(fragment, previousInstanceLast.nextSibling);
    },

    extractInstanceAt: function(index) {
      var previousInstanceLast = this.getLastInstanceNode(index - 1);
      var lastNode = this.getLastInstanceNode(index);
      var parent = this.templateElement_.parentNode;
      var instance = this.instances.splice(index, 1)[0];

      while (lastNode !== previousInstanceLast) {
        var node = previousInstanceLast.nextSibling;
        if (node == lastNode)
          lastNode = previousInstanceLast;

        instance.appendChild(parent.removeChild(node));
      }

      return instance;
    },

    getDelegateFn: function(fn) {
      fn = fn && fn(this.templateElement_);
      return typeof fn === 'function' ? fn : null;
    },

    handleSplices: function(splices) {
      if (this.closed || !splices.length)
        return;

      var template = this.templateElement_;

      if (!template.parentNode) {
        this.close();
        return;
      }

      ArrayObserver.applySplices(this.iteratedValue, this.presentValue,
                                 splices);

      var delegate = template.delegate_;
      if (this.instanceModelFn_ === undefined) {
        this.instanceModelFn_ =
            this.getDelegateFn(delegate && delegate.prepareInstanceModel);
      }

      if (this.instancePositionChangedFn_ === undefined) {
        this.instancePositionChangedFn_ =
            this.getDelegateFn(delegate &&
                               delegate.prepareInstancePositionChanged);
      }

      // Instance Removals
      var instanceCache = new Map;
      var removeDelta = 0;
      for (var i = 0; i < splices.length; i++) {
        var splice = splices[i];
        var removed = splice.removed;
        for (var j = 0; j < removed.length; j++) {
          var model = removed[j];
          var instance = this.extractInstanceAt(splice.index + removeDelta);
          if (instance !== emptyInstance) {
            instanceCache.set(model, instance);
          }
        }

        removeDelta -= splice.addedCount;
      }

      // Instance Insertions
      for (var i = 0; i < splices.length; i++) {
        var splice = splices[i];
        var addIndex = splice.index;
        for (; addIndex < splice.index + splice.addedCount; addIndex++) {
          var model = this.iteratedValue[addIndex];
          var instance = instanceCache.get(model);
          if (instance) {
            instanceCache.delete(model);
          } else {
            if (this.instanceModelFn_) {
              model = this.instanceModelFn_(model);
            }

            if (model === undefined) {
              instance = emptyInstance;
            } else {
              instance = template.createInstance(model, undefined, delegate);
            }
          }

          this.insertInstanceAt(addIndex, instance);
        }
      }

      instanceCache.forEach(function(instance) {
        this.closeInstanceBindings(instance);
      }, this);

      if (this.instancePositionChangedFn_)
        this.reportInstancesMoved(splices);
    },

    reportInstanceMoved: function(index) {
      var instance = this.instances[index];
      if (instance === emptyInstance)
        return;

      this.instancePositionChangedFn_(instance.templateInstance_, index);
    },

    reportInstancesMoved: function(splices) {
      var index = 0;
      var offset = 0;
      for (var i = 0; i < splices.length; i++) {
        var splice = splices[i];
        if (offset != 0) {
          while (index < splice.index) {
            this.reportInstanceMoved(index);
            index++;
          }
        } else {
          index = splice.index;
        }

        while (index < splice.index + splice.addedCount) {
          this.reportInstanceMoved(index);
          index++;
        }

        offset += splice.addedCount - splice.removed.length;
      }

      if (offset == 0)
        return;

      var length = this.instances.length;
      while (index < length) {
        this.reportInstanceMoved(index);
        index++;
      }
    },

    closeInstanceBindings: function(instance) {
      var bindings = instance.bindings_;
      for (var i = 0; i < bindings.length; i++) {
        bindings[i].close();
      }
    },

    unobserve: function() {
      if (!this.arrayObserver)
        return;

      this.arrayObserver.close();
      this.arrayObserver = undefined;
    },

    close: function() {
      if (this.closed)
        return;
      this.unobserve();
      for (var i = 0; i < this.instances.length; i++) {
        this.closeInstanceBindings(this.instances[i]);
      }

      this.instances.length = 0;
      this.closeDeps();
      this.templateElement_.iterator_ = undefined;
      this.closed = true;
    }
  };

  // Polyfill-specific API.
  HTMLTemplateElement.forAllTemplatesFrom_ = forAllTemplatesFrom;
})(this);

(function(scope) {
  'use strict';

  // feature detect for URL constructor
  var hasWorkingUrl = false;
  if (!scope.forceJURL) {
    try {
      var u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      hasWorkingUrl = u.href === 'http://a/c%20d';
    } catch(e) {}
  }

  if (hasWorkingUrl)
    return;

  var relative = Object.create(null);
  relative['ftp'] = 21;
  relative['file'] = 0;
  relative['gopher'] = 70;
  relative['http'] = 80;
  relative['https'] = 443;
  relative['ws'] = 80;
  relative['wss'] = 443;

  var relativePathDotMapping = Object.create(null);
  relativePathDotMapping['%2e'] = '.';
  relativePathDotMapping['.%2e'] = '..';
  relativePathDotMapping['%2e.'] = '..';
  relativePathDotMapping['%2e%2e'] = '..';

  function isRelativeScheme(scheme) {
    return relative[scheme] !== undefined;
  }

  function invalid() {
    clear.call(this);
    this._isInvalid = true;
  }

  function IDNAToASCII(h) {
    if ('' == h) {
      invalid.call(this)
    }
    // XXX
    return h.toLowerCase()
  }

  function percentEscape(c) {
    var unicode = c.charCodeAt(0);
    if (unicode > 0x20 &&
       unicode < 0x7F &&
       // " # < > ? `
       [0x22, 0x23, 0x3C, 0x3E, 0x3F, 0x60].indexOf(unicode) == -1
      ) {
      return c;
    }
    return encodeURIComponent(c);
  }

  function percentEscapeQuery(c) {
    // XXX This actually needs to encode c using encoding and then
    // convert the bytes one-by-one.

    var unicode = c.charCodeAt(0);
    if (unicode > 0x20 &&
       unicode < 0x7F &&
       // " # < > ` (do not escape '?')
       [0x22, 0x23, 0x3C, 0x3E, 0x60].indexOf(unicode) == -1
      ) {
      return c;
    }
    return encodeURIComponent(c);
  }

  var EOF = undefined,
      ALPHA = /[a-zA-Z]/,
      ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;

  function parse(input, stateOverride, base) {
    function err(message) {
      errors.push(message)
    }

    var state = stateOverride || 'scheme start',
        cursor = 0,
        buffer = '',
        seenAt = false,
        seenBracket = false,
        errors = [];

    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {
      var c = input[cursor];
      switch (state) {
        case 'scheme start':
          if (c && ALPHA.test(c)) {
            buffer += c.toLowerCase(); // ASCII-safe
            state = 'scheme';
          } else if (!stateOverride) {
            buffer = '';
            state = 'no scheme';
            continue;
          } else {
            err('Invalid scheme.');
            break loop;
          }
          break;

        case 'scheme':
          if (c && ALPHANUMERIC.test(c)) {
            buffer += c.toLowerCase(); // ASCII-safe
          } else if (':' == c) {
            this._scheme = buffer;
            buffer = '';
            if (stateOverride) {
              break loop;
            }
            if (isRelativeScheme(this._scheme)) {
              this._isRelative = true;
            }
            if ('file' == this._scheme) {
              state = 'relative';
            } else if (this._isRelative && base && base._scheme == this._scheme) {
              state = 'relative or authority';
            } else if (this._isRelative) {
              state = 'authority first slash';
            } else {
              state = 'scheme data';
            }
          } else if (!stateOverride) {
            buffer = '';
            cursor = 0;
            state = 'no scheme';
            continue;
          } else if (EOF == c) {
            break loop;
          } else {
            err('Code point not allowed in scheme: ' + c)
            break loop;
          }
          break;

        case 'scheme data':
          if ('?' == c) {
            query = '?';
            state = 'query';
          } else if ('#' == c) {
            this._fragment = '#';
            state = 'fragment';
          } else {
            // XXX error handling
            if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
              this._schemeData += percentEscape(c);
            }
          }
          break;

        case 'no scheme':
          if (!base || !(isRelativeScheme(base._scheme))) {
            err('Missing scheme.');
            invalid.call(this);
          } else {
            state = 'relative';
            continue;
          }
          break;

        case 'relative or authority':
          if ('/' == c && '/' == input[cursor+1]) {
            state = 'authority ignore slashes';
          } else {
            err('Expected /, got: ' + c);
            state = 'relative';
            continue
          }
          break;

        case 'relative':
          this._isRelative = true;
          if ('file' != this._scheme)
            this._scheme = base._scheme;
          if (EOF == c) {
            this._host = base._host;
            this._port = base._port;
            this._path = base._path.slice();
            this._query = base._query;
            break loop;
          } else if ('/' == c || '\\' == c) {
            if ('\\' == c)
              err('\\ is an invalid code point.');
            state = 'relative slash';
          } else if ('?' == c) {
            this._host = base._host;
            this._port = base._port;
            this._path = base._path.slice();
            this._query = '?';
            state = 'query';
          } else if ('#' == c) {
            this._host = base._host;
            this._port = base._port;
            this._path = base._path.slice();
            this._query = base._query;
            this._fragment = '#';
            state = 'fragment';
          } else {
            var nextC = input[cursor+1]
            var nextNextC = input[cursor+2]
            if (
              'file' != this._scheme || !ALPHA.test(c) ||
              (nextC != ':' && nextC != '|') ||
              (EOF != nextNextC && '/' != nextNextC && '\\' != nextNextC && '?' != nextNextC && '#' != nextNextC)) {
              this._host = base._host;
              this._port = base._port;
              this._path = base._path.slice();
              this._path.pop();
            }
            state = 'relative path';
            continue;
          }
          break;

        case 'relative slash':
          if ('/' == c || '\\' == c) {
            if ('\\' == c) {
              err('\\ is an invalid code point.');
            }
            if ('file' == this._scheme) {
              state = 'file host';
            } else {
              state = 'authority ignore slashes';
            }
          } else {
            if ('file' != this._scheme) {
              this._host = base._host;
              this._port = base._port;
            }
            state = 'relative path';
            continue;
          }
          break;

        case 'authority first slash':
          if ('/' == c) {
            state = 'authority second slash';
          } else {
            err("Expected '/', got: " + c);
            state = 'authority ignore slashes';
            continue;
          }
          break;

        case 'authority second slash':
          state = 'authority ignore slashes';
          if ('/' != c) {
            err("Expected '/', got: " + c);
            continue;
          }
          break;

        case 'authority ignore slashes':
          if ('/' != c && '\\' != c) {
            state = 'authority';
            continue;
          } else {
            err('Expected authority, got: ' + c);
          }
          break;

        case 'authority':
          if ('@' == c) {
            if (seenAt) {
              err('@ already seen.');
              buffer += '%40';
            }
            seenAt = true;
            for (var i = 0; i < buffer.length; i++) {
              var cp = buffer[i];
              if ('\t' == cp || '\n' == cp || '\r' == cp) {
                err('Invalid whitespace in authority.');
                continue;
              }
              // XXX check URL code points
              if (':' == cp && null === this._password) {
                this._password = '';
                continue;
              }
              var tempC = percentEscape(cp);
              (null !== this._password) ? this._password += tempC : this._username += tempC;
            }
            buffer = '';
          } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
            cursor -= buffer.length;
            buffer = '';
            state = 'host';
            continue;
          } else {
            buffer += c;
          }
          break;

        case 'file host':
          if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
            if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == ':' || buffer[1] == '|')) {
              state = 'relative path';
            } else if (buffer.length == 0) {
              state = 'relative path start';
            } else {
              this._host = IDNAToASCII.call(this, buffer);
              buffer = '';
              state = 'relative path start';
            }
            continue;
          } else if ('\t' == c || '\n' == c || '\r' == c) {
            err('Invalid whitespace in file host.');
          } else {
            buffer += c;
          }
          break;

        case 'host':
        case 'hostname':
          if (':' == c && !seenBracket) {
            // XXX host parsing
            this._host = IDNAToASCII.call(this, buffer);
            buffer = '';
            state = 'port';
            if ('hostname' == stateOverride) {
              break loop;
            }
          } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c) {
            this._host = IDNAToASCII.call(this, buffer);
            buffer = '';
            state = 'relative path start';
            if (stateOverride) {
              break loop;
            }
            continue;
          } else if ('\t' != c && '\n' != c && '\r' != c) {
            if ('[' == c) {
              seenBracket = true;
            } else if (']' == c) {
              seenBracket = false;
            }
            buffer += c;
          } else {
            err('Invalid code point in host/hostname: ' + c);
          }
          break;

        case 'port':
          if (/[0-9]/.test(c)) {
            buffer += c;
          } else if (EOF == c || '/' == c || '\\' == c || '?' == c || '#' == c || stateOverride) {
            if ('' != buffer) {
              var temp = parseInt(buffer, 10);
              if (temp != relative[this._scheme]) {
                this._port = temp + '';
              }
              buffer = '';
            }
            if (stateOverride) {
              break loop;
            }
            state = 'relative path start';
            continue;
          } else if ('\t' == c || '\n' == c || '\r' == c) {
            err('Invalid code point in port: ' + c);
          } else {
            invalid.call(this);
          }
          break;

        case 'relative path start':
          if ('\\' == c)
            err("'\\' not allowed in path.");
          state = 'relative path';
          if ('/' != c && '\\' != c) {
            continue;
          }
          break;

        case 'relative path':
          if (EOF == c || '/' == c || '\\' == c || (!stateOverride && ('?' == c || '#' == c))) {
            if ('\\' == c) {
              err('\\ not allowed in relative path.');
            }
            var tmp;
            if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
              buffer = tmp;
            }
            if ('..' == buffer) {
              this._path.pop();
              if ('/' != c && '\\' != c) {
                this._path.push('');
              }
            } else if ('.' == buffer && '/' != c && '\\' != c) {
              this._path.push('');
            } else if ('.' != buffer) {
              if ('file' == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == '|') {
                buffer = buffer[0] + ':';
              }
              this._path.push(buffer);
            }
            buffer = '';
            if ('?' == c) {
              this._query = '?';
              state = 'query';
            } else if ('#' == c) {
              this._fragment = '#';
              state = 'fragment';
            }
          } else if ('\t' != c && '\n' != c && '\r' != c) {
            buffer += percentEscape(c);
          }
          break;

        case 'query':
          if (!stateOverride && '#' == c) {
            this._fragment = '#';
            state = 'fragment';
          } else if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
            this._query += percentEscapeQuery(c);
          }
          break;

        case 'fragment':
          if (EOF != c && '\t' != c && '\n' != c && '\r' != c) {
            this._fragment += c;
          }
          break;
      }

      cursor++;
    }
  }

  function clear() {
    this._scheme = '';
    this._schemeData = '';
    this._username = '';
    this._password = null;
    this._host = '';
    this._port = '';
    this._path = [];
    this._query = '';
    this._fragment = '';
    this._isInvalid = false;
    this._isRelative = false;
  }

  // Does not process domain names or IP addresses.
  // Does not handle encoding for the query parameter.
  function jURL(url, base /* , encoding */) {
    if (base !== undefined && !(base instanceof jURL))
      base = new jURL(String(base));

    this._url = url;
    clear.call(this);

    var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, '');
    // encoding = encoding || 'utf-8'

    parse.call(this, input, null, base);
  }

  jURL.prototype = {
    get href() {
      if (this._isInvalid)
        return this._url;

      var authority = '';
      if ('' != this._username || null != this._password) {
        authority = this._username +
            (null != this._password ? ':' + this._password : '') + '@';
      }

      return this.protocol +
          (this._isRelative ? '//' + authority + this.host : '') +
          this.pathname + this._query + this._fragment;
    },
    set href(href) {
      clear.call(this);
      parse.call(this, href);
    },

    get protocol() {
      return this._scheme + ':';
    },
    set protocol(protocol) {
      if (this._isInvalid)
        return;
      parse.call(this, protocol + ':', 'scheme start');
    },

    get host() {
      return this._isInvalid ? '' : this._port ?
          this._host + ':' + this._port : this._host;
    },
    set host(host) {
      if (this._isInvalid || !this._isRelative)
        return;
      parse.call(this, host, 'host');
    },

    get hostname() {
      return this._host;
    },
    set hostname(hostname) {
      if (this._isInvalid || !this._isRelative)
        return;
      parse.call(this, hostname, 'hostname');
    },

    get port() {
      return this._port;
    },
    set port(port) {
      if (this._isInvalid || !this._isRelative)
        return;
      parse.call(this, port, 'port');
    },

    get pathname() {
      return this._isInvalid ? '' : this._isRelative ?
          '/' + this._path.join('/') : this._schemeData;
    },
    set pathname(pathname) {
      if (this._isInvalid || !this._isRelative)
        return;
      this._path = [];
      parse.call(this, pathname, 'relative path start');
    },

    get search() {
      return this._isInvalid || !this._query || '?' == this._query ?
          '' : this._query;
    },
    set search(search) {
      if (this._isInvalid || !this._isRelative)
        return;
      this._query = '?';
      if ('?' == search[0])
        search = search.slice(1);
      parse.call(this, search, 'query');
    },

    get hash() {
      return this._isInvalid || !this._fragment || '#' == this._fragment ?
          '' : this._fragment;
    },
    set hash(hash) {
      if (this._isInvalid)
        return;
      this._fragment = '#';
      if ('#' == hash[0])
        hash = hash.slice(1);
      parse.call(this, hash, 'fragment');
    },

    get origin() {
      var host;
      if (this._isInvalid || !this._scheme) {
        return '';
      }
      // javascript: Gecko returns String(""), WebKit/Blink String("null")
      // Gecko throws error for "data://"
      // data: Gecko returns "", Blink returns "data://", WebKit returns "null"
      // Gecko returns String("") for file: mailto:
      // WebKit/Blink returns String("SCHEME://") for file: mailto:
      switch (this._scheme) {
        case 'data':
        case 'file':
        case 'javascript':
        case 'mailto':
          return 'null';
      }
      host = this.host;
      if (!host) {
        return '';
      }
      return this._scheme + '://' + host;
    }
  };

  // Copy over the static methods
  var OriginalURL = scope.URL;
  if (OriginalURL) {
    jURL.createObjectURL = function(blob) {
      // IE extension allows a second optional options argument.
      // http://msdn.microsoft.com/en-us/library/ie/hh772302(v=vs.85).aspx
      return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
    };
    jURL.revokeObjectURL = function(url) {
      OriginalURL.revokeObjectURL(url);
    };
  }

  scope.URL = jURL;

})(this);

(function(scope) {

var iterations = 0;
var callbacks = [];
var twiddle = document.createTextNode('');

function endOfMicrotask(callback) {
  twiddle.textContent = iterations++;
  callbacks.push(callback);
}

function atEndOfMicrotask() {
  while (callbacks.length) {
    callbacks.shift()();
  }
}

new (window.MutationObserver || JsMutationObserver)(atEndOfMicrotask)
  .observe(twiddle, {characterData: true})
  ;

// exports
scope.endOfMicrotask = endOfMicrotask;
// bc
Platform.endOfMicrotask = endOfMicrotask;

})(Polymer);


(function(scope) {

/**
 * @class Polymer
 */

// imports
var endOfMicrotask = scope.endOfMicrotask;

// logging
var log = window.WebComponents ? WebComponents.flags.log : {};

// inject style sheet
var style = document.createElement('style');
style.textContent = 'template {display: none !important;} /* injected by platform.js */';
var head = document.querySelector('head');
head.insertBefore(style, head.firstChild);


/**
 * Force any pending data changes to be observed before
 * the next task. Data changes are processed asynchronously but are guaranteed
 * to be processed, for example, before painting. This method should rarely be
 * needed. It does nothing when Object.observe is available;
 * when Object.observe is not available, Polymer automatically flushes data
 * changes approximately every 1/10 second.
 * Therefore, `flush` should only be used when a data mutation should be
 * observed sooner than this.
 *
 * @method flush
 */
// flush (with logging)
var flushing;
function flush() {
  if (!flushing) {
    flushing = true;
    endOfMicrotask(function() {
      flushing = false;
      log.data && console.group('flush');
      Platform.performMicrotaskCheckpoint();
      log.data && console.groupEnd();
    });
  }
};

// polling dirty checker
// flush periodically if platform does not have object observe.
if (!Observer.hasObjectObserve) {
  var FLUSH_POLL_INTERVAL = 125;
  window.addEventListener('WebComponentsReady', function() {
    flush();
    // watch document visiblity to toggle dirty-checking
    var visibilityHandler = function() {
      // only flush if the page is visibile
      if (document.visibilityState === 'hidden') {
        if (scope.flushPoll) {
          clearInterval(scope.flushPoll);
        }
      } else {
        scope.flushPoll = setInterval(flush, FLUSH_POLL_INTERVAL);
      }
    };
    if (typeof document.visibilityState === 'string') {
      document.addEventListener('visibilitychange', visibilityHandler);
    }
    visibilityHandler();
  });
} else {
  // make flush a no-op when we have Object.observe
  flush = function() {};
}

if (window.CustomElements && !CustomElements.useNative) {
  var originalImportNode = Document.prototype.importNode;
  Document.prototype.importNode = function(node, deep) {
    var imported = originalImportNode.call(this, node, deep);
    CustomElements.upgradeAll(imported);
    return imported;
  };
}

// exports
scope.flush = flush;
// bc
Platform.flush = flush;

})(window.Polymer);


(function(scope) {

var urlResolver = {
  resolveDom: function(root, url) {
    url = url || baseUrl(root);
    this.resolveAttributes(root, url);
    this.resolveStyles(root, url);
    // handle template.content
    var templates = root.querySelectorAll('template');
    if (templates) {
      for (var i = 0, l = templates.length, t; (i < l) && (t = templates[i]); i++) {
        if (t.content) {
          this.resolveDom(t.content, url);
        }
      }
    }
  },
  resolveTemplate: function(template) {
    this.resolveDom(template.content, baseUrl(template));
  },
  resolveStyles: function(root, url) {
    var styles = root.querySelectorAll('style');
    if (styles) {
      for (var i = 0, l = styles.length, s; (i < l) && (s = styles[i]); i++) {
        this.resolveStyle(s, url);
      }
    }
  },
  resolveStyle: function(style, url) {
    url = url || baseUrl(style);
    style.textContent = this.resolveCssText(style.textContent, url);
  },
  resolveCssText: function(cssText, baseUrl, keepAbsolute) {
    cssText = replaceUrlsInCssText(cssText, baseUrl, keepAbsolute, CSS_URL_REGEXP);
    return replaceUrlsInCssText(cssText, baseUrl, keepAbsolute, CSS_IMPORT_REGEXP);
  },
  resolveAttributes: function(root, url) {
    if (root.hasAttributes && root.hasAttributes()) {
      this.resolveElementAttributes(root, url);
    }
    // search for attributes that host urls
    var nodes = root && root.querySelectorAll(URL_ATTRS_SELECTOR);
    if (nodes) {
      for (var i = 0, l = nodes.length, n; (i < l) && (n = nodes[i]); i++) {
        this.resolveElementAttributes(n, url);
      }
    }
  },
  resolveElementAttributes: function(node, url) {
    url = url || baseUrl(node);
    URL_ATTRS.forEach(function(v) {
      var attr = node.attributes[v];
      var value = attr && attr.value;
      var replacement;
      if (value && value.search(URL_TEMPLATE_SEARCH) < 0) {
        if (v === 'style') {
          replacement = replaceUrlsInCssText(value, url, false, CSS_URL_REGEXP);
        } else {
          replacement = resolveRelativeUrl(url, value);
        }
        attr.value = replacement;
      }
    });
  }
};

var CSS_URL_REGEXP = /(url\()([^)]*)(\))/g;
var CSS_IMPORT_REGEXP = /(@import[\s]+(?!url\())([^;]*)(;)/g;
var URL_ATTRS = ['href', 'src', 'action', 'style', 'url'];
var URL_ATTRS_SELECTOR = '[' + URL_ATTRS.join('],[') + ']';
var URL_TEMPLATE_SEARCH = '{{.*}}';
var URL_HASH = '#';

function baseUrl(node) {
  var u = new URL(node.ownerDocument.baseURI);
  u.search = '';
  u.hash = '';
  return u;
}

function replaceUrlsInCssText(cssText, baseUrl, keepAbsolute, regexp) {
  return cssText.replace(regexp, function(m, pre, url, post) {
    var urlPath = url.replace(/["']/g, '');
    urlPath = resolveRelativeUrl(baseUrl, urlPath, keepAbsolute);
    return pre + '\'' + urlPath + '\'' + post;
  });
}

function resolveRelativeUrl(baseUrl, url, keepAbsolute) {
  // do not resolve '/' absolute urls
  if (url && url[0] === '/') {
    return url;
  }
  // do not resolve '#' links, they are used for routing
  if (url && url[0] === '#') {
    return url;
  }
  var u = new URL(url, baseUrl);
  return keepAbsolute ? u.href : makeDocumentRelPath(u.href);
}

function makeDocumentRelPath(url) {
  var root = baseUrl(document.documentElement);
  var u = new URL(url, root);
  if (u.host === root.host && u.port === root.port &&
      u.protocol === root.protocol) {
    return makeRelPath(root, u);
  } else {
    return url;
  }
}

// make a relative path from source to target
function makeRelPath(sourceUrl, targetUrl) {
  var source = sourceUrl.pathname;
  var target = targetUrl.pathname;
  var s = source.split('/');
  var t = target.split('/');
  while (s.length && s[0] === t[0]){
    s.shift();
    t.shift();
  }
  for (var i = 0, l = s.length - 1; i < l; i++) {
    t.unshift('..');
  }
  // empty '#' is discarded but we need to preserve it.
  var hash = (targetUrl.href.slice(-1) === URL_HASH) ? URL_HASH : targetUrl.hash;
  return t.join('/') + targetUrl.search + hash;
}

// exports
scope.urlResolver = urlResolver;

})(Polymer);

(function(scope) {
  var endOfMicrotask = Polymer.endOfMicrotask;

  // Generic url loader
  function Loader(regex) {
    this.cache = Object.create(null);
    this.map = Object.create(null);
    this.requests = 0;
    this.regex = regex;
  }
  Loader.prototype = {

    // TODO(dfreedm): there may be a better factoring here
    // extract absolute urls from the text (full of relative urls)
    extractUrls: function(text, base) {
      var matches = [];
      var matched, u;
      while ((matched = this.regex.exec(text))) {
        u = new URL(matched[1], base);
        matches.push({matched: matched[0], url: u.href});
      }
      return matches;
    },
    // take a text blob, a root url, and a callback and load all the urls found within the text
    // returns a map of absolute url to text
    process: function(text, root, callback) {
      var matches = this.extractUrls(text, root);

      // every call to process returns all the text this loader has ever received
      var done = callback.bind(null, this.map);
      this.fetch(matches, done);
    },
    // build a mapping of url -> text from matches
    fetch: function(matches, callback) {
      var inflight = matches.length;

      // return early if there is no fetching to be done
      if (!inflight) {
        return callback();
      }

      // wait for all subrequests to return
      var done = function() {
        if (--inflight === 0) {
          callback();
        }
      };

      // start fetching all subrequests
      var m, req, url;
      for (var i = 0; i < inflight; i++) {
        m = matches[i];
        url = m.url;
        req = this.cache[url];
        // if this url has already been requested, skip requesting it again
        if (!req) {
          req = this.xhr(url);
          req.match = m;
          this.cache[url] = req;
        }
        // wait for the request to process its subrequests
        req.wait(done);
      }
    },
    handleXhr: function(request) {
      var match = request.match;
      var url = match.url;

      // handle errors with an empty string
      var response = request.response || request.responseText || '';
      this.map[url] = response;
      this.fetch(this.extractUrls(response, url), request.resolve);
    },
    xhr: function(url) {
      this.requests++;
      var request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.send();
      request.onerror = request.onload = this.handleXhr.bind(this, request);

      // queue of tasks to run after XHR returns
      request.pending = [];
      request.resolve = function() {
        var pending = request.pending;
        for(var i = 0; i < pending.length; i++) {
          pending[i]();
        }
        request.pending = null;
      };

      // if we have already resolved, pending is null, async call the callback
      request.wait = function(fn) {
        if (request.pending) {
          request.pending.push(fn);
        } else {
          endOfMicrotask(fn);
        }
      };

      return request;
    }
  };

  scope.Loader = Loader;
})(Polymer);

(function(scope) {

var urlResolver = scope.urlResolver;
var Loader = scope.Loader;

function StyleResolver() {
  this.loader = new Loader(this.regex);
}
StyleResolver.prototype = {
  regex: /@import\s+(?:url)?["'\(]*([^'"\)]*)['"\)]*;/g,
  // Recursively replace @imports with the text at that url
  resolve: function(text, url, callback) {
    var done = function(map) {
      callback(this.flatten(text, url, map));
    }.bind(this);
    this.loader.process(text, url, done);
  },
  // resolve the textContent of a style node
  resolveNode: function(style, url, callback) {
    var text = style.textContent;
    var done = function(text) {
      style.textContent = text;
      callback(style);
    };
    this.resolve(text, url, done);
  },
  // flatten all the @imports to text
  flatten: function(text, base, map) {
    var matches = this.loader.extractUrls(text, base);
    var match, url, intermediate;
    for (var i = 0; i < matches.length; i++) {
      match = matches[i];
      url = match.url;
      // resolve any css text to be relative to the importer, keep absolute url
      intermediate = urlResolver.resolveCssText(map[url], url, true);
      // flatten intermediate @imports
      intermediate = this.flatten(intermediate, base, map);
      text = text.replace(match.matched, intermediate);
    }
    return text;
  },
  loadStyles: function(styles, base, callback) {
    var loaded=0, l = styles.length;
    // called in the context of the style
    function loadedStyle(style) {
      loaded++;
      if (loaded === l && callback) {
        callback();
      }
    }
    for (var i=0, s; (i<l) && (s=styles[i]); i++) {
      this.resolveNode(s, base, loadedStyle);
    }
  }
};

var styleResolver = new StyleResolver();

// exports
scope.styleResolver = styleResolver;

})(Polymer);

(function(scope) {

  // copy own properties from 'api' to 'prototype, with name hinting for 'super'
  function extend(prototype, api) {
    if (prototype && api) {
      // use only own properties of 'api'
      Object.getOwnPropertyNames(api).forEach(function(n) {
        // acquire property descriptor
        var pd = Object.getOwnPropertyDescriptor(api, n);
        if (pd) {
          // clone property via descriptor
          Object.defineProperty(prototype, n, pd);
          // cache name-of-method for 'super' engine
          if (typeof pd.value == 'function') {
            // hint the 'super' engine
            pd.value.nom = n;
          }
        }
      });
    }
    return prototype;
  }


  // mixin

  // copy all properties from inProps (et al) to inObj
  function mixin(inObj/*, inProps, inMoreProps, ...*/) {
    var obj = inObj || {};
    for (var i = 1; i < arguments.length; i++) {
      var p = arguments[i];
      try {
        for (var n in p) {
          copyProperty(n, p, obj);
        }
      } catch(x) {
      }
    }
    return obj;
  }

  // copy property inName from inSource object to inTarget object
  function copyProperty(inName, inSource, inTarget) {
    var pd = getPropertyDescriptor(inSource, inName);
    Object.defineProperty(inTarget, inName, pd);
  }

  // get property descriptor for inName on inObject, even if
  // inName exists on some link in inObject's prototype chain
  function getPropertyDescriptor(inObject, inName) {
    if (inObject) {
      var pd = Object.getOwnPropertyDescriptor(inObject, inName);
      return pd || getPropertyDescriptor(Object.getPrototypeOf(inObject), inName);
    }
  }

  // exports

  scope.extend = extend;
  scope.mixin = mixin;

  // for bc
  Platform.mixin = mixin;

})(Polymer);

(function(scope) {

  // usage

  // invoke cb.call(this) in 100ms, unless the job is re-registered,
  // which resets the timer
  //
  // this.myJob = this.job(this.myJob, cb, 100)
  //
  // returns a job handle which can be used to re-register a job

  var Job = function(inContext) {
    this.context = inContext;
    this.boundComplete = this.complete.bind(this)
  };
  Job.prototype = {
    go: function(callback, wait) {
      this.callback = callback;
      var h;
      if (!wait) {
        h = requestAnimationFrame(this.boundComplete);
        this.handle = function() {
          cancelAnimationFrame(h);
        }
      } else {
        h = setTimeout(this.boundComplete, wait);
        this.handle = function() {
          clearTimeout(h);
        }
      }
    },
    stop: function() {
      if (this.handle) {
        this.handle();
        this.handle = null;
      }
    },
    complete: function() {
      if (this.handle) {
        this.stop();
        this.callback.call(this.context);
      }
    }
  };

  function job(job, callback, wait) {
    if (job) {
      job.stop();
    } else {
      job = new Job(this);
    }
    job.go(callback, wait);
    return job;
  }

  // exports

  scope.job = job;

})(Polymer);

(function(scope) {

  // dom polyfill, additions, and utility methods

  var registry = {};

  HTMLElement.register = function(tag, prototype) {
    registry[tag] = prototype;
  };

  // get prototype mapped to node <tag>
  HTMLElement.getPrototypeForTag = function(tag) {
    var prototype = !tag ? HTMLElement.prototype : registry[tag];
    // TODO(sjmiles): creating <tag> is likely to have wasteful side-effects
    return prototype || Object.getPrototypeOf(document.createElement(tag));
  };

  // we have to flag propagation stoppage for the event dispatcher
  var originalStopPropagation = Event.prototype.stopPropagation;
  Event.prototype.stopPropagation = function() {
    this.cancelBubble = true;
    originalStopPropagation.apply(this, arguments);
  };


  // polyfill DOMTokenList
  // * add/remove: allow these methods to take multiple classNames
  // * toggle: add a 2nd argument which forces the given state rather
  //  than toggling.

  var add = DOMTokenList.prototype.add;
  var remove = DOMTokenList.prototype.remove;
  DOMTokenList.prototype.add = function() {
    for (var i = 0; i < arguments.length; i++) {
      add.call(this, arguments[i]);
    }
  };
  DOMTokenList.prototype.remove = function() {
    for (var i = 0; i < arguments.length; i++) {
      remove.call(this, arguments[i]);
    }
  };
  DOMTokenList.prototype.toggle = function(name, bool) {
    if (arguments.length == 1) {
      bool = !this.contains(name);
    }
    bool ? this.add(name) : this.remove(name);
  };
  DOMTokenList.prototype.switch = function(oldName, newName) {
    oldName && this.remove(oldName);
    newName && this.add(newName);
  };

  // add array() to NodeList, NamedNodeMap, HTMLCollection

  var ArraySlice = function() {
    return Array.prototype.slice.call(this);
  };

  var namedNodeMap = (window.NamedNodeMap || window.MozNamedAttrMap || {});

  NodeList.prototype.array = ArraySlice;
  namedNodeMap.prototype.array = ArraySlice;
  HTMLCollection.prototype.array = ArraySlice;

  // utility

  function createDOM(inTagOrNode, inHTML, inAttrs) {
    var dom = typeof inTagOrNode == 'string' ?
        document.createElement(inTagOrNode) : inTagOrNode.cloneNode(true);
    dom.innerHTML = inHTML;
    if (inAttrs) {
      for (var n in inAttrs) {
        dom.setAttribute(n, inAttrs[n]);
      }
    }
    return dom;
  }

  // exports

  scope.createDOM = createDOM;

})(Polymer);

(function(scope) {
    // super

    // `arrayOfArgs` is an optional array of args like one might pass
    // to `Function.apply`

    // TODO(sjmiles):
    //    $super must be installed on an instance or prototype chain
    //    as `super`, and invoked via `this`, e.g.
    //      `this.super();`

    //    will not work if function objects are not unique, for example,
    //    when using mixins.
    //    The memoization strategy assumes each function exists on only one
    //    prototype chain i.e. we use the function object for memoizing)
    //    perhaps we can bookkeep on the prototype itself instead
    function $super(arrayOfArgs) {
      // since we are thunking a method call, performance is important here:
      // memoize all lookups, once memoized the fast path calls no other
      // functions
      //
      // find the caller (cannot be `strict` because of 'caller')
      var caller = $super.caller;
      // memoized 'name of method'
      var nom = caller.nom;
      // memoized next implementation prototype
      var _super = caller._super;
      if (!_super) {
        if (!nom) {
          nom = caller.nom = nameInThis.call(this, caller);
        }
        if (!nom) {
          console.warn('called super() on a method not installed declaratively (has no .nom property)');
        }
        // super prototype is either cached or we have to find it
        // by searching __proto__ (at the 'top')
        // invariant: because we cache _super on fn below, we never reach
        // here from inside a series of calls to super(), so it's ok to
        // start searching from the prototype of 'this' (at the 'top')
        // we must never memoize a null super for this reason
        _super = memoizeSuper(caller, nom, getPrototypeOf(this));
      }
      // our super function
      var fn = _super[nom];
      if (fn) {
        // memoize information so 'fn' can call 'super'
        if (!fn._super) {
          // must not memoize null, or we lose our invariant above
          memoizeSuper(fn, nom, _super);
        }
        // invoke the inherited method
        // if 'fn' is not function valued, this will throw
        return fn.apply(this, arrayOfArgs || []);
      }
    }

    function nameInThis(value) {
      var p = this.__proto__;
      while (p && p !== HTMLElement.prototype) {
        // TODO(sjmiles): getOwnPropertyNames is absurdly expensive
        var n$ = Object.getOwnPropertyNames(p);
        for (var i=0, l=n$.length, n; i<l && (n=n$[i]); i++) {
          var d = Object.getOwnPropertyDescriptor(p, n);
          if (typeof d.value === 'function' && d.value === value) {
            return n;
          }
        }
        p = p.__proto__;
      }
    }

    function memoizeSuper(method, name, proto) {
      // find and cache next prototype containing `name`
      // we need the prototype so we can do another lookup
      // from here
      var s = nextSuper(proto, name, method);
      if (s[name]) {
        // `s` is a prototype, the actual method is `s[name]`
        // tag super method with it's name for quicker lookups
        s[name].nom = name;
      }
      return method._super = s;
    }

    function nextSuper(proto, name, caller) {
      // look for an inherited prototype that implements name
      while (proto) {
        if ((proto[name] !== caller) && proto[name]) {
          return proto;
        }
        proto = getPrototypeOf(proto);
      }
      // must not return null, or we lose our invariant above
      // in this case, a super() call was invoked where no superclass
      // method exists
      // TODO(sjmiles): thow an exception?
      return Object;
    }

    // NOTE: In some platforms (IE10) the prototype chain is faked via
    // __proto__. Therefore, always get prototype via __proto__ instead of
    // the more standard Object.getPrototypeOf.
    function getPrototypeOf(prototype) {
      return prototype.__proto__;
    }

    // utility function to precompute name tags for functions
    // in a (unchained) prototype
    function hintSuper(prototype) {
      // tag functions with their prototype name to optimize
      // super call invocations
      for (var n in prototype) {
        var pd = Object.getOwnPropertyDescriptor(prototype, n);
        if (pd && typeof pd.value === 'function') {
          pd.value.nom = n;
        }
      }
    }

    // exports

    scope.super = $super;

})(Polymer);

(function(scope) {

  function noopHandler(value) {
    return value;
  }

  // helper for deserializing properties of various types to strings
  var typeHandlers = {
    string: noopHandler,
    'undefined': noopHandler,
    date: function(value) {
      return new Date(Date.parse(value) || Date.now());
    },
    boolean: function(value) {
      if (value === '') {
        return true;
      }
      return value === 'false' ? false : !!value;
    },
    number: function(value) {
      var n = parseFloat(value);
      // hex values like "0xFFFF" parseFloat as 0
      if (n === 0) {
        n = parseInt(value);
      }
      return isNaN(n) ? value : n;
      // this code disabled because encoded values (like "0xFFFF")
      // do not round trip to their original format
      //return (String(floatVal) === value) ? floatVal : value;
    },
    object: function(value, currentValue) {
      if (currentValue === null) {
        return value;
      }
      try {
        // If the string is an object, we can parse is with the JSON library.
        // include convenience replace for single-quotes. If the author omits
        // quotes altogether, parse will fail.
        return JSON.parse(value.replace(/'/g, '"'));
      } catch(e) {
        // The object isn't valid JSON, return the raw value
        return value;
      }
    },
    // avoid deserialization of functions
    'function': function(value, currentValue) {
      return currentValue;
    }
  };

  function deserializeValue(value, currentValue) {
    // attempt to infer type from default value
    var inferredType = typeof currentValue;
    // invent 'date' type value for Date
    if (currentValue instanceof Date) {
      inferredType = 'date';
    }
    // delegate deserialization via type string
    return typeHandlers[inferredType](value, currentValue);
  }

  // exports

  scope.deserializeValue = deserializeValue;

})(Polymer);

(function(scope) {

  // imports

  var extend = scope.extend;

  // module

  var api = {};

  api.declaration = {};
  api.instance = {};

  api.publish = function(apis, prototype) {
    for (var n in apis) {
      extend(prototype, apis[n]);
    }
  };

  // exports

  scope.api = api;

})(Polymer);

(function(scope) {

  /**
   * @class polymer-base
   */

  var utils = {

    /**
      * Invokes a function asynchronously. The context of the callback
      * function is bound to 'this' automatically. Returns a handle which may
      * be passed to <a href="#cancelAsync">cancelAsync</a> to cancel the
      * asynchronous call.
      *
      * @method async
      * @param {Function|String} method
      * @param {any|Array} args
      * @param {number} timeout
      */
    async: function(method, args, timeout) {
      // when polyfilling Object.observe, ensure changes
      // propagate before executing the async method
      Polymer.flush();
      // second argument to `apply` must be an array
      args = (args && args.length) ? args : [args];
      // function to invoke
      var fn = function() {
        (this[method] || method).apply(this, args);
      }.bind(this);
      // execute `fn` sooner or later
      var handle = timeout ? setTimeout(fn, timeout) :
          requestAnimationFrame(fn);
      // NOTE: switch on inverting handle to determine which time is used.
      return timeout ? handle : ~handle;
    },

    /**
      * Cancels a pending callback that was scheduled via
      * <a href="#async">async</a>.
      *
      * @method cancelAsync
      * @param {handle} handle Handle of the `async` to cancel.
      */
    cancelAsync: function(handle) {
      if (handle < 0) {
        cancelAnimationFrame(~handle);
      } else {
        clearTimeout(handle);
      }
    },

    /**
      * Fire an event.
      *
      * @method fire
      * @returns {Object} event
      * @param {string} type An event name.
      * @param {any} detail
      * @param {Node} onNode Target node.
      * @param {Boolean} bubbles Set false to prevent bubbling, defaults to true
      * @param {Boolean} cancelable Set false to prevent cancellation, defaults to true
      */
    fire: function(type, detail, onNode, bubbles, cancelable) {
      var node = onNode || this;
      var detail = detail === null || detail === undefined ? {} : detail;
      var event = new CustomEvent(type, {
        bubbles: bubbles !== undefined ? bubbles : true,
        cancelable: cancelable !== undefined ? cancelable : true,
        detail: detail
      });
      node.dispatchEvent(event);
      return event;
    },

    /**
      * Fire an event asynchronously.
      *
      * @method asyncFire
      * @param {string} type An event name.
      * @param detail
      * @param {Node} toNode Target node.
      */
    asyncFire: function(/*inType, inDetail*/) {
      this.async("fire", arguments);
    },

    /**
      * Remove class from old, add class to anew, if they exist.
      *
      * @param classFollows
      * @param anew A node.
      * @param old A node
      * @param className
      */
    classFollows: function(anew, old, className) {
      if (old) {
        old.classList.remove(className);
      }
      if (anew) {
        anew.classList.add(className);
      }
    },

    /**
      * Inject HTML which contains markup bound to this element into
      * a target element (replacing target element content).
      *
      * @param String html to inject
      * @param Element target element
      */
    injectBoundHTML: function(html, element) {
      var template = document.createElement('template');
      template.innerHTML = html;
      var fragment = this.instanceTemplate(template);
      if (element) {
        element.textContent = '';
        element.appendChild(fragment);
      }
      return fragment;
    }
  };

  // no-operation function for handy stubs
  var nop = function() {};

  // null-object for handy stubs
  var nob = {};

  // deprecated

  utils.asyncMethod = utils.async;

  // exports

  scope.api.instance.utils = utils;
  scope.nop = nop;
  scope.nob = nob;

})(Polymer);

(function(scope) {

  // imports

  var log = window.WebComponents ? WebComponents.flags.log : {};
  var EVENT_PREFIX = 'on-';

  // instance events api
  var events = {
    // read-only
    EVENT_PREFIX: EVENT_PREFIX,
    // event listeners on host
    addHostListeners: function() {
      var events = this.eventDelegates;
      log.events && (Object.keys(events).length > 0) && console.log('[%s] addHostListeners:', this.localName, events);
      // NOTE: host events look like bindings but really are not;
      // (1) we don't want the attribute to be set and (2) we want to support
      // multiple event listeners ('host' and 'instance') and Node.bind
      // by default supports 1 thing being bound.
      for (var type in events) {
        var methodName = events[type];
        PolymerGestures.addEventListener(this, type, this.element.getEventHandler(this, this, methodName));
      }
    },
    // call 'method' or function method on 'obj' with 'args', if the method exists
    dispatchMethod: function(obj, method, args) {
      if (obj) {
        log.events && console.group('[%s] dispatch [%s]', obj.localName, method);
        var fn = typeof method === 'function' ? method : obj[method];
        if (fn) {
          fn[args ? 'apply' : 'call'](obj, args);
        }
        log.events && console.groupEnd();
        // NOTE: dirty check right after calling method to ensure
        // changes apply quickly; in a very complicated app using high
        // frequency events, this can be a perf concern; in this case,
        // imperative handlers can be used to avoid flushing.
        Polymer.flush();
      }
    }
  };

  // exports

  scope.api.instance.events = events;

  /**
   * @class Polymer
   */

  /**
   * Add a gesture aware event handler to the given `node`. Can be used
   * in place of `element.addEventListener` and ensures gestures will function
   * as expected on mobile platforms. Please note that Polymer's declarative
   * event handlers include this functionality by default.
   *
   * @method addEventListener
   * @param {Node} node node on which to listen
   * @param {String} eventType name of the event
   * @param {Function} handlerFn event handler function
   * @param {Boolean} capture set to true to invoke event capturing
   * @type Function
   */
  // alias PolymerGestures event listener logic
  scope.addEventListener = function(node, eventType, handlerFn, capture) {
    PolymerGestures.addEventListener(wrap(node), eventType, handlerFn, capture);
  };

  /**
   * Remove a gesture aware event handler on the given `node`. To remove an
   * event listener, the exact same arguments are required that were passed
   * to `Polymer.addEventListener`.
   *
   * @method removeEventListener
   * @param {Node} node node on which to listen
   * @param {String} eventType name of the event
   * @param {Function} handlerFn event handler function
   * @param {Boolean} capture set to true to invoke event capturing
   * @type Function
   */
  scope.removeEventListener = function(node, eventType, handlerFn, capture) {
    PolymerGestures.removeEventListener(wrap(node), eventType, handlerFn, capture);
  };

})(Polymer);

(function(scope) {

  // instance api for attributes

  var attributes = {
    // copy attributes defined in the element declaration to the instance
    // e.g. <polymer-element name="x-foo" tabIndex="0"> tabIndex is copied
    // to the element instance here.
    copyInstanceAttributes: function () {
      var a$ = this._instanceAttributes;
      for (var k in a$) {
        if (!this.hasAttribute(k)) {
          this.setAttribute(k, a$[k]);
        }
      }
    },
    // for each attribute on this, deserialize value to property as needed
    takeAttributes: function() {
      // if we have no publish lookup table, we have no attributes to take
      // TODO(sjmiles): ad hoc
      if (this._publishLC) {
        for (var i=0, a$=this.attributes, l=a$.length, a; (a=a$[i]) && i<l; i++) {
          this.attributeToProperty(a.name, a.value);
        }
      }
    },
    // if attribute 'name' is mapped to a property, deserialize
    // 'value' into that property
    attributeToProperty: function(name, value) {
      // try to match this attribute to a property (attributes are
      // all lower-case, so this is case-insensitive search)
      var name = this.propertyForAttribute(name);
      if (name) {
        // filter out 'mustached' values, these are to be
        // replaced with bound-data and are not yet values
        // themselves
        if (value && value.search(scope.bindPattern) >= 0) {
          return;
        }
        // get original value
        var currentValue = this[name];
        // deserialize Boolean or Number values from attribute
        var value = this.deserializeValue(value, currentValue);
        // only act if the value has changed
        if (value !== currentValue) {
          // install new value (has side-effects)
          this[name] = value;
        }
      }
    },
    // return the published property matching name, or undefined
    propertyForAttribute: function(name) {
      var match = this._publishLC && this._publishLC[name];
      return match;
    },
    // convert representation of `stringValue` based on type of `currentValue`
    deserializeValue: function(stringValue, currentValue) {
      return scope.deserializeValue(stringValue, currentValue);
    },
    // convert to a string value based on the type of `inferredType`
    serializeValue: function(value, inferredType) {
      if (inferredType === 'boolean') {
        return value ? '' : undefined;
      } else if (inferredType !== 'object' && inferredType !== 'function'
          && value !== undefined) {
        return value;
      }
    },
    // serializes `name` property value and updates the corresponding attribute
    // note that reflection is opt-in.
    reflectPropertyToAttribute: function(name) {
      var inferredType = typeof this[name];
      // try to intelligently serialize property value
      var serializedValue = this.serializeValue(this[name], inferredType);
      // boolean properties must reflect as boolean attributes
      if (serializedValue !== undefined) {
        this.setAttribute(name, serializedValue);
        // TODO(sorvell): we should remove attr for all properties
        // that have undefined serialization; however, we will need to
        // refine the attr reflection system to achieve this; pica, for example,
        // relies on having inferredType object properties not removed as
        // attrs.
      } else if (inferredType === 'boolean') {
        this.removeAttribute(name);
      }
    }
  };

  // exports

  scope.api.instance.attributes = attributes;

})(Polymer);

(function(scope) {

  /**
   * @class polymer-base
   */

  // imports

  var log = window.WebComponents ? WebComponents.flags.log : {};

  // magic words

  var OBSERVE_SUFFIX = 'Changed';

  // element api

  var empty = [];

  var updateRecord = {
    object: undefined,
    type: 'update',
    name: undefined,
    oldValue: undefined
  };

  var numberIsNaN = Number.isNaN || function(value) {
    return typeof value === 'number' && isNaN(value);
  };

  function areSameValue(left, right) {
    if (left === right)
      return left !== 0 || 1 / left === 1 / right;
    if (numberIsNaN(left) && numberIsNaN(right))
      return true;
    return left !== left && right !== right;
  }

  // capture A's value if B's value is null or undefined,
  // otherwise use B's value
  function resolveBindingValue(oldValue, value) {
    if (value === undefined && oldValue === null) {
      return value;
    }
    return (value === null || value === undefined) ? oldValue : value;
  }

  var properties = {

    // creates a CompoundObserver to observe property changes
    // NOTE, this is only done there are any properties in the `observe` object
    createPropertyObserver: function() {
      var n$ = this._observeNames;
      if (n$ && n$.length) {
        var o = this._propertyObserver = new CompoundObserver(true);
        this.registerObserver(o);
        // TODO(sorvell): may not be kosher to access the value here (this[n]);
        // previously we looked at the descriptor on the prototype
        // this doesn't work for inheritance and not for accessors without
        // a value property
        for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {
          o.addPath(this, n);
          this.observeArrayValue(n, this[n], null);
        }
      }
    },

    // start observing property changes
    openPropertyObserver: function() {
      if (this._propertyObserver) {
        this._propertyObserver.open(this.notifyPropertyChanges, this);
      }
    },

    // handler for property changes; routes changes to observing methods
    // note: array valued properties are observed for array splices
    notifyPropertyChanges: function(newValues, oldValues, paths) {
      var name, method, called = {};
      for (var i in oldValues) {
        // note: paths is of form [object, path, object, path]
        name = paths[2 * i + 1];
        method = this.observe[name];
        if (method) {
          var ov = oldValues[i], nv = newValues[i];
          // observes the value if it is an array
          this.observeArrayValue(name, nv, ov);
          if (!called[method]) {
            // only invoke change method if one of ov or nv is not (undefined | null)
            if ((ov !== undefined && ov !== null) || (nv !== undefined && nv !== null)) {
              called[method] = true;
              // TODO(sorvell): call method with the set of values it's expecting;
              // e.g. 'foo bar': 'invalidate' expects the new and old values for
              // foo and bar. Currently we give only one of these and then
              // deliver all the arguments.
              this.invokeMethod(method, [ov, nv, arguments]);
            }
          }
        }
      }
    },

    // call method iff it exists.
    invokeMethod: function(method, args) {
      var fn = this[method] || method;
      if (typeof fn === 'function') {
        fn.apply(this, args);
      }
    },

    /**
     * Force any pending property changes to synchronously deliver to
     * handlers specified in the `observe` object.
     * Note, normally changes are processed at microtask time.
     *
     * @method deliverChanges
     */
    deliverChanges: function() {
      if (this._propertyObserver) {
        this._propertyObserver.deliver();
      }
    },

    observeArrayValue: function(name, value, old) {
      // we only care if there are registered side-effects
      var callbackName = this.observe[name];
      if (callbackName) {
        // if we are observing the previous value, stop
        if (Array.isArray(old)) {
          log.observe && console.log('[%s] observeArrayValue: unregister observer [%s]', this.localName, name);
          this.closeNamedObserver(name + '__array');
        }
        // if the new value is an array, being observing it
        if (Array.isArray(value)) {
          log.observe && console.log('[%s] observeArrayValue: register observer [%s]', this.localName, name, value);
          var observer = new ArrayObserver(value);
          observer.open(function(splices) {
            this.invokeMethod(callbackName, [splices]);
          }, this);
          this.registerNamedObserver(name + '__array', observer);
        }
      }
    },

    emitPropertyChangeRecord: function(name, value, oldValue) {
      var object = this;
      if (areSameValue(value, oldValue)) {
        return;
      }
      // invoke property change side effects
      this._propertyChanged(name, value, oldValue);
      // emit change record
      if (!Observer.hasObjectObserve) {
        return;
      }
      var notifier = this._objectNotifier;
      if (!notifier) {
        notifier = this._objectNotifier = Object.getNotifier(this);
      }
      updateRecord.object = this;
      updateRecord.name = name;
      updateRecord.oldValue = oldValue;
      notifier.notify(updateRecord);
    },

    _propertyChanged: function(name, value, oldValue) {
      if (this.reflect[name]) {
        this.reflectPropertyToAttribute(name);
      }
    },

    // creates a property binding (called via bind) to a published property.
    bindProperty: function(property, observable, oneTime) {
      if (oneTime) {
        this[property] = observable;
        return;
      }
      var computed = this.element.prototype.computed;
      // Binding an "out-only" value to a computed property. Note that
      // since this observer isn't opened, it doesn't need to be closed on
      // cleanup.
      if (computed && computed[property]) {
        var privateComputedBoundValue = property + 'ComputedBoundObservable_';
        this[privateComputedBoundValue] = observable;
        return;
      }
      return this.bindToAccessor(property, observable, resolveBindingValue);
    },

    // NOTE property `name` must be published. This makes it an accessor.
    bindToAccessor: function(name, observable, resolveFn) {
      var privateName = name + '_';
      var privateObservable  = name + 'Observable_';
      // Present for properties which are computed and published and have a
      // bound value.
      var privateComputedBoundValue = name + 'ComputedBoundObservable_';
      this[privateObservable] = observable;
      var oldValue = this[privateName];
      // observable callback
      var self = this;
      function updateValue(value, oldValue) {
        self[privateName] = value;
        var setObserveable = self[privateComputedBoundValue];
        if (setObserveable && typeof setObserveable.setValue == 'function') {
          setObserveable.setValue(value);
        }
        self.emitPropertyChangeRecord(name, value, oldValue);
      }
      // resolve initial value
      var value = observable.open(updateValue);
      if (resolveFn && !areSameValue(oldValue, value)) {
        var resolvedValue = resolveFn(oldValue, value);
        if (!areSameValue(value, resolvedValue)) {
          value = resolvedValue;
          if (observable.setValue) {
            observable.setValue(value);
          }
        }
      }
      updateValue(value, oldValue);
      // register and return observable
      var observer = {
        close: function() {
          observable.close();
          self[privateObservable] = undefined;
          self[privateComputedBoundValue] = undefined;
        }
      };
      this.registerObserver(observer);
      return observer;
    },

    createComputedProperties: function() {
      if (!this._computedNames) {
        return;
      }
      for (var i = 0; i < this._computedNames.length; i++) {
        var name = this._computedNames[i];
        var expressionText = this.computed[name];
        try {
          var expression = PolymerExpressions.getExpression(expressionText);
          var observable = expression.getBinding(this, this.element.syntax);
          this.bindToAccessor(name, observable);
        } catch (ex) {
          console.error('Failed to create computed property', ex);
        }
      }
    },

    // property bookkeeping
    registerObserver: function(observer) {
      if (!this._observers) {
        this._observers = [observer];
        return;
      }
      this._observers.push(observer);
    },

    closeObservers: function() {
      if (!this._observers) {
        return;
      }
      // observer array items are arrays of observers.
      var observers = this._observers;
      for (var i = 0; i < observers.length; i++) {
        var observer = observers[i];
        if (observer && typeof observer.close == 'function') {
          observer.close();
        }
      }
      this._observers = [];
    },

    // bookkeeping observers for memory management
    registerNamedObserver: function(name, observer) {
      var o$ = this._namedObservers || (this._namedObservers = {});
      o$[name] = observer;
    },

    closeNamedObserver: function(name) {
      var o$ = this._namedObservers;
      if (o$ && o$[name]) {
        o$[name].close();
        o$[name] = null;
        return true;
      }
    },

    closeNamedObservers: function() {
      if (this._namedObservers) {
        for (var i in this._namedObservers) {
          this.closeNamedObserver(i);
        }
        this._namedObservers = {};
      }
    }

  };

  // logging
  var LOG_OBSERVE = '[%s] watching [%s]';
  var LOG_OBSERVED = '[%s#%s] watch: [%s] now [%s] was [%s]';
  var LOG_CHANGED = '[%s#%s] propertyChanged: [%s] now [%s] was [%s]';

  // exports

  scope.api.instance.properties = properties;

})(Polymer);

(function(scope) {

  /**
   * @class polymer-base
   */

  // imports

  var log = window.WebComponents ? WebComponents.flags.log : {};

  // element api supporting mdv
  var mdv = {

    /**
     * Creates dom cloned from the given template, instantiating bindings
     * with this element as the template model and `PolymerExpressions` as the
     * binding delegate.
     *
     * @method instanceTemplate
     * @param {Template} template source template from which to create dom.
     */
    instanceTemplate: function(template) {
      // ensure template is decorated (lets' things like <tr template ...> work)
      HTMLTemplateElement.decorate(template);
      // ensure a default bindingDelegate
      var syntax = this.syntax || (!template.bindingDelegate &&
          this.element.syntax);
      var dom = template.createInstance(this, syntax);
      var observers = dom.bindings_;
      for (var i = 0; i < observers.length; i++) {
        this.registerObserver(observers[i]);
      }
      return dom;
    },

    // Called by TemplateBinding/NodeBind to setup a binding to the given
    // property. It's overridden here to support property bindings
    // in addition to attribute bindings that are supported by default.
    bind: function(name, observable, oneTime) {
      var property = this.propertyForAttribute(name);
      if (!property) {
        // TODO(sjmiles): this mixin method must use the special form
        // of `super` installed by `mixinMethod` in declaration/prototype.js
        return this.mixinSuper(arguments);
      } else {
        // use n-way Polymer binding
        var observer = this.bindProperty(property, observable, oneTime);
        // NOTE: reflecting binding information is typically required only for
        // tooling. It has a performance cost so it's opt-in in Node.bind.
        if (Platform.enableBindingsReflection && observer) {
          observer.path = observable.path_;
          this._recordBinding(property, observer);
        }
        if (this.reflect[property]) {
          this.reflectPropertyToAttribute(property);
        }
        return observer;
      }
    },

    _recordBinding: function(name, observer) {
      this.bindings_ = this.bindings_ || {};
      this.bindings_[name] = observer;
    },

    // Called by TemplateBinding when all bindings on an element have been
    // executed. This signals that all element inputs have been gathered
    // and it's safe to ready the element, create shadow-root and start
    // data-observation.
    bindFinished: function() {
      this.makeElementReady();
    },

    // called at detached time to signal that an element's bindings should be
    // cleaned up. This is done asynchronously so that users have the chance
    // to call `cancelUnbindAll` to prevent unbinding.
    asyncUnbindAll: function() {
      if (!this._unbound) {
        log.unbind && console.log('[%s] asyncUnbindAll', this.localName);
        this._unbindAllJob = this.job(this._unbindAllJob, this.unbindAll, 0);
      }
    },

    /**
     * This method should rarely be used and only if
     * <a href="#cancelUnbindAll">`cancelUnbindAll`</a> has been called to
     * prevent element unbinding. In this case, the element's bindings will
     * not be automatically cleaned up and it cannot be garbage collected
     * by the system. If memory pressure is a concern or a
     * large amount of elements need to be managed in this way, `unbindAll`
     * can be called to deactivate the element's bindings and allow its
     * memory to be reclaimed.
     *
     * @method unbindAll
     */
    unbindAll: function() {
      if (!this._unbound) {
        this.closeObservers();
        this.closeNamedObservers();
        this._unbound = true;
      }
    },

    /**
     * Call in `detached` to prevent the element from unbinding when it is
     * detached from the dom. The element is unbound as a cleanup step that
     * allows its memory to be reclaimed.
     * If `cancelUnbindAll` is used, consider calling
     * <a href="#unbindAll">`unbindAll`</a> when the element is no longer
     * needed. This will allow its memory to be reclaimed.
     *
     * @method cancelUnbindAll
     */
    cancelUnbindAll: function() {
      if (this._unbound) {
        log.unbind && console.warn('[%s] already unbound, cannot cancel unbindAll', this.localName);
        return;
      }
      log.unbind && console.log('[%s] cancelUnbindAll', this.localName);
      if (this._unbindAllJob) {
        this._unbindAllJob = this._unbindAllJob.stop();
      }
    }

  };

  function unbindNodeTree(node) {
    forNodeTree(node, _nodeUnbindAll);
  }

  function _nodeUnbindAll(node) {
    node.unbindAll();
  }

  function forNodeTree(node, callback) {
    if (node) {
      callback(node);
      for (var child = node.firstChild; child; child = child.nextSibling) {
        forNodeTree(child, callback);
      }
    }
  }

  var mustachePattern = /\{\{([^{}]*)}}/;

  // exports

  scope.bindPattern = mustachePattern;
  scope.api.instance.mdv = mdv;

})(Polymer);

(function(scope) {

  /**
   * Common prototype for all Polymer Elements.
   *
   * @class polymer-base
   * @homepage polymer.github.io
   */
  var base = {
    /**
     * Tags this object as the canonical Base prototype.
     *
     * @property PolymerBase
     * @type boolean
     * @default true
     */
    PolymerBase: true,

    /**
     * Debounce signals.
     *
     * Call `job` to defer a named signal, and all subsequent matching signals,
     * until a wait time has elapsed with no new signal.
     *
     *     debouncedClickAction: function(e) {
     *       // processClick only when it's been 100ms since the last click
     *       this.job('click', function() {
     *        this.processClick;
     *       }, 100);
     *     }
     *
     * @method job
     * @param String {String} job A string identifier for the job to debounce.
     * @param Function {Function} callback A function that is called (with `this` context) when the wait time elapses.
     * @param Number {Number} wait Time in milliseconds (ms) after the last signal that must elapse before invoking `callback`
     * @type Handle
     */
    job: function(job, callback, wait) {
      if (typeof job === 'string') {
        var n = '___' + job;
        this[n] = Polymer.job.call(this, this[n], callback, wait);
      } else {
        // TODO(sjmiles): suggest we deprecate this call signature
        return Polymer.job.call(this, job, callback, wait);
      }
    },

    /**
     * Invoke a superclass method.
     *
     * Use `super()` to invoke the most recently overridden call to the
     * currently executing function.
     *
     * To pass arguments through, use the literal `arguments` as the parameter
     * to `super()`.
     *
     *     nextPageAction: function(e) {
     *       // invoke the superclass version of `nextPageAction`
     *       this.super(arguments);
     *     }
     *
     * To pass custom arguments, arrange them in an array.
     *
     *     appendSerialNo: function(value, serial) {
     *       // prefix the superclass serial number with our lot # before
     *       // invoking the superlcass
     *       return this.super([value, this.lotNo + serial])
     *     }
     *
     * @method super
     * @type Any
     * @param {args) An array of arguments to use when calling the superclass method, or null.
     */
    super: Polymer.super,

    /**
     * Lifecycle method called when the element is instantiated.
     *
     * Override `created` to perform custom create-time tasks. No need to call
     * super-class `created` unless you are extending another Polymer element.
     * Created is called before the element creates `shadowRoot` or prepares
     * data-observation.
     *
     * @method created
     * @type void
     */
    created: function() {
    },

    /**
     * Lifecycle method called when the element has populated it's `shadowRoot`,
     * prepared data-observation, and made itself ready for API interaction.
     *
     * @method ready
     * @type void
     */
    ready: function() {
    },

    /**
     * Low-level lifecycle method called as part of standard Custom Elements
     * operation. Polymer implements this method to provide basic default
     * functionality. For custom create-time tasks, implement `created`
     * instead, which is called immediately after `createdCallback`.
     *
     * @method createdCallback
     */
    createdCallback: function() {
      if (this.templateInstance && this.templateInstance.model) {
        console.warn('Attributes on ' + this.localName + ' were data bound ' +
            'prior to Polymer upgrading the element. This may result in ' +
            'incorrect binding types.');
      }
      this.created();
      this.prepareElement();
      if (!this.ownerDocument.isStagingDocument) {
        this.makeElementReady();
      }
    },

    // system entry point, do not override
    prepareElement: function() {
      if (this._elementPrepared) {
        console.warn('Element already prepared', this.localName);
        return;
      }
      this._elementPrepared = true;
      // storage for shadowRoots info
      this.shadowRoots = {};
      // install property observers
      this.createPropertyObserver();
      this.openPropertyObserver();
      // install boilerplate attributes
      this.copyInstanceAttributes();
      // process input attributes
      this.takeAttributes();
      // add event listeners
      this.addHostListeners();
    },

    // system entry point, do not override
    makeElementReady: function() {
      if (this._readied) {
        return;
      }
      this._readied = true;
      this.createComputedProperties();
      this.parseDeclarations(this.__proto__);
      // NOTE: Support use of the `unresolved` attribute to help polyfill
      // custom elements' `:unresolved` feature.
      this.removeAttribute('unresolved');
      // user entry point
      this.ready();
    },

    /**
     * Low-level lifecycle method called as part of standard Custom Elements
     * operation. Polymer implements this method to provide basic default
     * functionality. For custom tasks in your element, implement `attributeChanged`
     * instead, which is called immediately after `attributeChangedCallback`.
     *
     * @method attributeChangedCallback
     */
    attributeChangedCallback: function(name, oldValue) {
      // TODO(sjmiles): adhoc filter
      if (name !== 'class' && name !== 'style') {
        this.attributeToProperty(name, this.getAttribute(name));
      }
      if (this.attributeChanged) {
        this.attributeChanged.apply(this, arguments);
      }
    },

    /**
     * Low-level lifecycle method called as part of standard Custom Elements
     * operation. Polymer implements this method to provide basic default
     * functionality. For custom create-time tasks, implement `attached`
     * instead, which is called immediately after `attachedCallback`.
     *
     * @method attachedCallback
     */
     attachedCallback: function() {
      // when the element is attached, prevent it from unbinding.
      this.cancelUnbindAll();
      // invoke user action
      if (this.attached) {
        this.attached();
      }
      if (!this.hasBeenAttached) {
        this.hasBeenAttached = true;
        if (this.domReady) {
          this.async('domReady');
        }
      }
    },

     /**
     * Implement to access custom elements in dom descendants, ancestors,
     * or siblings. Because custom elements upgrade in document order,
     * elements accessed in `ready` or `attached` may not be upgraded. When
     * `domReady` is called, all registered custom elements are guaranteed
     * to have been upgraded.
     *
     * @method domReady
     */

    /**
     * Low-level lifecycle method called as part of standard Custom Elements
     * operation. Polymer implements this method to provide basic default
     * functionality. For custom create-time tasks, implement `detached`
     * instead, which is called immediately after `detachedCallback`.
     *
     * @method detachedCallback
     */
    detachedCallback: function() {
      if (!this.preventDispose) {
        this.asyncUnbindAll();
      }
      // invoke user action
      if (this.detached) {
        this.detached();
      }
      // TODO(sorvell): bc
      if (this.leftView) {
        this.leftView();
      }
    },

    /**
     * Walks the prototype-chain of this element and allows specific
     * classes a chance to process static declarations.
     *
     * In particular, each polymer-element has it's own `template`.
     * `parseDeclarations` is used to accumulate all element `template`s
     * from an inheritance chain.
     *
     * `parseDeclaration` static methods implemented in the chain are called
     * recursively, oldest first, with the `<polymer-element>` associated
     * with the current prototype passed as an argument.
     *
     * An element may override this method to customize shadow-root generation.
     *
     * @method parseDeclarations
     */
    parseDeclarations: function(p) {
      if (p && p.element) {
        this.parseDeclarations(p.__proto__);
        p.parseDeclaration.call(this, p.element);
      }
    },

    /**
     * Perform init-time actions based on static information in the
     * `<polymer-element>` instance argument.
     *
     * For example, the standard implementation locates the template associated
     * with the given `<polymer-element>` and stamps it into a shadow-root to
     * implement shadow inheritance.
     *
     * An element may override this method for custom behavior.
     *
     * @method parseDeclaration
     */
    parseDeclaration: function(elementElement) {
      var template = this.fetchTemplate(elementElement);
      if (template) {
        var root = this.shadowFromTemplate(template);
        this.shadowRoots[elementElement.name] = root;
      }
    },

    /**
     * Given a `<polymer-element>`, find an associated template (if any) to be
     * used for shadow-root generation.
     *
     * An element may override this method for custom behavior.
     *
     * @method fetchTemplate
     */
    fetchTemplate: function(elementElement) {
      return elementElement.querySelector('template');
    },

    /**
     * Create a shadow-root in this host and stamp `template` as it's
     * content.
     *
     * An element may override this method for custom behavior.
     *
     * @method shadowFromTemplate
     */
    shadowFromTemplate: function(template) {
      if (template) {
        // make a shadow root
        var root = this.createShadowRoot();
        // stamp template
        // which includes parsing and applying MDV bindings before being
        // inserted (to avoid {{}} in attribute values)
        // e.g. to prevent <img src="images/{{icon}}"> from generating a 404.
        var dom = this.instanceTemplate(template);
        // append to shadow dom
        root.appendChild(dom);
        // perform post-construction initialization tasks on shadow root
        this.shadowRootReady(root, template);
        // return the created shadow root
        return root;
      }
    },

    // utility function that stamps a <template> into light-dom
    lightFromTemplate: function(template, refNode) {
      if (template) {
        // TODO(sorvell): mark this element as an eventController so that
        // event listeners on bound nodes inside it will be called on it.
        // Note, the expectation here is that events on all descendants
        // should be handled by this element.
        this.eventController = this;
        // stamp template
        // which includes parsing and applying MDV bindings before being
        // inserted (to avoid {{}} in attribute values)
        // e.g. to prevent <img src="images/{{icon}}"> from generating a 404.
        var dom = this.instanceTemplate(template);
        // append to shadow dom
        if (refNode) {
          this.insertBefore(dom, refNode);
        } else {
          this.appendChild(dom);
        }
        // perform post-construction initialization tasks on ahem, light root
        this.shadowRootReady(this);
        // return the created shadow root
        return dom;
      }
    },

    shadowRootReady: function(root) {
      // locate nodes with id and store references to them in this.$ hash
      this.marshalNodeReferences(root);
    },

    // locate nodes with id and store references to them in this.$ hash
    marshalNodeReferences: function(root) {
      // establish $ instance variable
      var $ = this.$ = this.$ || {};
      // populate $ from nodes with ID from the LOCAL tree
      if (root) {
        var n$ = root.querySelectorAll("[id]");
        for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {
          $[n.id] = n;
        };
      }
    },

    /**
     * Register a one-time callback when a child-list or sub-tree mutation
     * occurs on node.
     *
     * For persistent callbacks, call onMutation from your listener.
     *
     * @method onMutation
     * @param Node {Node} node Node to watch for mutations.
     * @param Function {Function} listener Function to call on mutation. The function is invoked as `listener.call(this, observer, mutations);` where `observer` is the MutationObserver that triggered the notification, and `mutations` is the native mutation list.
     */
    onMutation: function(node, listener) {
      var observer = new MutationObserver(function(mutations) {
        listener.call(this, observer, mutations);
        observer.disconnect();
      }.bind(this));
      observer.observe(node, {childList: true, subtree: true});
    }
  };

  /**
   * @class Polymer
   */

  /**
   * Returns true if the object includes <a href="#polymer-base">polymer-base</a> in it's prototype chain.
   *
   * @method isBase
   * @param Object {Object} object Object to test.
   * @type Boolean
   */
  function isBase(object) {
    return object.hasOwnProperty('PolymerBase')
  }

  // name a base constructor for dev tools

  /**
   * The Polymer base-class constructor.
   *
   * @property Base
   * @type Function
   */
  function PolymerBase() {};
  PolymerBase.prototype = base;
  base.constructor = PolymerBase;

  // exports

  scope.Base = PolymerBase;
  scope.isBase = isBase;
  scope.api.instance.base = base;

})(Polymer);

(function(scope) {

  // imports

  var log = window.WebComponents ? WebComponents.flags.log : {};
  var hasShadowDOMPolyfill = window.ShadowDOMPolyfill;

  // magic words

  var STYLE_SCOPE_ATTRIBUTE = 'element';
  var STYLE_CONTROLLER_SCOPE = 'controller';

  var styles = {
    STYLE_SCOPE_ATTRIBUTE: STYLE_SCOPE_ATTRIBUTE,
    /**
     * Installs external stylesheets and <style> elements with the attribute
     * polymer-scope='controller' into the scope of element. This is intended
     * to be a called during custom element construction.
    */
    installControllerStyles: function() {
      // apply controller styles, but only if they are not yet applied
      var scope = this.findStyleScope();
      if (scope && !this.scopeHasNamedStyle(scope, this.localName)) {
        // allow inherited controller styles
        var proto = getPrototypeOf(this), cssText = '';
        while (proto && proto.element) {
          cssText += proto.element.cssTextForScope(STYLE_CONTROLLER_SCOPE);
          proto = getPrototypeOf(proto);
        }
        if (cssText) {
          this.installScopeCssText(cssText, scope);
        }
      }
    },
    installScopeStyle: function(style, name, scope) {
      var scope = scope || this.findStyleScope(), name = name || '';
      if (scope && !this.scopeHasNamedStyle(scope, this.localName + name)) {
        var cssText = '';
        if (style instanceof Array) {
          for (var i=0, l=style.length, s; (i<l) && (s=style[i]); i++) {
            cssText += s.textContent + '\n\n';
          }
        } else {
          cssText = style.textContent;
        }
        this.installScopeCssText(cssText, scope, name);
      }
    },
    installScopeCssText: function(cssText, scope, name) {
      scope = scope || this.findStyleScope();
      name = name || '';
      if (!scope) {
        return;
      }
      if (hasShadowDOMPolyfill) {
        cssText = shimCssText(cssText, scope.host);
      }
      var style = this.element.cssTextToScopeStyle(cssText,
          STYLE_CONTROLLER_SCOPE);
      Polymer.applyStyleToScope(style, scope);
      // cache that this style has been applied
      this.styleCacheForScope(scope)[this.localName + name] = true;
    },
    findStyleScope: function(node) {
      // find the shadow root that contains this element
      var n = node || this;
      while (n.parentNode) {
        n = n.parentNode;
      }
      return n;
    },
    scopeHasNamedStyle: function(scope, name) {
      var cache = this.styleCacheForScope(scope);
      return cache[name];
    },
    styleCacheForScope: function(scope) {
      if (hasShadowDOMPolyfill) {
        var scopeName = scope.host ? scope.host.localName : scope.localName;
        return polyfillScopeStyleCache[scopeName] || (polyfillScopeStyleCache[scopeName] = {});
      } else {
        return scope._scopeStyles = (scope._scopeStyles || {});
      }
    }
  };

  var polyfillScopeStyleCache = {};

  // NOTE: use raw prototype traversal so that we ensure correct traversal
  // on platforms where the protoype chain is simulated via __proto__ (IE10)
  function getPrototypeOf(prototype) {
    return prototype.__proto__;
  }

  function shimCssText(cssText, host) {
    var name = '', is = false;
    if (host) {
      name = host.localName;
      is = host.hasAttribute('is');
    }
    var selector = WebComponents.ShadowCSS.makeScopeSelector(name, is);
    return WebComponents.ShadowCSS.shimCssText(cssText, selector);
  }

  // exports

  scope.api.instance.styles = styles;

})(Polymer);

(function(scope) {

  // imports

  var extend = scope.extend;
  var api = scope.api;

  // imperative implementation: Polymer()

  // specify an 'own' prototype for tag `name`
  function element(name, prototype) {
    if (typeof name !== 'string') {
      var script = prototype || document._currentScript;
      prototype = name;
      name = script && script.parentNode && script.parentNode.getAttribute ?
          script.parentNode.getAttribute('name') : '';
      if (!name) {
        throw 'Element name could not be inferred.';
      }
    }
    if (getRegisteredPrototype(name)) {
      throw 'Already registered (Polymer) prototype for element ' + name;
    }
    // cache the prototype
    registerPrototype(name, prototype);
    // notify the registrar waiting for 'name', if any
    notifyPrototype(name);
  }

  // async prototype source

  function waitingForPrototype(name, client) {
    waitPrototype[name] = client;
  }

  var waitPrototype = {};

  function notifyPrototype(name) {
    if (waitPrototype[name]) {
      waitPrototype[name].registerWhenReady();
      delete waitPrototype[name];
    }
  }

  // utility and bookkeeping

  // maps tag names to prototypes, as registered with
  // Polymer. Prototypes associated with a tag name
  // using document.registerElement are available from
  // HTMLElement.getPrototypeForTag().
  // If an element was fully registered by Polymer, then
  // Polymer.getRegisteredPrototype(name) ===
  //   HTMLElement.getPrototypeForTag(name)

  var prototypesByName = {};

  function registerPrototype(name, prototype) {
    return prototypesByName[name] = prototype || {};
  }

  function getRegisteredPrototype(name) {
    return prototypesByName[name];
  }

  function instanceOfType(element, type) {
    if (typeof type !== 'string') {
      return false;
    }
    var proto = HTMLElement.getPrototypeForTag(type);
    var ctor = proto && proto.constructor;
    if (!ctor) {
      return false;
    }
    if (CustomElements.instanceof) {
      return CustomElements.instanceof(element, ctor);
    }
    return element instanceof ctor;
  }

  // exports

  scope.getRegisteredPrototype = getRegisteredPrototype;
  scope.waitingForPrototype = waitingForPrototype;
  scope.instanceOfType = instanceOfType;

  // namespace shenanigans so we can expose our scope on the registration
  // function

  // make window.Polymer reference `element()`

  window.Polymer = element;

  // TODO(sjmiles): find a way to do this that is less terrible
  // copy window.Polymer properties onto `element()`

  extend(Polymer, scope);

  // Under the HTMLImports polyfill, scripts in the main document
  // do not block on imports; we want to allow calls to Polymer in the main
  // document. WebComponents collects those calls until we can process them, which
  // we do here.

  if (WebComponents.consumeDeclarations) {
    WebComponents.consumeDeclarations(function(declarations) {
      if (declarations) {
        for (var i=0, l=declarations.length, d; (i<l) && (d=declarations[i]); i++) {
          element.apply(null, d);
        }
      }
    });
  }

})(Polymer);

(function(scope) {

/**
 * @class polymer-base
 */

 /**
  * Resolve a url path to be relative to a `base` url. If unspecified, `base`
  * defaults to the element's ownerDocument url. Can be used to resolve
  * paths from element's in templates loaded in HTMLImports to be relative
  * to the document containing the element. Polymer automatically does this for
  * url attributes in element templates; however, if a url, for
  * example, contains a binding, then `resolvePath` can be used to ensure it is
  * relative to the element document. For example, in an element's template,
  *
  *     <a href="{{resolvePath(path)}}">Resolved</a>
  *
  * @method resolvePath
  * @param {String} url Url path to resolve.
  * @param {String} base Optional base url against which to resolve, defaults
  * to the element's ownerDocument url.
  * returns {String} resolved url.
  */

var path = {
  resolveElementPaths: function(node) {
    Polymer.urlResolver.resolveDom(node);
  },
  addResolvePathApi: function() {
    // let assetpath attribute modify the resolve path
    var assetPath = this.getAttribute('assetpath') || '';
    var root = new URL(assetPath, this.ownerDocument.baseURI);
    this.prototype.resolvePath = function(urlPath, base) {
      var u = new URL(urlPath, base || root);
      return u.href;
    };
  }
};

// exports
scope.api.declaration.path = path;

})(Polymer);

(function(scope) {

  // imports

  var log = window.WebComponents ? WebComponents.flags.log : {};
  var api = scope.api.instance.styles;
  var STYLE_SCOPE_ATTRIBUTE = api.STYLE_SCOPE_ATTRIBUTE;

  var hasShadowDOMPolyfill = window.ShadowDOMPolyfill;

  // magic words

  var STYLE_SELECTOR = 'style';
  var STYLE_LOADABLE_MATCH = '@import';
  var SHEET_SELECTOR = 'link[rel=stylesheet]';
  var STYLE_GLOBAL_SCOPE = 'global';
  var SCOPE_ATTR = 'polymer-scope';

  var styles = {
    // returns true if resources are loading
    loadStyles: function(callback) {
      var template = this.fetchTemplate();
      var content = template && this.templateContent();
      if (content) {
        this.convertSheetsToStyles(content);
        var styles = this.findLoadableStyles(content);
        if (styles.length) {
          var templateUrl = template.ownerDocument.baseURI;
          return Polymer.styleResolver.loadStyles(styles, templateUrl, callback);
        }
      }
      if (callback) {
        callback();
      }
    },
    convertSheetsToStyles: function(root) {
      var s$ = root.querySelectorAll(SHEET_SELECTOR);
      for (var i=0, l=s$.length, s, c; (i<l) && (s=s$[i]); i++) {
        c = createStyleElement(importRuleForSheet(s, this.ownerDocument.baseURI),
            this.ownerDocument);
        this.copySheetAttributes(c, s);
        s.parentNode.replaceChild(c, s);
      }
    },
    copySheetAttributes: function(style, link) {
      for (var i=0, a$=link.attributes, l=a$.length, a; (a=a$[i]) && i<l; i++) {
        if (a.name !== 'rel' && a.name !== 'href') {
          style.setAttribute(a.name, a.value);
        }
      }
    },
    findLoadableStyles: function(root) {
      var loadables = [];
      if (root) {
        var s$ = root.querySelectorAll(STYLE_SELECTOR);
        for (var i=0, l=s$.length, s; (i<l) && (s=s$[i]); i++) {
          if (s.textContent.match(STYLE_LOADABLE_MATCH)) {
            loadables.push(s);
          }
        }
      }
      return loadables;
    },
    /**
     * Install external stylesheets loaded in <polymer-element> elements into the
     * element's template.
     * @param elementElement The <element> element to style.
     */
    installSheets: function() {
      this.cacheSheets();
      this.cacheStyles();
      this.installLocalSheets();
      this.installGlobalStyles();
    },
    /**
     * Remove all sheets from element and store for later use.
     */
    cacheSheets: function() {
      this.sheets = this.findNodes(SHEET_SELECTOR);
      this.sheets.forEach(function(s) {
        if (s.parentNode) {
          s.parentNode.removeChild(s);
        }
      });
    },
    cacheStyles: function() {
      this.styles = this.findNodes(STYLE_SELECTOR + '[' + SCOPE_ATTR + ']');
      this.styles.forEach(function(s) {
        if (s.parentNode) {
          s.parentNode.removeChild(s);
        }
      });
    },
    /**
     * Takes external stylesheets loaded in an <element> element and moves
     * their content into a <style> element inside the <element>'s template.
     * The sheet is then removed from the <element>. This is done only so
     * that if the element is loaded in the main document, the sheet does
     * not become active.
     * Note, ignores sheets with the attribute 'polymer-scope'.
     * @param elementElement The <element> element to style.
     */
    installLocalSheets: function () {
      var sheets = this.sheets.filter(function(s) {
        return !s.hasAttribute(SCOPE_ATTR);
      });
      var content = this.templateContent();
      if (content) {
        var cssText = '';
        sheets.forEach(function(sheet) {
          cssText += cssTextFromSheet(sheet) + '\n';
        });
        if (cssText) {
          var style = createStyleElement(cssText, this.ownerDocument);
          content.insertBefore(style, content.firstChild);
        }
      }
    },
    findNodes: function(selector, matcher) {
      var nodes = this.querySelectorAll(selector).array();
      var content = this.templateContent();
      if (content) {
        var templateNodes = content.querySelectorAll(selector).array();
        nodes = nodes.concat(templateNodes);
      }
      return matcher ? nodes.filter(matcher) : nodes;
    },
    /**
     * Promotes external stylesheets and <style> elements with the attribute
     * polymer-scope='global' into global scope.
     * This is particularly useful for defining @keyframe rules which
     * currently do not function in scoped or shadow style elements.
     * (See wkb.ug/72462)
     * @param elementElement The <element> element to style.
    */
    // TODO(sorvell): remove when wkb.ug/72462 is addressed.
    installGlobalStyles: function() {
      var style = this.styleForScope(STYLE_GLOBAL_SCOPE);
      applyStyleToScope(style, document.head);
    },
    cssTextForScope: function(scopeDescriptor) {
      var cssText = '';
      // handle stylesheets
      var selector = '[' + SCOPE_ATTR + '=' + scopeDescriptor + ']';
      var matcher = function(s) {
        return matchesSelector(s, selector);
      };
      var sheets = this.sheets.filter(matcher);
      sheets.forEach(function(sheet) {
        cssText += cssTextFromSheet(sheet) + '\n\n';
      });
      // handle cached style elements
      var styles = this.styles.filter(matcher);
      styles.forEach(function(style) {
        cssText += style.textContent + '\n\n';
      });
      return cssText;
    },
    styleForScope: function(scopeDescriptor) {
      var cssText = this.cssTextForScope(scopeDescriptor);
      return this.cssTextToScopeStyle(cssText, scopeDescriptor);
    },
    cssTextToScopeStyle: function(cssText, scopeDescriptor) {
      if (cssText) {
        var style = createStyleElement(cssText);
        style.setAttribute(STYLE_SCOPE_ATTRIBUTE, this.getAttribute('name') +
            '-' + scopeDescriptor);
        return style;
      }
    }
  };

  function importRuleForSheet(sheet, baseUrl) {
    var href = new URL(sheet.getAttribute('href'), baseUrl).href;
    return '@import \'' + href + '\';';
  }

  function applyStyleToScope(style, scope) {
    if (style) {
      if (scope === document) {
        scope = document.head;
      }
      if (hasShadowDOMPolyfill) {
        scope = document.head;
      }
      // TODO(sorvell): necessary for IE
      // see https://connect.microsoft.com/IE/feedback/details/790212/
      // cloning-a-style-element-and-adding-to-document-produces
      // -unexpected-result#details
      // var clone = style.cloneNode(true);
      var clone = createStyleElement(style.textContent);
      var attr = style.getAttribute(STYLE_SCOPE_ATTRIBUTE);
      if (attr) {
        clone.setAttribute(STYLE_SCOPE_ATTRIBUTE, attr);
      }
      // TODO(sorvell): probably too brittle; try to figure out
      // where to put the element.
      var refNode = scope.firstElementChild;
      if (scope === document.head) {
        var selector = 'style[' + STYLE_SCOPE_ATTRIBUTE + ']';
        var s$ = document.head.querySelectorAll(selector);
        if (s$.length) {
          refNode = s$[s$.length-1].nextElementSibling;
        }
      }
      scope.insertBefore(clone, refNode);
    }
  }

  function createStyleElement(cssText, scope) {
    scope = scope || document;
    scope = scope.createElement ? scope : scope.ownerDocument;
    var style = scope.createElement('style');
    style.textContent = cssText;
    return style;
  }

  function cssTextFromSheet(sheet) {
    return (sheet && sheet.__resource) || '';
  }

  function matchesSelector(node, inSelector) {
    if (matches) {
      return matches.call(node, inSelector);
    }
  }
  var p = HTMLElement.prototype;
  var matches = p.matches || p.matchesSelector || p.webkitMatchesSelector
      || p.mozMatchesSelector;

  // exports

  scope.api.declaration.styles = styles;
  scope.applyStyleToScope = applyStyleToScope;

})(Polymer);

(function(scope) {

  // imports

  var log = window.WebComponents ? WebComponents.flags.log : {};
  var api = scope.api.instance.events;
  var EVENT_PREFIX = api.EVENT_PREFIX;

  var mixedCaseEventTypes = {};
  [
    'webkitAnimationStart',
    'webkitAnimationEnd',
    'webkitTransitionEnd',
    'DOMFocusOut',
    'DOMFocusIn',
    'DOMMouseScroll'
  ].forEach(function(e) {
    mixedCaseEventTypes[e.toLowerCase()] = e;
  });

  // polymer-element declarative api: events feature
  var events = {
    parseHostEvents: function() {
      // our delegates map
      var delegates = this.prototype.eventDelegates;
      // extract data from attributes into delegates
      this.addAttributeDelegates(delegates);
    },
    addAttributeDelegates: function(delegates) {
      // for each attribute
      for (var i=0, a; a=this.attributes[i]; i++) {
        // does it have magic marker identifying it as an event delegate?
        if (this.hasEventPrefix(a.name)) {
          // if so, add the info to delegates
          delegates[this.removeEventPrefix(a.name)] = a.value.replace('{{', '')
              .replace('}}', '').trim();
        }
      }
    },
    // starts with 'on-'
    hasEventPrefix: function (n) {
      return n && (n[0] === 'o') && (n[1] === 'n') && (n[2] === '-');
    },
    removeEventPrefix: function(n) {
      return n.slice(prefixLength);
    },
    findController: function(node) {
      while (node.parentNode) {
        if (node.eventController) {
          return node.eventController;
        }
        node = node.parentNode;
      }
      return node.host;
    },
    getEventHandler: function(controller, target, method) {
      var events = this;
      return function(e) {
        if (!controller || !controller.PolymerBase) {
          controller = events.findController(target);
        }

        var args = [e, e.detail, e.currentTarget];
        controller.dispatchMethod(controller, method, args);
      };
    },
    prepareEventBinding: function(pathString, name, node) {
      if (!this.hasEventPrefix(name))
        return;

      var eventType = this.removeEventPrefix(name);
      eventType = mixedCaseEventTypes[eventType] || eventType;

      var events = this;

      return function(model, node, oneTime) {
        var handler = events.getEventHandler(undefined, node, pathString);
        PolymerGestures.addEventListener(node, eventType, handler);

        if (oneTime)
          return;

        // TODO(rafaelw): This is really pointless work. Aside from the cost
        // of these allocations, NodeBind is going to setAttribute back to its
        // current value. Fixing this would mean changing the TemplateBinding
        // binding delegate API.
        function bindingValue() {
          return '{{ ' + pathString + ' }}';
        }

        return {
          open: bindingValue,
          discardChanges: bindingValue,
          close: function() {
            PolymerGestures.removeEventListener(node, eventType, handler);
          }
        };
      };
    }
  };

  var prefixLength = EVENT_PREFIX.length;

  // exports
  scope.api.declaration.events = events;

})(Polymer);

(function(scope) {

  // element api

  var observationBlacklist = ['attribute'];

  var properties = {
    inferObservers: function(prototype) {
      // called before prototype.observe is chained to inherited object
      var observe = prototype.observe, property;
      for (var n in prototype) {
        if (n.slice(-7) === 'Changed') {
          property = n.slice(0, -7);
          if (this.canObserveProperty(property)) {
            if (!observe) {
              observe  = (prototype.observe = {});
            }
            observe[property] = observe[property] || n;
          }
        }
      }
    },
    canObserveProperty: function(property) {
      return (observationBlacklist.indexOf(property) < 0);
    },
    explodeObservers: function(prototype) {
      // called before prototype.observe is chained to inherited object
      var o = prototype.observe;
      if (o) {
        var exploded = {};
        for (var n in o) {
          var names = n.split(' ');
          for (var i=0, ni; ni=names[i]; i++) {
            exploded[ni] = o[n];
          }
        }
        prototype.observe = exploded;
      }
    },
    optimizePropertyMaps: function(prototype) {
      if (prototype.observe) {
        // construct name list
        var a = prototype._observeNames = [];
        for (var n in prototype.observe) {
          var names = n.split(' ');
          for (var i=0, ni; ni=names[i]; i++) {
            a.push(ni);
          }
        }
      }
      if (prototype.publish) {
        // construct name list
        var a = prototype._publishNames = [];
        for (var n in prototype.publish) {
          a.push(n);
        }
      }
      if (prototype.computed) {
        // construct name list
        var a = prototype._computedNames = [];
        for (var n in prototype.computed) {
          a.push(n);
        }
      }
    },
    publishProperties: function(prototype, base) {
      // if we have any properties to publish
      var publish = prototype.publish;
      if (publish) {
        // transcribe `publish` entries onto own prototype
        this.requireProperties(publish, prototype, base);
        // warn and remove accessor names that are broken on some browsers
        this.filterInvalidAccessorNames(publish);
        // construct map of lower-cased property names
        prototype._publishLC = this.lowerCaseMap(publish);
      }
      var computed = prototype.computed;
      if (computed) {
        // warn and remove accessor names that are broken on some browsers
        this.filterInvalidAccessorNames(computed);
      }
    },
    // Publishing/computing a property where the name might conflict with a
    // browser property is not currently supported to help users of Polymer
    // avoid browser bugs:
    //
    // https://code.google.com/p/chromium/issues/detail?id=43394
    // https://bugs.webkit.org/show_bug.cgi?id=49739
    //
    // We can lift this restriction when those bugs are fixed.
    filterInvalidAccessorNames: function(propertyNames) {
      for (var name in propertyNames) {
        // Check if the name is in our blacklist.
        if (this.propertyNameBlacklist[name]) {
          console.warn('Cannot define property "' + name + '" for element "' +
            this.name + '" because it has the same name as an HTMLElement ' +
            'property, and not all browsers support overriding that. ' +
            'Consider giving it a different name.');
          // Remove the invalid accessor from the list.
          delete propertyNames[name];
        }
      }
    },
    //
    // `name: value` entries in the `publish` object may need to generate
    // matching properties on the prototype.
    //
    // Values that are objects may have a `reflect` property, which
    // signals that the value describes property control metadata.
    // In metadata objects, the prototype default value (if any)
    // is encoded in the `value` property.
    //
    // publish: {
    //   foo: 5,
    //   bar: {value: true, reflect: true},
    //   zot: {}
    // }
    //
    // `reflect` metadata property controls whether changes to the property
    // are reflected back to the attribute (default false).
    //
    // A value is stored on the prototype unless it's === `undefined`,
    // in which case the base chain is checked for a value.
    // If the basal value is also undefined, `null` is stored on the prototype.
    //
    // The reflection data is stored on another prototype object, `reflect`
    // which also can be specified directly.
    //
    // reflect: {
    //   foo: true
    // }
    //
    requireProperties: function(propertyInfos, prototype, base) {
      // per-prototype storage for reflected properties
      prototype.reflect = prototype.reflect || {};
      // ensure a prototype value for each property
      // and update the property's reflect to attribute status
      for (var n in propertyInfos) {
        var value = propertyInfos[n];
        // value has metadata if it has a `reflect` property
        if (value && value.reflect !== undefined) {
          prototype.reflect[n] = Boolean(value.reflect);
          value = value.value;
        }
        // only set a value if one is specified
        if (value !== undefined) {
          prototype[n] = value;
        }
      }
    },
    lowerCaseMap: function(properties) {
      var map = {};
      for (var n in properties) {
        map[n.toLowerCase()] = n;
      }
      return map;
    },
    createPropertyAccessor: function(name, ignoreWrites) {
      var proto = this.prototype;

      var privateName = name + '_';
      var privateObservable  = name + 'Observable_';
      proto[privateName] = proto[name];

      Object.defineProperty(proto, name, {
        get: function() {
          var observable = this[privateObservable];
          if (observable)
            observable.deliver();

          return this[privateName];
        },
        set: function(value) {
          if (ignoreWrites) {
            return this[privateName];
          }

          var observable = this[privateObservable];
          if (observable) {
            observable.setValue(value);
            return;
          }

          var oldValue = this[privateName];
          this[privateName] = value;
          this.emitPropertyChangeRecord(name, value, oldValue);

          return value;
        },
        configurable: true
      });
    },
    createPropertyAccessors: function(prototype) {
      var n$ = prototype._computedNames;
      if (n$ && n$.length) {
        for (var i=0, l=n$.length, n, fn; (i<l) && (n=n$[i]); i++) {
          this.createPropertyAccessor(n, true);
        }
      }
      var n$ = prototype._publishNames;
      if (n$ && n$.length) {
        for (var i=0, l=n$.length, n, fn; (i<l) && (n=n$[i]); i++) {
          // If the property is computed and published, the accessor is created
          // above.
          if (!prototype.computed || !prototype.computed[n]) {
            this.createPropertyAccessor(n);
          }
        }
      }
    },
    // This list contains some property names that people commonly want to use,
    // but won't work because of Chrome/Safari bugs. It isn't an exhaustive
    // list. In particular it doesn't contain any property names found on
    // subtypes of HTMLElement (e.g. name, value). Rather it attempts to catch
    // some common cases.
    propertyNameBlacklist: {
      children: 1,
      'class': 1,
      id: 1,
      hidden: 1,
      style: 1,
      title: 1,
    }
  };

  // exports

  scope.api.declaration.properties = properties;

})(Polymer);

(function(scope) {

  // magic words

  var ATTRIBUTES_ATTRIBUTE = 'attributes';
  var ATTRIBUTES_REGEX = /\s|,/;

  // attributes api

  var attributes = {

    inheritAttributesObjects: function(prototype) {
      // chain our lower-cased publish map to the inherited version
      this.inheritObject(prototype, 'publishLC');
      // chain our instance attributes map to the inherited version
      this.inheritObject(prototype, '_instanceAttributes');
    },

    publishAttributes: function(prototype, base) {
      // merge names from 'attributes' attribute into the 'publish' object
      var attributes = this.getAttribute(ATTRIBUTES_ATTRIBUTE);
      if (attributes) {
        // create a `publish` object if needed.
        // the `publish` object is only relevant to this prototype, the
        // publishing logic in `declaration/properties.js` is responsible for
        // managing property values on the prototype chain.
        // TODO(sjmiles): the `publish` object is later chained to it's
        //                ancestor object, presumably this is only for
        //                reflection or other non-library uses.
        var publish = prototype.publish || (prototype.publish = {});
        // names='a b c' or names='a,b,c'
        var names = attributes.split(ATTRIBUTES_REGEX);
        // record each name for publishing
        for (var i=0, l=names.length, n; i<l; i++) {
          // remove excess ws
          n = names[i].trim();
          // looks weird, but causes n to exist on `publish` if it does not;
          // a more careful test would need expensive `in` operator
          if (n && publish[n] === undefined) {
            publish[n] = undefined;
          }
        }
      }
    },

    // record clonable attributes from <element>
    accumulateInstanceAttributes: function() {
      // inherit instance attributes
      var clonable = this.prototype._instanceAttributes;
      // merge attributes from element
      var a$ = this.attributes;
      for (var i=0, l=a$.length, a; (i<l) && (a=a$[i]); i++) {
        if (this.isInstanceAttribute(a.name)) {
          clonable[a.name] = a.value;
        }
      }
    },

    isInstanceAttribute: function(name) {
      return !this.blackList[name] && name.slice(0,3) !== 'on-';
    },

    // do not clone these attributes onto instances
    blackList: {
      name: 1,
      'extends': 1,
      constructor: 1,
      noscript: 1,
      assetpath: 1,
      'cache-csstext': 1
    }

  };

  // add ATTRIBUTES_ATTRIBUTE to the blacklist
  attributes.blackList[ATTRIBUTES_ATTRIBUTE] = 1;

  // exports

  scope.api.declaration.attributes = attributes;

})(Polymer);

(function(scope) {

  // imports
  var events = scope.api.declaration.events;

  var syntax = new PolymerExpressions();
  var prepareBinding = syntax.prepareBinding;

  // Polymer takes a first crack at the binding to see if it's a declarative
  // event handler.
  syntax.prepareBinding = function(pathString, name, node) {
    return events.prepareEventBinding(pathString, name, node) ||
           prepareBinding.call(syntax, pathString, name, node);
  };

  // declaration api supporting mdv
  var mdv = {
    syntax: syntax,
    fetchTemplate: function() {
      return this.querySelector('template');
    },
    templateContent: function() {
      var template = this.fetchTemplate();
      return template && template.content;
    },
    installBindingDelegate: function(template) {
      if (template) {
        template.bindingDelegate = this.syntax;
      }
    }
  };

  // exports
  scope.api.declaration.mdv = mdv;

})(Polymer);

(function(scope) {

  // imports

  var api = scope.api;
  var isBase = scope.isBase;
  var extend = scope.extend;

  var hasShadowDOMPolyfill = window.ShadowDOMPolyfill;

  // prototype api

  var prototype = {

    register: function(name, extendeeName) {
      // build prototype combining extendee, Polymer base, and named api
      this.buildPrototype(name, extendeeName);
      // register our custom element with the platform
      this.registerPrototype(name, extendeeName);
      // reference constructor in a global named by 'constructor' attribute
      this.publishConstructor();
    },

    buildPrototype: function(name, extendeeName) {
      // get our custom prototype (before chaining)
      var extension = scope.getRegisteredPrototype(name);
      // get basal prototype
      var base = this.generateBasePrototype(extendeeName);
      // implement declarative features
      this.desugarBeforeChaining(extension, base);
      // join prototypes
      this.prototype = this.chainPrototypes(extension, base);
      // more declarative features
      this.desugarAfterChaining(name, extendeeName);
    },

    desugarBeforeChaining: function(prototype, base) {
      // back reference declaration element
      // TODO(sjmiles): replace `element` with `elementElement` or `declaration`
      prototype.element = this;
      // transcribe `attributes` declarations onto own prototype's `publish`
      this.publishAttributes(prototype, base);
      // `publish` properties to the prototype and to attribute watch
      this.publishProperties(prototype, base);
      // infer observers for `observe` list based on method names
      this.inferObservers(prototype);
      // desugar compound observer syntax, e.g. 'a b c'
      this.explodeObservers(prototype);
    },

    chainPrototypes: function(prototype, base) {
      // chain various meta-data objects to inherited versions
      this.inheritMetaData(prototype, base);
      // chain custom api to inherited
      var chained = this.chainObject(prototype, base);
      // x-platform fixup
      ensurePrototypeTraversal(chained);
      return chained;
    },

    inheritMetaData: function(prototype, base) {
      // chain observe object to inherited
      this.inheritObject('observe', prototype, base);
      // chain publish object to inherited
      this.inheritObject('publish', prototype, base);
      // chain reflect object to inherited
      this.inheritObject('reflect', prototype, base);
      // chain our lower-cased publish map to the inherited version
      this.inheritObject('_publishLC', prototype, base);
      // chain our instance attributes map to the inherited version
      this.inheritObject('_instanceAttributes', prototype, base);
      // chain our event delegates map to the inherited version
      this.inheritObject('eventDelegates', prototype, base);
    },

    // implement various declarative features
    desugarAfterChaining: function(name, extendee) {
      // build side-chained lists to optimize iterations
      this.optimizePropertyMaps(this.prototype);
      this.createPropertyAccessors(this.prototype);
      // install mdv delegate on template
      this.installBindingDelegate(this.fetchTemplate());
      // install external stylesheets as if they are inline
      this.installSheets();
      // adjust any paths in dom from imports
      this.resolveElementPaths(this);
      // compile list of attributes to copy to instances
      this.accumulateInstanceAttributes();
      // parse on-* delegates declared on `this` element
      this.parseHostEvents();
      //
      // install a helper method this.resolvePath to aid in
      // setting resource urls. e.g.
      // this.$.image.src = this.resolvePath('images/foo.png')
      this.addResolvePathApi();
      // under ShadowDOMPolyfill, transforms to approximate missing CSS features
      if (hasShadowDOMPolyfill) {
        WebComponents.ShadowCSS.shimStyling(this.templateContent(), name,
          extendee);
      }
      // allow custom element access to the declarative context
      if (this.prototype.registerCallback) {
        this.prototype.registerCallback(this);
      }
    },

    // if a named constructor is requested in element, map a reference
    // to the constructor to the given symbol
    publishConstructor: function() {
      var symbol = this.getAttribute('constructor');
      if (symbol) {
        window[symbol] = this.ctor;
      }
    },

    // build prototype combining extendee, Polymer base, and named api
    generateBasePrototype: function(extnds) {
      var prototype = this.findBasePrototype(extnds);
      if (!prototype) {
        // create a prototype based on tag-name extension
        var prototype = HTMLElement.getPrototypeForTag(extnds);
        // insert base api in inheritance chain (if needed)
        prototype = this.ensureBaseApi(prototype);
        // memoize this base
        memoizedBases[extnds] = prototype;
      }
      return prototype;
    },

    findBasePrototype: function(name) {
      return memoizedBases[name];
    },

    // install Polymer instance api into prototype chain, as needed
    ensureBaseApi: function(prototype) {
      if (prototype.PolymerBase) {
        return prototype;
      }
      var extended = Object.create(prototype);
      // we need a unique copy of base api for each base prototype
      // therefore we 'extend' here instead of simply chaining
      api.publish(api.instance, extended);
      // TODO(sjmiles): sharing methods across prototype chains is
      // not supported by 'super' implementation which optimizes
      // by memoizing prototype relationships.
      // Probably we should have a version of 'extend' that is
      // share-aware: it could study the text of each function,
      // look for usage of 'super', and wrap those functions in
      // closures.
      // As of now, there is only one problematic method, so
      // we just patch it manually.
      // To avoid re-entrancy problems, the special super method
      // installed is called `mixinSuper` and the mixin method
      // must use this method instead of the default `super`.
      this.mixinMethod(extended, prototype, api.instance.mdv, 'bind');
      // return buffed-up prototype
      return extended;
    },

    mixinMethod: function(extended, prototype, api, name) {
      var $super = function(args) {
        return prototype[name].apply(this, args);
      };
      extended[name] = function() {
        this.mixinSuper = $super;
        return api[name].apply(this, arguments);
      }
    },

    // ensure prototype[name] inherits from a prototype.prototype[name]
    inheritObject: function(name, prototype, base) {
      // require an object
      var source = prototype[name] || {};
      // chain inherited properties onto a new object
      prototype[name] = this.chainObject(source, base[name]);
    },

    // register 'prototype' to custom element 'name', store constructor
    registerPrototype: function(name, extendee) {
      var info = {
        prototype: this.prototype
      }
      // native element must be specified in extends
      var typeExtension = this.findTypeExtension(extendee);
      if (typeExtension) {
        info.extends = typeExtension;
      }
      // register the prototype with HTMLElement for name lookup
      HTMLElement.register(name, this.prototype);
      // register the custom type
      this.ctor = document.registerElement(name, info);
    },

    findTypeExtension: function(name) {
      if (name && name.indexOf('-') < 0) {
        return name;
      } else {
        var p = this.findBasePrototype(name);
        if (p.element) {
          return this.findTypeExtension(p.element.extends);
        }
      }
    }

  };

  // memoize base prototypes
  var memoizedBases = {};

  // implementation of 'chainObject' depends on support for __proto__
  if (Object.__proto__) {
    prototype.chainObject = function(object, inherited) {
      if (object && inherited && object !== inherited) {
        object.__proto__ = inherited;
      }
      return object;
    }
  } else {
    prototype.chainObject = function(object, inherited) {
      if (object && inherited && object !== inherited) {
        var chained = Object.create(inherited);
        object = extend(chained, object);
      }
      return object;
    }
  }

  // On platforms that do not support __proto__ (versions of IE), the prototype
  // chain of a custom element is simulated via installation of __proto__.
  // Although custom elements manages this, we install it here so it's
  // available during desugaring.
  function ensurePrototypeTraversal(prototype) {
    if (!Object.__proto__) {
      var ancestor = Object.getPrototypeOf(prototype);
      prototype.__proto__ = ancestor;
      if (isBase(ancestor)) {
        ancestor.__proto__ = Object.getPrototypeOf(ancestor);
      }
    }
  }

  // exports

  api.declaration.prototype = prototype;

})(Polymer);

(function(scope) {

  /*

    Elements are added to a registration queue so that they register in
    the proper order at the appropriate time. We do this for a few reasons:

    * to enable elements to load resources (like stylesheets)
    asynchronously. We need to do this until the platform provides an efficient
    alternative. One issue is that remote @import stylesheets are
    re-fetched whenever stamped into a shadowRoot.

    * to ensure elements loaded 'at the same time' (e.g. via some set of
    imports) are registered as a batch. This allows elements to be enured from
    upgrade ordering as long as they query the dom tree 1 task after
    upgrade (aka domReady). This is a performance tradeoff. On the one hand,
    elements that could register while imports are loading are prevented from
    doing so. On the other, grouping upgrades into a single task means less
    incremental work (for example style recalcs),  Also, we can ensure the
    document is in a known state at the single quantum of time when
    elements upgrade.

  */
  var queue = {

    // tell the queue to wait for an element to be ready
    wait: function(element) {
      if (!element.__queue) {
        element.__queue = {};
        elements.push(element);
      }
    },

    // enqueue an element to the next spot in the queue.
    enqueue: function(element, check, go) {
      var shouldAdd = element.__queue && !element.__queue.check;
      if (shouldAdd) {
        queueForElement(element).push(element);
        element.__queue.check = check;
        element.__queue.go = go;
      }
      return (this.indexOf(element) !== 0);
    },

    indexOf: function(element) {
      var i = queueForElement(element).indexOf(element);
      if (i >= 0 && document.contains(element)) {
        i += (HTMLImports.useNative || HTMLImports.ready) ?
          importQueue.length : 1e9;
      }
      return i;
    },

    // tell the queue an element is ready to be registered
    go: function(element) {
      var readied = this.remove(element);
      if (readied) {
        element.__queue.flushable = true;
        this.addToFlushQueue(readied);
        this.check();
      }
    },

    remove: function(element) {
      var i = this.indexOf(element);
      if (i !== 0) {
        //console.warn('queue order wrong', i);
        return;
      }
      return queueForElement(element).shift();
    },

    check: function() {
      // next
      var element = this.nextElement();
      if (element) {
        element.__queue.check.call(element);
      }
      if (this.canReady()) {
        this.ready();
        return true;
      }
    },

    nextElement: function() {
      return nextQueued();
    },

    canReady: function() {
      return !this.waitToReady && this.isEmpty();
    },

    isEmpty: function() {
      for (var i=0, l=elements.length, e; (i<l) &&
          (e=elements[i]); i++) {
        if (e.__queue && !e.__queue.flushable) {
          return;
        }
      }
      return true;
    },

    addToFlushQueue: function(element) {
      flushQueue.push(element);
    },

    flush: function() {
      // prevent re-entrance
      if (this.flushing) {
        return;
      }
      this.flushing = true;
      var element;
      while (flushQueue.length) {
        element = flushQueue.shift();
        element.__queue.go.call(element);
        element.__queue = null;
      }
      this.flushing = false;
    },

    ready: function() {
      // TODO(sorvell): As an optimization, turn off CE polyfill upgrading
      // while registering. This way we avoid having to upgrade each document
      // piecemeal per registration and can instead register all elements
      // and upgrade once in a batch. Without this optimization, upgrade time
      // degrades significantly when SD polyfill is used. This is mainly because
      // querying the document tree for elements is slow under the SD polyfill.
      var polyfillWasReady = CustomElements.ready;
      CustomElements.ready = false;
      this.flush();
      if (!CustomElements.useNative) {
        CustomElements.upgradeDocumentTree(document);
      }
      CustomElements.ready = polyfillWasReady;
      Polymer.flush();
      requestAnimationFrame(this.flushReadyCallbacks);
    },

    addReadyCallback: function(callback) {
      if (callback) {
        readyCallbacks.push(callback);
      }
    },

    flushReadyCallbacks: function() {
      if (readyCallbacks) {
        var fn;
        while (readyCallbacks.length) {
          fn = readyCallbacks.shift();
          fn();
        }
      }
    },

    /**
    Returns a list of elements that have had polymer-elements created but
    are not yet ready to register. The list is an array of element definitions.
    */
    waitingFor: function() {
      var e$ = [];
      for (var i=0, l=elements.length, e; (i<l) &&
          (e=elements[i]); i++) {
        if (e.__queue && !e.__queue.flushable) {
          e$.push(e);
        }
      }
      return e$;
    },

    waitToReady: true

  };

  var elements = [];
  var flushQueue = [];
  var importQueue = [];
  var mainQueue = [];
  var readyCallbacks = [];

  function queueForElement(element) {
    return document.contains(element) ? mainQueue : importQueue;
  }

  function nextQueued() {
    return importQueue.length ? importQueue[0] : mainQueue[0];
  }

  function whenReady(callback) {
    queue.waitToReady = true;
    Polymer.endOfMicrotask(function() {
      HTMLImports.whenReady(function() {
        queue.addReadyCallback(callback);
        queue.waitToReady = false;
        queue.check();
    });
    });
  }

  /**
    Forces polymer to register any pending elements. Can be used to abort
    waiting for elements that are partially defined.
    @param timeout {Integer} Optional timeout in milliseconds
  */
  function forceReady(timeout) {
    if (timeout === undefined) {
      queue.ready();
      return;
    }
    var handle = setTimeout(function() {
      queue.ready();
    }, timeout);
    Polymer.whenReady(function() {
      clearTimeout(handle);
    });
  }

  // exports
  scope.elements = elements;
  scope.waitingFor = queue.waitingFor.bind(queue);
  scope.forceReady = forceReady;
  scope.queue = queue;
  scope.whenReady = scope.whenPolymerReady = whenReady;
})(Polymer);

(function(scope) {

  // imports

  var extend = scope.extend;
  var api = scope.api;
  var queue = scope.queue;
  var whenReady = scope.whenReady;
  var getRegisteredPrototype = scope.getRegisteredPrototype;
  var waitingForPrototype = scope.waitingForPrototype;

  // declarative implementation: <polymer-element>

  var prototype = extend(Object.create(HTMLElement.prototype), {

    createdCallback: function() {
      if (this.getAttribute('name')) {
        this.init();
      }
    },

    init: function() {
      // fetch declared values
      this.name = this.getAttribute('name');
      this.extends = this.getAttribute('extends');
      queue.wait(this);
      // initiate any async resource fetches
      this.loadResources();
      // register when all constraints are met
      this.registerWhenReady();
    },

    // TODO(sorvell): we currently queue in the order the prototypes are
    // registered, but we should queue in the order that polymer-elements
    // are registered. We are currently blocked from doing this based on
    // crbug.com/395686.
    registerWhenReady: function() {
     if (this.registered
       || this.waitingForPrototype(this.name)
       || this.waitingForQueue()
       || this.waitingForResources()) {
          return;
      }
      queue.go(this);
    },

    _register: function() {
      //console.log('registering', this.name);
      // warn if extending from a custom element not registered via Polymer
      if (isCustomTag(this.extends) && !isRegistered(this.extends)) {
        console.warn('%s is attempting to extend %s, an unregistered element ' +
            'or one that was not registered with Polymer.', this.name,
            this.extends);
      }
      this.register(this.name, this.extends);
      this.registered = true;
    },

    waitingForPrototype: function(name) {
      if (!getRegisteredPrototype(name)) {
        // then wait for a prototype
        waitingForPrototype(name, this);
        // emulate script if user is not supplying one
        this.handleNoScript(name);
        // prototype not ready yet
        return true;
      }
    },

    handleNoScript: function(name) {
      // if explicitly marked as 'noscript'
      if (this.hasAttribute('noscript') && !this.noscript) {
        this.noscript = true;
        // imperative element registration
        Polymer(name);
      }
    },

    waitingForResources: function() {
      return this._needsResources;
    },

    // NOTE: Elements must be queued in proper order for inheritance/composition
    // dependency resolution. Previously this was enforced for inheritance,
    // and by rule for composition. It's now entirely by rule.
    waitingForQueue: function() {
      return queue.enqueue(this, this.registerWhenReady, this._register);
    },

    loadResources: function() {
      this._needsResources = true;
      this.loadStyles(function() {
        this._needsResources = false;
        this.registerWhenReady();
      }.bind(this));
    }

  });

  // semi-pluggable APIs

  // TODO(sjmiles): should be fully pluggable (aka decoupled, currently
  // the various plugins are allowed to depend on each other directly)
  api.publish(api.declaration, prototype);

  // utility and bookkeeping

  function isRegistered(name) {
    return Boolean(HTMLElement.getPrototypeForTag(name));
  }

  function isCustomTag(name) {
    return (name && name.indexOf('-') >= 0);
  }

  // boot tasks

  whenReady(function() {
    document.body.removeAttribute('unresolved');
    document.dispatchEvent(
      new CustomEvent('polymer-ready', {bubbles: true})
    );
  });

  // register polymer-element with document

  document.registerElement('polymer-element', {prototype: prototype});

})(Polymer);

(function(scope) {

/**
 * @class Polymer
 */

var whenReady = scope.whenReady;

/**
 * Loads the set of HTMLImports contained in `node`. Notifies when all
 * the imports have loaded by calling the `callback` function argument.
 * This method can be used to lazily load imports. For example, given a
 * template:
 *
 *     <template>
 *       <link rel="import" href="my-import1.html">
 *       <link rel="import" href="my-import2.html">
 *     </template>
 *
 *     Polymer.importElements(template.content, function() {
 *       console.log('imports lazily loaded');
 *     });
 *
 * @method importElements
 * @param {Node} node Node containing the HTMLImports to load.
 * @param {Function} callback Callback called when all imports have loaded.
 */
function importElements(node, callback) {
  if (node) {
    document.head.appendChild(node);
    whenReady(callback);
  } else if (callback) {
    callback();
  }
}

/**
 * Loads an HTMLImport for each url specified in the `urls` array.
 * Notifies when all the imports have loaded by calling the `callback`
 * function argument. This method can be used to lazily load imports.
 * For example,
 *
 *     Polymer.import(['my-import1.html', 'my-import2.html'], function() {
 *       console.log('imports lazily loaded');
 *     });
 *
 * @method import
 * @param {Array} urls Array of urls to load as HTMLImports.
 * @param {Function} callback Callback called when all imports have loaded.
 */
function _import(urls, callback) {
  if (urls && urls.length) {
      var frag = document.createDocumentFragment();
      for (var i=0, l=urls.length, url, link; (i<l) && (url=urls[i]); i++) {
        link = document.createElement('link');
        link.rel = 'import';
        link.href = url;
        frag.appendChild(link);
      }
      importElements(frag, callback);
  } else if (callback) {
    callback();
  }
}

// exports
scope.import = _import;
scope.importElements = importElements;

})(Polymer);

/**
 * The `auto-binding` element extends the template element. It provides a quick
 * and easy way to do data binding without the need to setup a model.
 * The `auto-binding` element itself serves as the model and controller for the
 * elements it contains. Both data and event handlers can be bound.
 *
 * The `auto-binding` element acts just like a template that is bound to
 * a model. It stamps its content in the dom adjacent to itself. When the
 * content is stamped, the `template-bound` event is fired.
 *
 * Example:
 *
 *     <template is="auto-binding">
 *       <div>Say something: <input value="{{value}}"></div>
 *       <div>You said: {{value}}</div>
 *       <button on-tap="{{buttonTap}}">Tap me!</button>
 *     </template>
 *     <script>
 *       var template = document.querySelector('template');
 *       template.value = 'something';
 *       template.buttonTap = function() {
 *         console.log('tap!');
 *       };
 *     <\/script>
 *
 * @module Polymer
 * @status stable
*/

(function() {

  var element = document.createElement('polymer-element');
  element.setAttribute('name', 'auto-binding');
  element.setAttribute('extends', 'template');
  element.init();

  Polymer('auto-binding', {

    createdCallback: function() {
      this.syntax = this.bindingDelegate = this.makeSyntax();
      // delay stamping until polymer-ready so that auto-binding is not
      // required to load last.
      Polymer.whenPolymerReady(function() {
        this.model = this;
        this.setAttribute('bind', '');
        // we don't bother with an explicit signal here, we could ust a MO
        // if necessary
        this.async(function() {
          // note: this will marshall *all* the elements in the parentNode
          // rather than just stamped ones. We'd need to use createInstance
          // to fix this or something else fancier.
          this.marshalNodeReferences(this.parentNode);
          // template stamping is asynchronous so stamping isn't complete
          // by polymer-ready; fire an event so users can use stamped elements
          this.fire('template-bound');
        });
      }.bind(this));
    },

    makeSyntax: function() {
      var events = Object.create(Polymer.api.declaration.events);
      var self = this;
      events.findController = function() { return self.model; };

      var syntax = new PolymerExpressions();
      var prepareBinding = syntax.prepareBinding;
      syntax.prepareBinding = function(pathString, name, node) {
        return events.prepareEventBinding(pathString, name, node) ||
               prepareBinding.call(syntax, pathString, name, node);
      };
      return syntax;
    }

  });

})();
</script>
    <!-- XUI Utilities -->
<polymer-element name="xui-utils-hash">
	<script>/* globals Polymer */

(function()
{
	'use strict';

	var generatedHashes = [],
		lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' +
				 '0123456789';

	new Polymer(
	{
		publish:
		{
			value:  { value: '', reflect: true },
			length: 8,
			initial: ''
		},

		ready: function()
		{
			this.generateHash();
		},

		lengthChanged: function()
		{
			this.ready();
		},

		initialChanged: function()
		{
			this.ready();
		},

		generateHash: function()
		{
			var hash = this.initial;

		    for(var i = 0; i < this.length; i++)
		    {
		        hash += lookup.charAt(Math.floor(Math.random() * lookup.length));
		    }

		    if (generatedHashes.indexOf(hash) >= 0)
			{
				return this.generateHash(this.length);
			}

		    this.value = hash;
		    generatedHashes.push(this.value);
		}
	});
})();



</script>
</polymer-element>

<polymer-element name="xui-button">

    <template>
    	<style>*
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

* /deep/ *
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

::-webkit-scrollbar,
::-webkit-scrollbar-track
{
    width: 1.2em;
    height: 1.2em;
    background-color : #000;
}

::-webkit-scrollbar-thumb
{
    width: 1em;
    height: 1em;
    background-color : #393939;
    border: 0.1em solid #000;
}

::-webkit-scrollbar-thumb:vertical
{
    border-left: none;
}

::-webkit-scrollbar-thumb:horizontal
{
    border-top: none;
}

::-webkit-scrollbar-thumb:hover
{
    background-color : #EEE;
}

::-webkit-scrollbar-button
{
    width: 1em;
    height: 1em;
    background-color: #000;
    background-repeat: no-repeat;
    background-position: center;
}

::-webkit-scrollbar-button:vertical:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDbCysvpAqQv4gYY8BGIJSrwgB8TbgYbwUBIGBkC8ekBj4QIQh5JrwCMg9jx27NgXXApY8Gj+CNQoT8h5jKN5gQEgwAAAIhV/ZWnXrQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDXj//v0HSl3ADzTkIRBLUOIFOSDeDjSEh5IwMADi1QMaCxeAOJRcAx4BsaegoOAXXApY8Gj+CNQoT8h5jKN5gQEgwABHnBm9Hh2Q3AAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF1JREFUeNpi/P//PwMlgImBQjBEDLCysvqAS46FgEYJIHUSiPlJdgFQMw+Q2g7EcuR6YTUQGwxoIIYC8QWyDTh27NgXIOUJxI/wmgBKyoSwpaXlB1xyjKN5gQEgwABgXz/D96CahwAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF5JREFUeNpi/P//PwMlgImBQjBEDHj//v0HXHIsBDRKAKmTQMxPsguAmnmA1HYgliPXC6uB2GBAAzEUiC+QbYCgoOAXIOUJxI/wmgBKyoTwu3fvPuCSYxzNCwwAAQYAvFlGICKAHEEAAAAASUVORK5CYII=");
}</style>
        <style>:host
{
	display: inline-block;
	height: 2.2em;
	min-width: 10em;
}

img
{
	vertical-align: middle;
}

button
{
	background-color: #191919;
	border: 0.1em solid #555555;
	cursor: pointer;
	color: #FFF;
	padding: 0 2em;
	white-space: nowrap;
    font-size: 1.2em;
    outline: none;
    display: inline-block;
    width: 100%;
    height: 100%;
}

button:focus,
button:hover
{
	background-color: #043151;
	border: 0.1em solid #EEE;
	cursor: pointer;
}

button:disabled
{
	background-color: #000;
	border-color: #555;
	cursor: default;
	color: #555;
}

button
{
	line-height: 1.2em;
}</style>

        <button id="button"><content></content></button>
    </template>

    <script>/* globals Polymer */

(function()
{
	'use strict';

	/**
	 * Creates a button
	 *
	 * @class xui-button
	 * @constructor
	 *
	 * @example
	 *     <xui-button>text</xui-button>
	 */
	new Polymer(
	{
	    publish:
	    {
	        icon    : '',
	        disabled: { value: false, reflect: true }
	    },

	    disabledChanged: function()
	    {
	        this.$.button.disabled = this.disabled;
	    }
	});

})();</script>
</polymer-element>
<polymer-element name="xui-checkbox">

    <template>
    	<style>*
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

* /deep/ *
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

::-webkit-scrollbar,
::-webkit-scrollbar-track
{
    width: 1.2em;
    height: 1.2em;
    background-color : #000;
}

::-webkit-scrollbar-thumb
{
    width: 1em;
    height: 1em;
    background-color : #393939;
    border: 0.1em solid #000;
}

::-webkit-scrollbar-thumb:vertical
{
    border-left: none;
}

::-webkit-scrollbar-thumb:horizontal
{
    border-top: none;
}

::-webkit-scrollbar-thumb:hover
{
    background-color : #EEE;
}

::-webkit-scrollbar-button
{
    width: 1em;
    height: 1em;
    background-color: #000;
    background-repeat: no-repeat;
    background-position: center;
}

::-webkit-scrollbar-button:vertical:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDbCysvpAqQv4gYY8BGIJSrwgB8TbgYbwUBIGBkC8ekBj4QIQh5JrwCMg9jx27NgXXApY8Gj+CNQoT8h5jKN5gQEgwAAAIhV/ZWnXrQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDXj//v0HSl3ADzTkIRBLUOIFOSDeDjSEh5IwMADi1QMaCxeAOJRcAx4BsaegoOAXXApY8Gj+CNQoT8h5jKN5gQEgwABHnBm9Hh2Q3AAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF1JREFUeNpi/P//PwMlgImBQjBEDLCysvqAS46FgEYJIHUSiPlJdgFQMw+Q2g7EcuR6YTUQGwxoIIYC8QWyDTh27NgXIOUJxI/wmgBKyoSwpaXlB1xyjKN5gQEgwABgXz/D96CahwAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF5JREFUeNpi/P//PwMlgImBQjBEDHj//v0HXHIsBDRKAKmTQMxPsguAmnmA1HYgliPXC6uB2GBAAzEUiC+QbYCgoOAXIOUJxI/wmgBKyoTwu3fvPuCSYxzNCwwAAQYAvFlGICKAHEEAAAAASUVORK5CYII=");
}</style>
        <style>input, label
{
    cursor: default;
    color: #555;

    font-size: 1.2em;
    vertical-align: middle;
    display: inline-block;
}

input:not(:disabled),
input:not(:disabled) + label
{
    cursor: pointer;
    color: #EEE;
}

input
{
    -webkit-appearance: none;
    display: inline-block;
    width: 18px;
    height: 17px;
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAARCAIAAABfOGuuAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAC1JREFUeNpiDA0NZSAdsADxnj17SNLj4uLCxEAWGNU2qm2YaGOBZARStQEEGAAt0QTxi2nF1wAAAABJRU5ErkJggg==");
}

input:checked
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAARCAIAAABfOGuuAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAARVJREFUeNpiDA0NZSAdsADxnj17SNLj4uLCxEAWIFYbLy+vpaUladr09PTmz5+vpaWF4jf8wNTUtKmpiYWF5evXr8TapqysXF9fD9QDZEtISBCljZOTs7q6mp2dHcj++PHjtWvXcGqzs7MrLS2FsGNiYmRlZYGMGzdupKWl7dq1C4vfNDQ0srOzgSSQfeTIkVevXoWEhADZZ8+ebWxs/P79O3p0Q8DTp09v374N0ZaRkfH8+XMmJiagPUC//fz5E2e8ff78edKkSVlZWUB7pKSkjI2Nnz17VlNTg6kHi9+AFubm5t6/f//Pnz8NDQ3AkMCZJtHAu3fvgKFiaGgI1Exa4gJacuDAASqkSSyOBGYEUrUBBBgAS/FqqBG/u1cAAAAASUVORK5CYII=");
}

input:focus,
input:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAARCAIAAABfOGuuAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACtJREFUeNpifPfuHQPpgAWIlZWVSdJz9+5dJgaywKi2UW3DRBsjefkNIMAAzEcIt4FpKZoAAAAASUVORK5CYII=");
}

input:checked:focus,
input:checked:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAARCAIAAABfOGuuAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQhJREFUeNqskj8LRVAYxu+VksEqi0lKBmUwWHwKo1lKbCaDP1/E9zAZrFYpyYQyKIOkDPcty/1/0X3rnJ7l13Oe9zzXYRguxweFwzDMIaaqKuRyavZiBEHIsnwMEwQhiiKe5x+yfR9JksIwRFF0mqa9brAtz/OAAU1R1C4Mx3HXdTEMAz2OY57nHzFFURzH2bSmaTRNgyiKQtf1OI7fZOM4zjRNuEGnadr3vaqqoLMsC4Jgnufn796maZqyLDfMMIyu6xAEAR/ItizL06OuUK77lrAs6/s+SZKg27a1bRtS/W4JGFqWVdf1uq7AvzIf/w38YSuiKAJ8rFxgkiTJHzr5ZiUnsJsAAwCWpWy0pF6v0AAAAABJRU5ErkJggg==");
}

input:disabled
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAARCAYAAADQWvz5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADJJREFUeNpiZGBg+M9ABcACIv7//89IiSGMjIz/mRioBEYNGjVo1KAhZhAjtcojgAADAFvYBiHjVxzZAAAAAElFTkSuQmCC");
}

input:checked:disabled
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAARCAYAAADQWvz5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAALJJREFUeNpiZGBg+M9AJUANg/4zUaBZDojZKHWRPRA/B2JmZDNINSgTiP8A8St0x5BiUDhUPQh/JtcgFajm/0hYlxiDONH4h5EMAHnLjxgXJUMVw2yMQjLkCRCrY0tCyAYpAvFJJE3roFF8D8kQRVxpEd1FIdCohRk2E0p/A2IDfIkam9dEgfgYWsCGEMod+AJ7L5KrGMg1CAT4gXgLEPNQahBdMi3EhP8QdzBSqzwCCDAAFihGuiigV8QAAAAASUVORK5CYII=");
}
</style>

        <xui-utils-hash value="{{ hash }}" initial="checkbox-"></xui-utils-hash>

        <input type="checkbox" id="{{ hash }}" on-change="{{ checkboxChanged }}">
        <label for="{{ hash }}"><content></content></label>
    </template>

    <script>/* globals Polymer */

(function()
{
    'use strict';

    new Polymer(
    {
        publish:
        {
            checked : { value: false, reflect: true },
            disabled: { value: false, reflect: true }
        },

        ready: function()
        {
            this.checkbox = this.shadowRoot.querySelector('input');
        },

        checkedChanged: function()
        {
            this.checkbox.checked = this.checked;
        },

        disabledChanged: function()
        {
            this.checkbox.disabled = this.disabled;
        },

        checkboxChanged: function()
        {
            this.checked = this.checkbox.checked;

            this.fire('change');
        }
    });
})();
</script>
</polymer-element>
<polymer-element name="xui-option">

    <template>
    	<style>*
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

* /deep/ *
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

::-webkit-scrollbar,
::-webkit-scrollbar-track
{
    width: 1.2em;
    height: 1.2em;
    background-color : #000;
}

::-webkit-scrollbar-thumb
{
    width: 1em;
    height: 1em;
    background-color : #393939;
    border: 0.1em solid #000;
}

::-webkit-scrollbar-thumb:vertical
{
    border-left: none;
}

::-webkit-scrollbar-thumb:horizontal
{
    border-top: none;
}

::-webkit-scrollbar-thumb:hover
{
    background-color : #EEE;
}

::-webkit-scrollbar-button
{
    width: 1em;
    height: 1em;
    background-color: #000;
    background-repeat: no-repeat;
    background-position: center;
}

::-webkit-scrollbar-button:vertical:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDbCysvpAqQv4gYY8BGIJSrwgB8TbgYbwUBIGBkC8ekBj4QIQh5JrwCMg9jx27NgXXApY8Gj+CNQoT8h5jKN5gQEgwAAAIhV/ZWnXrQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDXj//v0HSl3ADzTkIRBLUOIFOSDeDjSEh5IwMADi1QMaCxeAOJRcAx4BsaegoOAXXApY8Gj+CNQoT8h5jKN5gQEgwABHnBm9Hh2Q3AAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF1JREFUeNpi/P//PwMlgImBQjBEDLCysvqAS46FgEYJIHUSiPlJdgFQMw+Q2g7EcuR6YTUQGwxoIIYC8QWyDTh27NgXIOUJxI/wmgBKyoSwpaXlB1xyjKN5gQEgwABgXz/D96CahwAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF5JREFUeNpi/P//PwMlgImBQjBEDHj//v0HXHIsBDRKAKmTQMxPsguAmnmA1HYgliPXC6uB2GBAAzEUiC+QbYCgoOAXIOUJxI/wmgBKyoTwu3fvPuCSYxzNCwwAAQYAvFlGICKAHEEAAAAASUVORK5CYII=");
}</style>
    	<style>:host
{
	display: block;
	line-height: 2.2em;
	white-space: nowrap;
	font-size: 1.2em;
	padding: 0 0.5em;
	text-overflow: ellipsis;
  	overflow: hidden;
  	cursor: pointer;
}

:host(:hover)
{
	background-color: #043151;
	color: #EEE;
}
</style>

    	<content></content>
    </template>

    <script>/* globals Polymer */

(function()
{
	'use strict';

	new Polymer(
	{
	    publish:
	    {
	        value: { value: '', reflect: true },
	        data: { value: '', reflect: true }
	    },

	    get label()
	    {
	        return this.innerHTML;
	    }
	});
})();</script>

</polymer-element>
<polymer-element name="xui-option-group">

    <template>
    	<style>*
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

* /deep/ *
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

::-webkit-scrollbar,
::-webkit-scrollbar-track
{
    width: 1.2em;
    height: 1.2em;
    background-color : #000;
}

::-webkit-scrollbar-thumb
{
    width: 1em;
    height: 1em;
    background-color : #393939;
    border: 0.1em solid #000;
}

::-webkit-scrollbar-thumb:vertical
{
    border-left: none;
}

::-webkit-scrollbar-thumb:horizontal
{
    border-top: none;
}

::-webkit-scrollbar-thumb:hover
{
    background-color : #EEE;
}

::-webkit-scrollbar-button
{
    width: 1em;
    height: 1em;
    background-color: #000;
    background-repeat: no-repeat;
    background-position: center;
}

::-webkit-scrollbar-button:vertical:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDbCysvpAqQv4gYY8BGIJSrwgB8TbgYbwUBIGBkC8ekBj4QIQh5JrwCMg9jx27NgXXApY8Gj+CNQoT8h5jKN5gQEgwAAAIhV/ZWnXrQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDXj//v0HSl3ADzTkIRBLUOIFOSDeDjSEh5IwMADi1QMaCxeAOJRcAx4BsaegoOAXXApY8Gj+CNQoT8h5jKN5gQEgwABHnBm9Hh2Q3AAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF1JREFUeNpi/P//PwMlgImBQjBEDLCysvqAS46FgEYJIHUSiPlJdgFQMw+Q2g7EcuR6YTUQGwxoIIYC8QWyDTh27NgXIOUJxI/wmgBKyoSwpaXlB1xyjKN5gQEgwABgXz/D96CahwAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF5JREFUeNpi/P//PwMlgImBQjBEDHj//v0HXHIsBDRKAKmTQMxPsguAmnmA1HYgliPXC6uB2GBAAzEUiC+QbYCgoOAXIOUJxI/wmgBKyoTwu3fvPuCSYxzNCwwAAQYAvFlGICKAHEEAAAAASUVORK5CYII=");
}</style>
    	<style>:host label
{
	display: block;
	line-height: 2.2em;
	white-space: nowrap;
	font-size: 1.2em;
	padding: 0 0.5em;
	text-overflow: ellipsis;
  	overflow: hidden;
  	font-weight: bold;
}

#options
{
	padding-left: 2em;
	position: relative;
	background-color: transparent;
}</style>

    	<label>{{ label }}</label>
    	<div id="options">
    		<content select="xui-option"></content>
    	</div>
    </template>

    <script>/* globals Polymer */

(function()
{
	'use strict';

	new Polymer(
	{
		publish:
		{
			label: { value: '', reflect: true }
		}
	});
})();</script>

</polymer-element>

<polymer-element name="xui-select" tabindex="0">

    <template>
        <style>*
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

* /deep/ *
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

::-webkit-scrollbar,
::-webkit-scrollbar-track
{
    width: 1.2em;
    height: 1.2em;
    background-color : #000;
}

::-webkit-scrollbar-thumb
{
    width: 1em;
    height: 1em;
    background-color : #393939;
    border: 0.1em solid #000;
}

::-webkit-scrollbar-thumb:vertical
{
    border-left: none;
}

::-webkit-scrollbar-thumb:horizontal
{
    border-top: none;
}

::-webkit-scrollbar-thumb:hover
{
    background-color : #EEE;
}

::-webkit-scrollbar-button
{
    width: 1em;
    height: 1em;
    background-color: #000;
    background-repeat: no-repeat;
    background-position: center;
}

::-webkit-scrollbar-button:vertical:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDbCysvpAqQv4gYY8BGIJSrwgB8TbgYbwUBIGBkC8ekBj4QIQh5JrwCMg9jx27NgXXApY8Gj+CNQoT8h5jKN5gQEgwAAAIhV/ZWnXrQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDXj//v0HSl3ADzTkIRBLUOIFOSDeDjSEh5IwMADi1QMaCxeAOJRcAx4BsaegoOAXXApY8Gj+CNQoT8h5jKN5gQEgwABHnBm9Hh2Q3AAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF1JREFUeNpi/P//PwMlgImBQjBEDLCysvqAS46FgEYJIHUSiPlJdgFQMw+Q2g7EcuR6YTUQGwxoIIYC8QWyDTh27NgXIOUJxI/wmgBKyoSwpaXlB1xyjKN5gQEgwABgXz/D96CahwAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF5JREFUeNpi/P//PwMlgImBQjBEDHj//v0HXHIsBDRKAKmTQMxPsguAmnmA1HYgliPXC6uB2GBAAzEUiC+QbYCgoOAXIOUJxI/wmgBKyoTwu3fvPuCSYxzNCwwAAQYAvFlGICKAHEEAAAAASUVORK5CYII=");
}</style>
        <style>*, :host
{
	color: #EEE;
	outline: none;
}

:host
{
	position: relative;
	width: 20em;
	height: 2.2em;
	display: inline-block;
}

#wrap
{
	border: 0.1em solid #000;
	background-color: #393939;
	width: 100%;
	height: 100%;
	display: -webkit-flex;
}

#wrap:hover
{
    background-color: #555;
    color: #eee;
}

:host(:focus) #wrap
{
	background-color: #555;
}

#toggle,
#input
{
	background-color: transparent;
	border: none;
	cursor: pointer;
	display: inline-block;
}

#input
{
	font-size: 1.2em;
	padding: 0.2em 0 0.2em 0.5em;
	text-overflow: ellipsis;
  	overflow: hidden;
  	white-space: nowrap;
  	-webkit-flex: 1;
}

#toggle
{
	width: 2em;
	background-position: center center;
	background-repeat: no-repeat;
	background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFhJREFUeNpiTEtLm8zAwJDDgB3MZQISxUB8EIvkKSDOYvz//z9Denq6KJBzHoiloZKvgdhw5syZT0EmMAAZIAF/IP4FxaEgSbBSkAkwDHRPAhDnI4sBBBgAqFkrWV8limsAAAAASUVORK5CYII=");
}

#wrap:hover #toggle,
:host(:focus) #toggle,
#toggle:hover
{
	background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFtJREFUeNpiPHPmzGQGBoYcBuxgLhOQKAbig1gkTwFxFuP///8Zzp49KwrknAdiaajkayA2NDY2fgoygQHIAAn4A/EvKA4FSYLkwCbAANCkBCDFD5ScCBMDCDAASBocBPGB98YAAAAASUVORK5CYII=");
}

:host(:disabled) #toggle
{
	background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFhJREFUeNpiVFJSmszAwJDDgB3MZQISxUB8EIvkKSDOYvz//z+DsrKyKJBzHoiloZKvgdjw7t27T0EmMAAZIAF/IP4FxaEgSbBSkAkwDHRPAhDnI4sBBBgAR+0qjbdd+UkAAAAASUVORK5CYII=");
	cursor: default;
}

#list
{
	position: absolute;
	top: 100%;
	left: 0;
	display: none;
	margin: 1px 0 0;
	padding: 0;
    z-index: 10;
}

:host(:focus) #list
{
	display: block;
}

#list
{
	max-height: 12em;
	width: 100%;
	border: 0.1em solid #555;
	background-color: #000;
	overflow-y: auto;
	overflow-x: hidden;
}</style>

        <div id="wrap">
		    <input id="input" type="text" value="{{ selected.label }}" placeholder="{{ placeholder }}" readonly>
		    <button id="toggle"></button>
        </div>

        <ul id="list">
        	<content select="xui-option,xui-option-group"></content>
        </ul>
    </template>

    <script>/* globals Polymer */

(function()
{
    'use strict';

    new Polymer(
    {
        publish:
        {
            disabled: { value: false, reflect: true },
            value:    { value: '', reflect: true },
            placeholder: { value: '', reflect: true },
            selected: null,
            name: ''
        },

        eventDelegates:
        {
            click: 'onClick'
        },

        domReady: function()
        {
            this.async(this.valueChanged);
        },

        ready: function()
        {
            this.onMutation(this, this.onContentUpdate);
        },

        valueChanged: function()
        {
            var option = this.querySelector(
                'xui-option[value="' + this.value + '"]'
            ), data = option ? option.data : '';

            this.selected = option;

            this.fire('select-changed', {
                value: this.value,
                name: this.name,
                data: data
            });
        },

        onContentUpdate: function()
        {
            this.async(this.valueChanged);
            this.onMutation(this, this.onContentUpdate);
        },

        onClick: function(event)
        {
            this.focus();
            if ((/xui-option$/i).test(event.target.tagName))
            {
                this.value = event.target.value;
                this.blur();
            }
        }
    });
})();</script>

</polymer-element>
<polymer-element name="xui-radio-group">

	<template>
		<content select="xui-radio"></content>
	</template>

	<script>/* globals Polymer */

(function()
{
	'use strict';

	new Polymer(
	{
		publish:
		{
			value: { value: null, reflect: true }
		},

		eventDelegates:
		{
			select: 'onSelect'
		},

		onSelect: function(event)
		{
			if (event.target.selected)
			{
				this.value = event.target.value;
			}
		},

		valueChanged: function()
		{
			var radios = this.querySelectorAll('xui-radio');

			for (var i = 0; i < radios.length; i++)
			{
				var radio = radios[i];

				radio.selected = (this.value === radio.value);
			}
		}
	});
})();</script>

</polymer-element>

<polymer-element name="xui-radio">

    <template>
    	<style>*
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

* /deep/ *
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

::-webkit-scrollbar,
::-webkit-scrollbar-track
{
    width: 1.2em;
    height: 1.2em;
    background-color : #000;
}

::-webkit-scrollbar-thumb
{
    width: 1em;
    height: 1em;
    background-color : #393939;
    border: 0.1em solid #000;
}

::-webkit-scrollbar-thumb:vertical
{
    border-left: none;
}

::-webkit-scrollbar-thumb:horizontal
{
    border-top: none;
}

::-webkit-scrollbar-thumb:hover
{
    background-color : #EEE;
}

::-webkit-scrollbar-button
{
    width: 1em;
    height: 1em;
    background-color: #000;
    background-repeat: no-repeat;
    background-position: center;
}

::-webkit-scrollbar-button:vertical:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDbCysvpAqQv4gYY8BGIJSrwgB8TbgYbwUBIGBkC8ekBj4QIQh5JrwCMg9jx27NgXXApY8Gj+CNQoT8h5jKN5gQEgwAAAIhV/ZWnXrQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDXj//v0HSl3ADzTkIRBLUOIFOSDeDjSEh5IwMADi1QMaCxeAOJRcAx4BsaegoOAXXApY8Gj+CNQoT8h5jKN5gQEgwABHnBm9Hh2Q3AAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF1JREFUeNpi/P//PwMlgImBQjBEDLCysvqAS46FgEYJIHUSiPlJdgFQMw+Q2g7EcuR6YTUQGwxoIIYC8QWyDTh27NgXIOUJxI/wmgBKyoSwpaXlB1xyjKN5gQEgwABgXz/D96CahwAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF5JREFUeNpi/P//PwMlgImBQjBEDHj//v0HXHIsBDRKAKmTQMxPsguAmnmA1HYgliPXC6uB2GBAAzEUiC+QbYCgoOAXIOUJxI/wmgBKyoTwu3fvPuCSYxzNCwwAAQYAvFlGICKAHEEAAAAASUVORK5CYII=");
}</style>
        <style>input, label
{
    cursor: default;
    color: #555;
    font-size: 1.2em;
    vertical-align: middle;
    display: inline-block;
}

input:not(:disabled),
input:not(:disabled) + label
{
    cursor: pointer;
    color: #EEE;
}

input
{
    -webkit-appearance: none;
    display: inline-block;
    width: 17px;
    height: 17px;
    margin: 4px;
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAzCAYAAABxCePHAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA4BJREFUeNqsV99L01EUP865EkT2I0QQBEEwi17sSexpUDgUREgf9mCGwTCq/8CH8D/IMfgSQfgwQsQwJoui3kQfQoIezBSFUjCjKWJYOvftfL6cO+6+bm5XPPDhe/e953527znnc3ZXNTAwQC7zMe4y+hktgg3Ba8Y040g5T01NkddFcJuRYLS63gcZN4X8KeMx462a1ElGGBajOpPJ0M7ODu3v79Ph4SHV1tZSfX09NTQ0UDAYxBekGDHGC50krAi2trZoeXm5YBvHx8cO4ebmJrW3t1NTU1O1+OOIHz0Sg5IEbsM8/OCPdYODgz6QRBEDHKEcgU4Ef4ld1CNZoO3tbTIxzb8fJNcw2tvbMyLR/Ns8kj4neCaWzWbz6QfJL4xqamqMSLzefHVkQLKCkd/vNyLhelHDzx4pZWpsbDQiQeGJvQFJkrEGZhRSJQY/2ckatOQRMT1knHAlliWSisXwBBpiAR6p6LwXLVgoaWhFaefg4IDq6up07SiCmBKhLkCICfWcYMcWLXBu25CdF1UxycRVkTzQzLjB+ML4Lr2koJ8UIyHLghbJI1sOMP7Ic0PeUywWK1hTJUJS1s2YKNKUdENGnjDS+BAIBApIHjGegXhhYYHm5uZofn7eCS6C2tXVRT09PdTZ2QlfW4jiIHEkzehm5Bh2PB63eaIkMA8/8Y/Ytu3s5LKUfnMymaSxsbGyxTY+Pk7RKNqQE+w2kNzjwUtsfWhoqOKyn5ycdI7Idj/flBADE0ulUmrYB5LrGC0uLhqRLC0tFTQl1ICThXN2thBIfjqjUMiIROs/v0HyDaOOjg4jEs1/BSSzGPX29hqRaP6zIHmFfCNdyH8lBj9J7w9nvVRsRFVsIpE4s2IxX6xi1ReMiviqUXjpdPqUdiKRiNrBiWgn4RYg7A7jufSRUoYjPGC8y6vY7SFaQkPqQxKkjnZRX5KEae56f5U/juMt8nuS40dOPmKxX54k73PlAo+b0qr0i1JYleaV3wm5bkpZcfwggcYVKyTPUXlvi9+ImySsEVhldmtpRGFF4tOOYFVYsJZ2NKynYe0IJqaONpxvSvKbbGLK31mvjtJqSNIm677mb0paLVRqu6duSmxXDEkCp25KbLcMScLqpnQR2YleWJ0ozZynYrsr1c6lSrWjXy3Wy6h4/SwV6/+8EKwZxifGP3nOyHuf7gyS/wIMAOfeszGy3ACTAAAAAElFTkSuQmCC");
}

input:focus,
input:hover
{
    background-position: 0 -17px;
}

input:disabled
{
    background-position: 0 -34px;
}

input:checked
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAzCAYAAABxCePHAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABEBJREFUeNqsV09I3EcUfruupoKIuyuiCAGh4N9eLB7EnIQWF6EhUD3swVpSWFLantSbhyqIKKKksrCE0OJBioSUFsWypaEXUUoQoeC/hAitijXEijWYRN3N+4Y3y8zsbnZb8uBj58+bz5k373u/0dPV1UWOFTE+Ztxg1Ah2BD8w7jFeaee5uTnyOQQfMKKMd53xAON9If+a8SXjZz1pktxkxBgFR0dHdHh4SCcnJ3R2dkbFxcVUWlpKFRUVFAgE8AfmGRHGXZOkXRPs7e3RxsaGtY3z83NFuLu7S/X19VRdXV0g/jjiA6/EICuBa5iHH/yxrru7uwgkYcQAR8hFYBLBX2IX9sot0MHBgeVYXl5OQ0NDtLi4SCMjI1RZWWnNG/43QNKA1vHxseXU19dHra2t5PP5qKWlhfr7+615w7/WK9engmdaQ0NDWt/r9ab6FxcXqevH6FO0CgsLrUVbW1tWf3NzkxKJRKqPHYodgUR5l5WVWYsmJiZobW1NtdfX12l8fNzOvkBAN9d8ksofIXD7+/tW4Nw4mIbEE/sJO5llPAYzEikfg5/s5DG05BUxfc645EzMSSQZi+YlNMQCfKWj84toIYaUhla0dk5PT6mkpMTUjiaIaBGaAoSYkM9RdqwxAufajuw8o4pJJupE8sBVxnuMPxh/Si2x6kkmEorFoEXyypb9jOfyuyPjFIlErDUeEZK2DsY3GYqSabiRrxiL6Pj9fovkC8ZtEC8vL9PCwgItLS2p4CKobW1t1NnZqfTElhSiaZAoSTM6GAlGcnp6OskTWYF5+Il/KJlMqp28I6l/dXZ2lgYHB3Mm2/DwMIXDKEMq2LUg+YQb32HrPT09lK/NzMyoI7J9mipKiIFp0NLU1BTF43GanJykqqoqa35+fl43r4OkEa2VlZW0otTY2Egej4eamppoYGDAml9dXbWKEnJA3YJpWGhaXV2dIsxQ2YIg+Vu1gkFr0fb2dlofN6HNqD/PQKK8m5ubrUWjo6OqmumqNjY2Zs0b/lu4nV5ufJvtdnAEcwfZbud73DcGcP+uZSKAnxD8pdZLxoZ0xkaj0TdmLOYzZaz+A7dEfAU4Gj5arnZCoZDewaVoJ+oKEPYh447UkWyGI3zGiKdU7HqIllCQruMSJI/+QX4xfkRR4qr3woxZWlFiB3yh9FcKi8vkl2Q8kUtXeCk9knqRDY+keGW8PbyULsTxVwk0nlhB+b0l40nxu+mStBsEsRy7jRlE7ZqkyDhCLM9yEjOOhvXUaxzhv5g+Wm+qKMk32bRqudKXUtlrnHntr9bro7ifibhzK78587UyrqT+TDpBx+lfh+SlvBhTrwsZP0y9lPDWc0h+z9C/NPr+tJcS2zVnEfTxQNrLqBvOfLt+Kb2N2wm/tTzRmvk/GduRr3au5Ksd82nxJIeKn7xJxeZ/XgjWfcZDyY+H0g+bMdAkrwUYAPhtEIfi/eXDAAAAAElFTkSuQmCC");
}</style>

        <xui-utils-hash value="{{ hash }}" initial="radio-"></xui-utils-hash>

        <input type="radio" id="{{ hash }}" on-change="{{ radioChanged }}">
        <label for="{{ hash }}"><content></content></label>
    </template>

    <script>/* globals Polymer */

(function()
{
	'use strict';

	new Polymer(
	{
		publish:
		{
			selected: { value: false, reflect: true },
			disabled: { value: false, reflect: true },
			value: 	  { value: null, reflect: true }
		},

		select: function()
		{
			this.selected = true;
		},

		ready: function()
        {
            this.radio = this.shadowRoot.querySelector('input');
        },

        selectedChanged: function()
        {
        	this.radio.checked = this.selected;

        	this.fire('select');
        },

        disabledChanged: function()
        {
            this.radio.disabled = this.disabled;
        },

		radioChanged: function()
		{
			this.selected = this.radio.checked;
		}
	});
})();</script>

</polymer-element>
<polymer-element name="xui-input" attributes="textAlign value max min">

    <template>
    	<style>*
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

* /deep/ *
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

::-webkit-scrollbar,
::-webkit-scrollbar-track
{
    width: 1.2em;
    height: 1.2em;
    background-color : #000;
}

::-webkit-scrollbar-thumb
{
    width: 1em;
    height: 1em;
    background-color : #393939;
    border: 0.1em solid #000;
}

::-webkit-scrollbar-thumb:vertical
{
    border-left: none;
}

::-webkit-scrollbar-thumb:horizontal
{
    border-top: none;
}

::-webkit-scrollbar-thumb:hover
{
    background-color : #EEE;
}

::-webkit-scrollbar-button
{
    width: 1em;
    height: 1em;
    background-color: #000;
    background-repeat: no-repeat;
    background-position: center;
}

::-webkit-scrollbar-button:vertical:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDbCysvpAqQv4gYY8BGIJSrwgB8TbgYbwUBIGBkC8ekBj4QIQh5JrwCMg9jx27NgXXApY8Gj+CNQoT8h5jKN5gQEgwAAAIhV/ZWnXrQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDXj//v0HSl3ADzTkIRBLUOIFOSDeDjSEh5IwMADi1QMaCxeAOJRcAx4BsaegoOAXXApY8Gj+CNQoT8h5jKN5gQEgwABHnBm9Hh2Q3AAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF1JREFUeNpi/P//PwMlgImBQjBEDLCysvqAS46FgEYJIHUSiPlJdgFQMw+Q2g7EcuR6YTUQGwxoIIYC8QWyDTh27NgXIOUJxI/wmgBKyoSwpaXlB1xyjKN5gQEgwABgXz/D96CahwAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF5JREFUeNpi/P//PwMlgImBQjBEDHj//v0HXHIsBDRKAKmTQMxPsguAmnmA1HYgliPXC6uB2GBAAzEUiC+QbYCgoOAXIOUJxI/wmgBKyoTwu3fvPuCSYxzNCwwAAQYAvFlGICKAHEEAAAAASUVORK5CYII=");
}</style>
        <style>:host
{
  	width: 20em;
  	height: 2.2em;
  	display: inline-block;
  	border: 0.1em solid #000;
  	background-color: #393939;
}

input
{
	background-color: transparent;
	font-size: 1.2em;
	padding: 0;
	text-overflow: ellipsis;
	overflow: hidden;
	white-space: nowrap;
	display: inline-block;
	width: 100%;
	height: 100%;
	color: #EEE;
	border: none;
    outline: none;
    text-indent: 0.5em;
}

input
{
	text-align: {{textAlign}};
}

input[type=number]::-webkit-inner-spin-button,
input[type=number]::-webkit-outer-spin-button
{
	margin-top: 1px;
	margin-right: 1px;
    cursor:pointer;
}</style>

        <input type="{{ type }}" placeholder="{{ placeholder }}" id="input" text-align="{{ textAlign }}" max="{{ max }}" min="{{ min }}">
    </template>

    <script>/* globals Polymer */

(function()
{
	'use strict';

    var self,
        onRaise = function(event)
        {
            //var input = event.target;
            // revert to old value if invalid number
            if(self.type === "number")
            {
                var input = self.$.input;
                if (input.value != self.value)
                {
                    self.value = input.value;
                }
                input.removeEventListener("mouseout", onRaise);
                document.removeEventListener("mouseup", onRaise);
                self = null;
            }
        };

	new Polymer(
	{
		publish:
		{
			type:        { value: 'text', reflect: true },
			placeholder: { value: '', reflect: true },
            min:         { value: "", reflect: true },
            max:         { value: "", reflect: true }
		},

        valueChanged: function(oldValue, newValue)
        {
            if(this.type === "number")
            {
                if (oldValue == newValue)
                {
                    return;
                }

                if (isNaN(newValue) ||
                    (newValue.toString().trim() == "") ||
                    (parseInt(newValue) < parseInt(this.min)) ||
                    (parseInt(newValue) > parseInt(this.max)))
                {
                    this.value = oldValue;
                    return;
                }
                this.$.input.value = newValue;
                this.fire("change");
            }
        },

        typeChanged: function()
        {
            if (this.type === "number" && this.value !== "")
            {
                this._lastValidValue = this.value;
            }
            else
            {
                this._lastValidValue = null;
            }
        },

        onKeyDown : function(event)
        {
            if(this.type === "number")
            {
                if (event.which === 38 || event.which === 40)
                {
                    var _this = this;
                    setTimeout(function()
                    {
                        _this.value = _this.$.input.value;
                    }, 0);
                }
            }
        },

        onKeyPress : function(event)
        {
            if(this.type === "number")
            {
                var acceptKeyPress =
                    // accept numbers
                    (event.which >= 48  && event.which <= 57) ||
                    // accept minus sign.or period
                    (event.which === 45 || event.which === 46) ||
                    (event.which === 13);

                if (event.which === 13)
                {
                    this.value = this.$.input.value;
                }

                if (!acceptKeyPress)
                {
                    event.preventDefault();
                }
                // changed value will still need to be validated in onChange
            }
        },

        onChange : function(event)
        {
            var input = event.target;
            // revert to old value if invalid number
            if(input.type === "number")
            {

                event.stopPropagation();
            }
            else
            {
                this.fire("change"); // need this general case, because the
                    // change event does not bubble
            }
        },

        onMouseDown : function(event)
        {
            var input = event.target;
            // revert to old value if invalid number
            if(input.type === "number" && event.which == 1)
            {
                input.addEventListener("mouseout", onRaise, false);
                document.addEventListener("mouseup", onRaise, false);
                self = this;
            }
        },

        onInputBlur: function(event)
        {
            this.value = this.$.input.value;
        },

        ready : function()
        {
            this.$.input.addEventListener("mousedown", this.onMouseDown.bind(this));
            this.$.input.addEventListener("change", this.onChange.bind(this));
            this.$.input.addEventListener("keypress", this.onKeyPress.bind(this));
            this.$.input.addEventListener("keydown", this.onKeyDown.bind(this));
            this.$.input.addEventListener("blur", this.onInputBlur.bind(this));
        }
	});
})();</script>

</polymer-element>


<polymer-element name="xui-tab-group" vertical="" layout="" flex="">

    <template>
    	<style>*
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

* /deep/ *
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

::-webkit-scrollbar,
::-webkit-scrollbar-track
{
    width: 1.2em;
    height: 1.2em;
    background-color : #000;
}

::-webkit-scrollbar-thumb
{
    width: 1em;
    height: 1em;
    background-color : #393939;
    border: 0.1em solid #000;
}

::-webkit-scrollbar-thumb:vertical
{
    border-left: none;
}

::-webkit-scrollbar-thumb:horizontal
{
    border-top: none;
}

::-webkit-scrollbar-thumb:hover
{
    background-color : #EEE;
}

::-webkit-scrollbar-button
{
    width: 1em;
    height: 1em;
    background-color: #000;
    background-repeat: no-repeat;
    background-position: center;
}

::-webkit-scrollbar-button:vertical:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDbCysvpAqQv4gYY8BGIJSrwgB8TbgYbwUBIGBkC8ekBj4QIQh5JrwCMg9jx27NgXXApY8Gj+CNQoT8h5jKN5gQEgwAAAIhV/ZWnXrQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDXj//v0HSl3ADzTkIRBLUOIFOSDeDjSEh5IwMADi1QMaCxeAOJRcAx4BsaegoOAXXApY8Gj+CNQoT8h5jKN5gQEgwABHnBm9Hh2Q3AAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF1JREFUeNpi/P//PwMlgImBQjBEDLCysvqAS46FgEYJIHUSiPlJdgFQMw+Q2g7EcuR6YTUQGwxoIIYC8QWyDTh27NgXIOUJxI/wmgBKyoSwpaXlB1xyjKN5gQEgwABgXz/D96CahwAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF5JREFUeNpi/P//PwMlgImBQjBEDHj//v0HXHIsBDRKAKmTQMxPsguAmnmA1HYgliPXC6uB2GBAAzEUiC+QbYCgoOAXIOUJxI/wmgBKyoTwu3fvPuCSYxzNCwwAAQYAvFlGICKAHEEAAAAASUVORK5CYII=");
}</style>
        <style>#tabs
{
	padding-left: 0.5em;
}

#contents ::content > *
{
	-webkit-flex: 1;
}

#tabs
{
    overflow: hidden;
}

:host([horizontal])::shadow #tabs
{
    display: flex;
    flex-direction: column;
    padding-top: 0.5em;
}</style>

		<div id="tabs" on-click="{{ onTabClick }}">
			<content select="xui-tab"></content>
		</div>

		<div id="contents" vertical="" layout="" flex="">
			<content select="xui-tab-content"></content>
		</div>
    </template>

    <script>/* globals Polymer */

(function()
{
	'use strict';

	new Polymer(
	{
		ready: function()
		{
			this.onMutation(this, this.onContentUpdate);
		},

		onContentUpdate: function()
		{
			this.fire('tab-updated', {});
			this.onMutation(this, this.onContentUpdate);
		},

		onTabClick: function(event)
		{
			if (!(/xui-tab/i).test(event.target.tagName))
			{
				return false;
			}

			var tabs = [].slice.call(this.querySelectorAll('xui-tab'));

			tabs.forEach(function(tab)
			{
				tab.selected = (tab === event.target);
			});

			this.fire('tab-click', { target: event.target });
		}
	});
})();</script>

</polymer-element>
<polymer-element name="xui-tab-content">

    <template>
        <style>:host
{
	background-color: #313131;
	display: none;
}

:host([selected])
{
	display: block;
}</style>

		<content></content>
    </template>

    <script>/* globals Polymer */

(function()
{
	'use strict';

	new Polymer(
	{
		publish:
		{
			selected: { value: false, reflect: true }
		}
	});
})();</script>

</polymer-element>

<polymer-element name="xui-tab">

    <template>
    	<style>*
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

* /deep/ *
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

::-webkit-scrollbar,
::-webkit-scrollbar-track
{
    width: 1.2em;
    height: 1.2em;
    background-color : #000;
}

::-webkit-scrollbar-thumb
{
    width: 1em;
    height: 1em;
    background-color : #393939;
    border: 0.1em solid #000;
}

::-webkit-scrollbar-thumb:vertical
{
    border-left: none;
}

::-webkit-scrollbar-thumb:horizontal
{
    border-top: none;
}

::-webkit-scrollbar-thumb:hover
{
    background-color : #EEE;
}

::-webkit-scrollbar-button
{
    width: 1em;
    height: 1em;
    background-color: #000;
    background-repeat: no-repeat;
    background-position: center;
}

::-webkit-scrollbar-button:vertical:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDbCysvpAqQv4gYY8BGIJSrwgB8TbgYbwUBIGBkC8ekBj4QIQh5JrwCMg9jx27NgXXApY8Gj+CNQoT8h5jKN5gQEgwAAAIhV/ZWnXrQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDXj//v0HSl3ADzTkIRBLUOIFOSDeDjSEh5IwMADi1QMaCxeAOJRcAx4BsaegoOAXXApY8Gj+CNQoT8h5jKN5gQEgwABHnBm9Hh2Q3AAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF1JREFUeNpi/P//PwMlgImBQjBEDLCysvqAS46FgEYJIHUSiPlJdgFQMw+Q2g7EcuR6YTUQGwxoIIYC8QWyDTh27NgXIOUJxI/wmgBKyoSwpaXlB1xyjKN5gQEgwABgXz/D96CahwAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF5JREFUeNpi/P//PwMlgImBQjBEDHj//v0HXHIsBDRKAKmTQMxPsguAmnmA1HYgliPXC6uB2GBAAzEUiC+QbYCgoOAXIOUJxI/wmgBKyoTwu3fvPuCSYxzNCwwAAQYAvFlGICKAHEEAAAAASUVORK5CYII=");
}</style>
        <style>:host
{
	display: inline-block;
	border-radius: 4px 4px 0 0;
	background-color: #212121;
	color: #999;
	text-align: center;
	padding: 0.5em 1.5em 0.2em;
	margin: 0 0 0.2em 0.2em;
	cursor: pointer;
	font-size: 1.2em;
}

:host(:hover)
{
	background-color: #555;
	color: #CCC;
}

:host([selected])
{
	background-color: #313131;
	color: #CCC;
	box-shadow: 0 0.1em 0 0 #313131, 0 0.2em 0 0 #313131;
	cursor: default;
}

:host-context([horizontal])
{
	border-radius: 4px 0px 0px 4px;
	margin: 0.2em 0.2em 0 0;
	padding: 1.5em 0.2em 1.5em 0.5em;
}

:host-context([horizontal]):host([selected])
{
	box-shadow: 0.1em 0 0 0 #313131, 0.2em 0 0 0 #313131;
}</style>

		<content></content>
    </template>

    <script>/* globals Polymer */

(function()
{
	'use strict';

	new Polymer(
	{
		publish:
		{
			selected: { value: false, reflect: true },
			section: { reflect: true }
		},

		selectedChanged: function()
		{
			if (this.tabContent === undefined)
			{
				this.tabContent = this.nextElementSibling;
			}

			if (this.tabContent !== undefined &&
				(/xui-tab-content/i).test(this.tabContent.tagName))
			{
				this.tabContent.selected = this.selected;
			}
		},

		setContents: function(tabContent)
		{
			this.tabContent = tabContent;
		},

		ready: function()
		{
			// try assigning tab content elements with same section attribute
			var contents = [].slice.call(this.parentElement.querySelectorAll(
				"xui-tab-content"));

			for (var i = 0; i < contents.length; ++i)
			{
				var section = contents[i].getAttribute("section");
				if (section === this.getAttribute("section"))
				{
					this.setContents(contents[i]);
					break;
				}
			}
		}
	});
})();</script>

</polymer-element>
<polymer-element name="xui-dialog" vertical="" layout="">

    <template>
        <style>*
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

* /deep/ *
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

::-webkit-scrollbar,
::-webkit-scrollbar-track
{
    width: 1.2em;
    height: 1.2em;
    background-color : #000;
}

::-webkit-scrollbar-thumb
{
    width: 1em;
    height: 1em;
    background-color : #393939;
    border: 0.1em solid #000;
}

::-webkit-scrollbar-thumb:vertical
{
    border-left: none;
}

::-webkit-scrollbar-thumb:horizontal
{
    border-top: none;
}

::-webkit-scrollbar-thumb:hover
{
    background-color : #EEE;
}

::-webkit-scrollbar-button
{
    width: 1em;
    height: 1em;
    background-color: #000;
    background-repeat: no-repeat;
    background-position: center;
}

::-webkit-scrollbar-button:vertical:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDbCysvpAqQv4gYY8BGIJSrwgB8TbgYbwUBIGBkC8ekBj4QIQh5JrwCMg9jx27NgXXApY8Gj+CNQoT8h5jKN5gQEgwAAAIhV/ZWnXrQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDXj//v0HSl3ADzTkIRBLUOIFOSDeDjSEh5IwMADi1QMaCxeAOJRcAx4BsaegoOAXXApY8Gj+CNQoT8h5jKN5gQEgwABHnBm9Hh2Q3AAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF1JREFUeNpi/P//PwMlgImBQjBEDLCysvqAS46FgEYJIHUSiPlJdgFQMw+Q2g7EcuR6YTUQGwxoIIYC8QWyDTh27NgXIOUJxI/wmgBKyoSwpaXlB1xyjKN5gQEgwABgXz/D96CahwAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF5JREFUeNpi/P//PwMlgImBQjBEDHj//v0HXHIsBDRKAKmTQMxPsguAmnmA1HYgliPXC6uB2GBAAzEUiC+QbYCgoOAXIOUJxI/wmgBKyoTwu3fvPuCSYxzNCwwAAQYAvFlGICKAHEEAAAAASUVORK5CYII=");
}</style>
        <style>*
{
	color: #EEE;
}

:host
{
	display: -webkit-flex;
	-webkit-flex-direction: column;
	width: 36em;
	height: 44.5em;
	border: 0.3em solid #191919;
	background-color: #000;
}

#title
{
	font-size: 1.2em;
	line-height: 2.2em;
	padding-left: 0.5em;
}

#sticky
{
  	line-height: 2.2em;
}

#content,
#content ::content > *
{
	-webkit-flex: 1;
	display: flex;
	-webkit-flex-direction: column;
}

#footer
{
	background-color: #313131;
}</style>

        <div id="titlebar" horizontal="" layout="">
            <div id="title" flex="">
                <content select="[titlebar]"></content>
            </div>
            <xui-checkbox id="sticky" horizontal="" layout="" reverse="">
                Sticky
            </xui-checkbox>
        </div>

        <div id="content" flex=""><content select="[content]"></content></div>

        <div id="footer">
            <xui-checkbox id="keepsource">Keep source in memory</xui-checkbox>
        </div>
    </template>

    <script>/* globals Polymer */

(function()
{
	'use strict';

	new Polymer(
	{

	});
})();</script>

</polymer-element>
<polymer-element name="xui-subsection" noscript="">

    <template>
    	<style>*
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

* /deep/ *
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

::-webkit-scrollbar,
::-webkit-scrollbar-track
{
    width: 1.2em;
    height: 1.2em;
    background-color : #000;
}

::-webkit-scrollbar-thumb
{
    width: 1em;
    height: 1em;
    background-color : #393939;
    border: 0.1em solid #000;
}

::-webkit-scrollbar-thumb:vertical
{
    border-left: none;
}

::-webkit-scrollbar-thumb:horizontal
{
    border-top: none;
}

::-webkit-scrollbar-thumb:hover
{
    background-color : #EEE;
}

::-webkit-scrollbar-button
{
    width: 1em;
    height: 1em;
    background-color: #000;
    background-repeat: no-repeat;
    background-position: center;
}

::-webkit-scrollbar-button:vertical:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDbCysvpAqQv4gYY8BGIJSrwgB8TbgYbwUBIGBkC8ekBj4QIQh5JrwCMg9jx27NgXXApY8Gj+CNQoT8h5jKN5gQEgwAAAIhV/ZWnXrQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDXj//v0HSl3ADzTkIRBLUOIFOSDeDjSEh5IwMADi1QMaCxeAOJRcAx4BsaegoOAXXApY8Gj+CNQoT8h5jKN5gQEgwABHnBm9Hh2Q3AAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF1JREFUeNpi/P//PwMlgImBQjBEDLCysvqAS46FgEYJIHUSiPlJdgFQMw+Q2g7EcuR6YTUQGwxoIIYC8QWyDTh27NgXIOUJxI/wmgBKyoSwpaXlB1xyjKN5gQEgwABgXz/D96CahwAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF5JREFUeNpi/P//PwMlgImBQjBEDHj//v0HXHIsBDRKAKmTQMxPsguAmnmA1HYgliPXC6uB2GBAAzEUiC+QbYCgoOAXIOUJxI/wmgBKyoTwu3fvPuCSYxzNCwwAAQYAvFlGICKAHEEAAAAASUVORK5CYII=");
}</style>
        <style>:host
{
	display: block;
	min-height: 1em;
	border: 0.1em solid #000;
	background-color: #212121;
	padding: 0.5em;
}</style>

		<content></content>
    </template>

</polymer-element>

<polymer-element name="xui-section">

    <template>
    	<style>*
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

* /deep/ *
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

::-webkit-scrollbar,
::-webkit-scrollbar-track
{
    width: 1.2em;
    height: 1.2em;
    background-color : #000;
}

::-webkit-scrollbar-thumb
{
    width: 1em;
    height: 1em;
    background-color : #393939;
    border: 0.1em solid #000;
}

::-webkit-scrollbar-thumb:vertical
{
    border-left: none;
}

::-webkit-scrollbar-thumb:horizontal
{
    border-top: none;
}

::-webkit-scrollbar-thumb:hover
{
    background-color : #EEE;
}

::-webkit-scrollbar-button
{
    width: 1em;
    height: 1em;
    background-color: #000;
    background-repeat: no-repeat;
    background-position: center;
}

::-webkit-scrollbar-button:vertical:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDbCysvpAqQv4gYY8BGIJSrwgB8TbgYbwUBIGBkC8ekBj4QIQh5JrwCMg9jx27NgXXApY8Gj+CNQoT8h5jKN5gQEgwAAAIhV/ZWnXrQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDXj//v0HSl3ADzTkIRBLUOIFOSDeDjSEh5IwMADi1QMaCxeAOJRcAx4BsaegoOAXXApY8Gj+CNQoT8h5jKN5gQEgwABHnBm9Hh2Q3AAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF1JREFUeNpi/P//PwMlgImBQjBEDLCysvqAS46FgEYJIHUSiPlJdgFQMw+Q2g7EcuR6YTUQGwxoIIYC8QWyDTh27NgXIOUJxI/wmgBKyoSwpaXlB1xyjKN5gQEgwABgXz/D96CahwAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF5JREFUeNpi/P//PwMlgImBQjBEDHj//v0HXHIsBDRKAKmTQMxPsguAmnmA1HYgliPXC6uB2GBAAzEUiC+QbYCgoOAXIOUJxI/wmgBKyoTwu3fvPuCSYxzNCwwAAQYAvFlGICKAHEEAAAAASUVORK5CYII=");
}</style>
        <style>:host
{
	margin: 0.5em 0.8em;
	display: block;
	position: relative;
	padding-top: 1.6em;
}

:host label
{
	color: #888;
	font-size: 1.2em;
	position: absolute;
	top: 0;
}

#content
{
	border: 0.1em solid #555;
	padding: 0.5em;
	min-height: 1em;
}</style>

        <label block="">{{ label }}</label>
        <div id="content">
			<content></content>
		</div>
    </template>

    <script>/* globals Polymer */

(function()
{
	'use strict';

	new Polymer(
	{
		publish:
		{
			label: { value: '', reflect: true }
		}
	});
})();</script>

</polymer-element>

<polymer-element name="xui-textarea">

    <template>
        <style>*
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

* /deep/ *
{
	font-family: "Roboto";
	outline: none;
	box-sizing: border-box;
	-webkit-user-select: none;
}

::-webkit-scrollbar,
::-webkit-scrollbar-track
{
    width: 1.2em;
    height: 1.2em;
    background-color : #000;
}

::-webkit-scrollbar-thumb
{
    width: 1em;
    height: 1em;
    background-color : #393939;
    border: 0.1em solid #000;
}

::-webkit-scrollbar-thumb:vertical
{
    border-left: none;
}

::-webkit-scrollbar-thumb:horizontal
{
    border-top: none;
}

::-webkit-scrollbar-thumb:hover
{
    background-color : #EEE;
}

::-webkit-scrollbar-button
{
    width: 1em;
    height: 1em;
    background-color: #000;
    background-repeat: no-repeat;
    background-position: center;
}

::-webkit-scrollbar-button:vertical:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=");
}

::-webkit-scrollbar-button:vertical:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDbCysvpAqQv4gYY8BGIJSrwgB8TbgYbwUBIGBkC8ekBj4QIQh5JrwCMg9jx27NgXXApY8Gj+CNQoT8h5jKN5gQEgwAAAIhV/ZWnXrQAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:increment:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQjCIDXj//v0HSl3ADzTkIRBLUOIFOSDeDjSEh5IwMADi1QMaCxeAOJRcAx4BsaegoOAXXApY8Gj+CNQoT8h5jKN5gQEgwABHnBm9Hh2Q3AAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF1JREFUeNpi/P//PwMlgImBQjBEDLCysvqAS46FgEYJIHUSiPlJdgFQMw+Q2g7EcuR6YTUQGwxoIIYC8QWyDTh27NgXIOUJxI/wmgBKyoSwpaXlB1xyjKN5gQEgwABgXz/D96CahwAAAABJRU5ErkJggg==");
}

::-webkit-scrollbar-button:horizontal:decrement:hover
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAF5JREFUeNpi/P//PwMlgImBQjBEDHj//v0HXHIsBDRKAKmTQMxPsguAmnmA1HYgliPXC6uB2GBAAzEUiC+QbYCgoOAXIOUJxI/wmgBKyoTwu3fvPuCSYxzNCwwAAQYAvFlGICKAHEEAAAAASUVORK5CYII=");
}</style>
        <style>:host
{
  	width: 20em;
  	display: inline-block;
  	border: 0.1em solid #000;
  	background-color: #393939;
}

textarea
{
	background-color: transparent;
	font-size: 1.2em;
	padding: 0.2em 0.5em;
	text-overflow: ellipsis;
	overflow: hidden;
	display: inline-block;
	width: 100%;
	color: #EEE;
	border: none;
	resize: none;
}</style>

        <textarea rows="{{ rows }}" cols="{{ cols }}" disabled?="{{ disabled }}" maxlength="{{ maxlength }}" wrap="{{ wrap }}" value="{{ text }}"></textarea>
    </template>

    <script>/* globals Polymer */

(function()
{
	'use strict';

	new Polymer(
	{
		publish:
		{
			text: 		{ value: '', reflect: true },
			rows: 		{ value: 3, reflect: true },
			cols: 	   	{ value: 200, reflect: true },
			wrap:       { value: 'hard', reflect: true },
			disabled:  	{ value: false, reflect: true },
			maxlength: 	{ value: -1, reflect: true }
		},

		ready: function()
		{
			this.text = this.innerHTML;
		},

		textChanged: function()
		{
			this.innerHTML = this.text;
		}
	});
})();</script>

</polymer-element>
<polymer-element name="xui-dropdown" constructor="XUIDropdown" attributes="value">

    <template>
        <style>:focus
{
    outline: none;
}

#dropdown,
label
{
    color: #CCC;
    font-size: 12px;
}


#dropdown
{
	margin: 5px 0;
	padding: 0;
    width: inherit;
    position: relative;
}

#dropdown li
{
	margin: 0;
	padding: 0;
	list-style: none;
	float: left;
    width: inherit;
}

#dropdown li a
{
	display: block;
	min-width: 100px;
    width: inherit;
	text-decoration: none;
	height: 18px;
	color: #eee;
	resize: none;
	overflow-x: hidden;
	font-size: 12px;
	cursor: pointer;
    padding: 3px 5px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

#dropdown li > a
{
    background: #393939 url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFhJREFUeNpiTEtLm8zAwJDDgB3MZQISxUB8EIvkKSDOYvz//z9Denq6KJBzHoiloZKvgdhw5syZT0EmMAAZIAF/IP4FxaEgSbBSkAkwDHRPAhDnI4sBBBgAqFkrWV8limsAAAAASUVORK5CYII=") no-repeat 97%;
    border: 1px solid #000;
    max-width: 95%;
}

#dropdown li > a:hover,
#dropdown li > a:focus
{
    background: #555 url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFtJREFUeNpiPHPmzGQGBoYcBuxgLhOQKAbig1gkTwFxFuP///8Zzp49KwrknAdiaajkayA2NDY2fgoygQHIAAn4A/EvKA4FSYLkwCbAANCkBCDFD5ScCBMDCDAASBocBPGB98YAAAAASUVORK5CYII=") no-repeat 97%;
	color: #eee;
}

#dropdown li > a.show
{
    background: #555;
}

#options
{
    width: inherit;
    min-width: 100px;
    padding-right: 10px;
    max-height: 102px;
    min-height: 24px;
    background: #000;
    border: 1px solid #555;
    overflow: auto;
    overflow-x: hidden;
    position: absolute;
    z-index: 10;
    box-sizing: border-box;
    left: -1px;
}

#options a
{
    color: #999;
    display: block;
    height: 24px;
    width: inherit;
}

#dropdown li > #options a
{
    width: 100%;
}

#options a.selected
{
    color: #eee;
    background: #043151;
}

/** Scrollbar **/
::-webkit-scrollbar
{
    background: #000;
    width: 12px;
}

::-webkit-scrollbar-button
{
    height: 8px;
    width: 12px;
}

::-webkit-scrollbar-button:increment
{
     background: transparent url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=") no-repeat  2px;
}

::-webkit-scrollbar-button:decrement
{
    background: transparent url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=") no-repeat  2px;
}

::-webkit-scrollbar-button:increment:hover
{
     background: transparent url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=") no-repeat  2px;
}

::-webkit-scrollbar-button:decrement:hover
{
    background: transparent url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==") no-repeat  2px;
}

::-webkit-scrollbar-button:increment:disabled
{
     background: transparent url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpiVFRU/MDAwMDPgB18ZLp3754AkPEIi+QjkBwTlGMOxBeQJC9AxRgY////DxZRUlLiAVKroQpCgbq/gBgAAQYAShgTfaoD9sIAAAAASUVORK5CYII=") no-repeat  2px;
}

::-webkit-scrollbar-button:decrement:disabled
{
    background: transparent url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIKCkp8QCp1QwQEHrv3r0vIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqKi4gcgzc+AHXwECDAACv0VRRi/fSoAAAAASUVORK5CYII=") no-repeat  2px;
}

::-webkit-scrollbar-track
{
    background: #000;
}

::-webkit-scrollbar-thumb:hover
{
    background: #eee;
}

::-webkit-scrollbar-thumb
{
    background: #393939;
    border-left: 1px solid #000;
    width: 10px;
}
</style>

        <label for="dropdown" id="label">{{ label }}</label>
        <ul id="dropdown">
            <li>
                <a id="select" href="#" on-click="{{ XUIDropdownClicked }}">{{ selected }}</a>
			    <div id="options">
                    <template repeat="{{ option in list }}">
                        <a href="#" value="{{ option.id }}" on-click="{{ selectOptions }}" on-mouseover="{{ onMouseOver }}" tabindex="-1">{{ option.name }}</a>
                    </template>
			     </div>
			</li>
        </ul>
    </template>

    <script>/* globals Polymer, document */
(function()
{
    "use strict";
    var self;

    var mouseCancel = function()
        {
            if (event.target != self && !self.contains(event.target))
            {
                self.XUIDropdownClicked();
            }
        },

        keyCancel = function()
        {
            if (event.which == 9) // tab
            {
                self.XUIDropdownClicked();
            }
            else if (event.which == 27) // esc
            {
                self.$.select.focus();
                self.XUIDropdownClicked();
                event.stopPropagation();
            }
            else if (event.which == 33) // page up
            {
                var list = self.$.options;
                var optionCollection = list.querySelectorAll("a");
                var optionCollectionLength = optionCollection.length;

                for (var i = 0; i < optionCollectionLength; i++)
                {
                    if (optionCollection[i].classList.contains("selected"))
                    {
                        var selected = optionCollection[i];
                        if (i > 0)
                        {
                            selected.classList.remove("selected");
                            var steps = Math.floor(list.offsetHeight/selected.offsetHeight) - 1;
                            var newSelected, viewportOffset;

                            if (i >= steps)
                            {
                                newSelected = optionCollection[i-steps];
                            }
                            else
                            {
                                newSelected = optionCollection[0];
                            }
                            newSelected.classList.add("selected");
                            viewportOffset = newSelected.getBoundingClientRect();
                            self.computeScrollTop(viewportOffset, newSelected.offsetHeight + parseFloat(getComputedStyle(newSelected).marginTop) + parseFloat(getComputedStyle(newSelected).marginBottom));
                        }
                        break;
                    }
                }
                event.stopPropagation();
                event.preventDefault();
            }
            else if (event.which == 34) // page down
            {
                var list = self.$.options;
                var optionCollection = list.querySelectorAll("a");
                var optionCollectionLength = optionCollection.length;

                for (var i = 0; i < optionCollectionLength; i++)
                {
                    if (optionCollection[i].classList.contains("selected"))
                    {
                        var selected = optionCollection[i];
                        if (i < (optionCollectionLength - 1))
                        {
                            selected.classList.remove("selected");
                            var steps = Math.floor(list.offsetHeight/selected.offsetHeight) - 1;
                            var newSelected, viewportOffset;

                            if (i <= optionCollectionLength - 1 - steps)
                            {
                                newSelected = optionCollection[i + steps];
                            }
                            else
                            {
                                newSelected = optionCollection[optionCollectionLength-1];
                            }
                            newSelected.classList.add("selected");
                            viewportOffset = newSelected.getBoundingClientRect();
                            self.computeScrollTop(viewportOffset, newSelected.offsetHeight + parseFloat(getComputedStyle(newSelected).marginTop) + parseFloat(getComputedStyle(newSelected).marginBottom));
                        }
                        break;
                    }
                }
                event.stopPropagation();
                event.preventDefault();
            }
            else if (event.which == 35) // end
            {
                var list = self.$.options;
                var optionCollection = list.querySelectorAll("a");
                var optionCollectionLength = optionCollection.length;
                var selected = list.querySelector("a.selected");
                var newSelected = optionCollection[optionCollectionLength-1];

                if (newSelected != selected)
                {
                    var viewportOffset = newSelected.getBoundingClientRect();
                    selected.classList.remove("selected");
                    newSelected.classList.add("selected");
                    self.computeScrollTop(viewportOffset, newSelected.offsetHeight + parseFloat(getComputedStyle(newSelected).marginTop) + parseFloat(getComputedStyle(newSelected).marginBottom));
                }
                event.stopPropagation();
                event.preventDefault();
            }
            else if (event.which == 36) // home
            {
                var list = self.$.options;
                var optionCollection = list.querySelectorAll("a");
                var selected = list.querySelector("a.selected");
                var newSelected = optionCollection[0];

                if (newSelected != selected)
                {
                    var viewportOffset = newSelected.getBoundingClientRect();
                    selected.classList.remove("selected");
                    newSelected.classList.add("selected");
                    self.computeScrollTop(viewportOffset, newSelected.offsetHeight + parseFloat(getComputedStyle(newSelected).marginTop) + parseFloat(getComputedStyle(newSelected).marginBottom));
                }
                event.stopPropagation();
                event.preventDefault();
            }
            else if (event.which == 38) // up
            {
                var list = self.$.options;
                var optionCollection = list.querySelectorAll("a");
                var optionCollectionLength = optionCollection.length;

                for (var i = 0; i < optionCollectionLength; i++)
                {
                    if (optionCollection[i].classList.contains("selected"))
                    {
                        var selected = optionCollection[i];
                        if (i > 0)
                        {
                            selected.classList.remove("selected");
                            var newSelected = optionCollection[i-1];
                            var viewportOffset = newSelected.getBoundingClientRect();
                            newSelected.classList.add("selected");
                            self.computeScrollTop(viewportOffset, newSelected.offsetHeight + parseFloat(getComputedStyle(newSelected).marginTop) + parseFloat(getComputedStyle(newSelected).marginBottom));
                        }
                        break;
                    }
                }
                event.stopPropagation();
                event.preventDefault();
            }
            else if (event.which == 40) // down
            {
                var list = self.$.options;
                var optionCollection = list.querySelectorAll("a");
                var optionCollectionLength = optionCollection.length;

                for (var i = 0; i < optionCollectionLength; i++)
                {
                    if (optionCollection[i].classList.contains("selected"))
                    {
                        var selected = optionCollection[i];
                        if (i < (optionCollectionLength - 1))
                        {
                            selected.classList.remove("selected");
                            var newSelected = optionCollection[i+1];
                            var viewportOffset = newSelected.getBoundingClientRect();
                            newSelected.classList.add("selected");
                            self.computeScrollTop(viewportOffset, newSelected.offsetHeight + parseFloat(getComputedStyle(newSelected).marginTop) + parseFloat(getComputedStyle(newSelected).marginBottom));
                        }
                        break;
                    }
                }
                event.stopPropagation();
                event.preventDefault();
            }
            else if (event.which == 13) // enter
            {
                var selected = self.$.dropdown.querySelector("#options a.selected");
                if (selected != null)
                {
                    selected.click();
                    event.preventDefault();
                }
            }
            else if (event.keyCode >= 65 && event.keyCode <= 90)
            //cycle between values starting with letter
            {

            }
        };

    function XUIDropdown()
    {
        this.$.options.hidden = true;
        this.updateOptions();
    }

    /**
    * Creates a dropdown
    *
    * @class  XUIDropdown
    * @constructor
    *
    * @example
    *     <xui-dropdown label="Dropdown Label"></xui-dropdown>
    */
    XUIDropdown.prototype =
    {
       ready: XUIDropdown,

        publish:
        {
            /**
             * Label for the dropdown
             *
             * @attribute   label
             * @type        String
             */
            label           : { value: "", reflect: true },

            /**
             * Disables/enables the dropdown
             *
             * @attribute   disabled
             * @type        Boolean
             * @default     false
             */
            disabled        : { value: false, reflect: true },

            /**
             * Sets selected Option
             *
             * @attribute   selected
             * @type        String
             */
            selected        : { value: "", reflect: true },

            /**
             * Sets selected Value
             *
             * @attribute   value
             * @type        String
             */
            value   : { value: "", reflect: true },

            /**
             * Sets the available options
             *
             * @attribute   optionlist
             * @type        String
             */
            optionlist      : { value: [], reflect: true }
        },

        valueChanged: function(oldValue, newValue)
        {
            if (oldValue == newValue)
            {
                return;
            }

            var selector = "#options a[value='" + newValue + "']";
            var selected = this.$.dropdown.querySelector(selector);

            if (selected != null)
            {
                this.selected = newValue;
            }
            this.fire("change");
        },

        computeScrollTop: function(viewportOffset, height)
        {
            var scrollDiv = this.$.options;
            var minTop = scrollDiv.getBoundingClientRect().top;
            var maxTop = scrollDiv.getBoundingClientRect().bottom - height;

            if (viewportOffset.top < minTop)
            {
                var difference = minTop - viewportOffset.top;
                scrollDiv.scrollTop = scrollDiv.scrollTop - difference;
            }
            else if (viewportOffset.top > maxTop)
            {
                var difference = viewportOffset.top - maxTop;
                scrollDiv.scrollTop = scrollDiv.scrollTop + difference;
            }
        },

        XUIDropdownClicked: function(event)
        {
            var hidden = this.$.options.hidden;
            this.$.options.hidden = !hidden;

            if (!hidden)
            {
                this.clearSelected();
                document.body.removeEventListener('mousedown', mouseCancel, false);
                document.body.removeEventListener('keydown', keyCancel, false);
                self = null;
            }
            else
            {
                self = this;
                document.body.addEventListener('mousedown', mouseCancel, false);
                document.body.addEventListener('keydown', keyCancel, false);
                this.showSelected();
            }

            if(typeof event !== "undefined")
            {
                //this.fire('change', event);
                event.stopPropagation();
                if (event.which == 2)
                {
                    event.preventDefault();
                }
            }
        },

        showSelected: function()
        {
            var selector = "#options a[value='" + this.value + "']";
            var selected = this.$.dropdown.querySelector(selector);

            if (selected != null)
            {
                selected.classList.add("selected");
                var viewportOffset = selected.getBoundingClientRect();
                var outerHeight = selected.offsetHeight + parseFloat(getComputedStyle(selected).marginTop) + parseFloat(getComputedStyle(selected).marginBottom);
                this.computeScrollTop(viewportOffset, outerHeight);
            }
            this.$.select.focus();
        },

        clearSelected: function()
        {
            var selected = this.$.dropdown.querySelectorAll("#options a.selected");
            for (var i = selected.length - 1; i >= 0; i--)
            {
                selected[i].classList.remove("selected");
            };
        },

        onMouseOver: function(event, detail, sender)
        {
            this.clearSelected();
            sender.classList.add("selected");
        },

        selectOptions: function(event, detail, sender)
        {
            if (event.which != undefined && event.which != 1)
            {
                event.preventDefault();
                return;
            }

            this.value = sender.getAttribute('value');
            this.XUIDropdownClicked();
            this.fire("select");
        },

        optionlistChanged: function(oldVal, newVal)
        {
            if(typeof newVal !== "undefined")
            {
                if (oldVal != newVal)
                {
                    this.optionlist = newVal;
                    this.updateOptions();
                }
            }
        },

        /**
         * Updates the option list
         */
        updateOptions: function()
        {
            var list = [];
            var selectedValue = 0;
            var selectedName = "";
            if(this.optionlist.length > 0)
            {
                selectedValue = this.value;
                selectedName = this.selected;
                list = this.optionlist.slice(0);
            }

            this.list = list;
            this.selected = selectedName;
        }
    };

    Polymer.call({}, XUIDropdown.prototype);
})();</script>
</polymer-element>
<polymer-element name="xui-listbox" constructor="XUIListBox">

    <template>
        <style>#dropdown,
label
{
    color: #CCC;
    font-size: 12px;
}

label.disabled
{
    color: #555;
}

#options
{
    width: inherit;
    height: inherit;
    min-height: 24px;
    background: #393939;
    border: 1px solid #000;
    overflow: scroll;
    overflow-x: hidden;
    z-index: 10;
}

#options a
{
    color: #999;
    overflow: hidden;
    display: block;
    font-size: 12px;
    padding: 2px 5px;
    text-decoration: none;
    word-break: break-all;
}

#options a:hover,
#options a:focus,
#options a.selected
{
    color: #eee;
    background: #555;
}

#options.disabled a,
#options.disabled a:hover,
#options.disabled a:focus
{
    background: #212121;
    color: #555;
}

/** Scrollbar **/
::-webkit-scrollbar
{
    background: #000;
    width: 12px;
}

::-webkit-scrollbar-button
{
    height: 8px;
    width: 12px;
}

::-webkit-scrollbar-button:increment
{
     background: transparent url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUeNpitLS0/MDAwMDPgB18ZPz//z+DlZXVQyBHDk3y0bFjx+SZoBxzIL6AJHkBKsYANgEEgKbwAKnVUAWhQN1fQAyAAAMAy+oUqU6ofmcAAAAASUVORK5CYII=") no-repeat  2px;
}

::-webkit-scrollbar-button:decrement
{
    background: transparent url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIWFlZ8QCp1QwQEHrs2LEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqWl5Qcgzc+AHXwECDAAHvUVjerUH5MAAAAASUVORK5CYII=") no-repeat  2px;
}

::-webkit-scrollbar-button:increment:hover
{
     background: transparent url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpifPfu3T8GBgZGBuzgP5OgoCATkPEHi+QfkBwTlGMMxN+RJL9DxRgY////DxZ5//69OJC6AlWgA9T9EsQACDAANmwRgl5U30MAAAAASUVORK5CYII=") no-repeat  2px;
}

::-webkit-scrollbar-button:decrement:hover
{
    background: transparent url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAE5JREFUeNpi/P//PwMIvH//ngdIrWaAgFBBQcEvIAYjSAFQUgLI3g7EBlAFF4DYE6joBUzBQ6CAHAMqeARUIM/47t27D0AOPwN28BEgwAAleh22O1TFjQAAAABJRU5ErkJggg==") no-repeat  2px;
}

::-webkit-scrollbar-button:increment:disabled
{
     background: transparent url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEZJREFUeNpiVFRU/MDAwMDPgB18ZLp3754AkPEIi+QjkBwTlGMOxBeQJC9AxRgY////DxZRUlLiAVKroQpCgbq/gBgAAQYAShgTfaoD9sIAAAAASUVORK5CYII=") no-repeat  2px;
}

::-webkit-scrollbar-button:decrement:disabled
{
    background: transparent url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAExJREFUeNpi/P//PwMIKCkp8QCp1QwQEHrv3r0vIAYjSAFQUgLI3g7EBlAFF4DYE6joBRNU4CSSJAOUfRJsgqKi4gcgzc+AHXwECDAACv0VRRi/fSoAAAAASUVORK5CYII=") no-repeat  2px;
}

::-webkit-scrollbar-track
{
    background: #000;
}

::-webkit-scrollbar-thumb:hover
{
    background: #eee;
}

::-webkit-scrollbar-thumb
{
    background: #393939;
    border-left: 1px solid #000;
    width: 10px;
}</style>

        <label for="dropdown" id="label">{{ label }}</label>
        <div id="options">
            <template repeat="{{ option in optionlist }}">
                <a href="#" id="{{ option.id }}" value="{{ option.id }}" class="{{ itemclass }}" on-click="{{ selectOptions }}">{{ option.name }}</a>
            </template>
        </div>
        <content></content>
    </template>

    <script>/* globals Polymer */
(function()
{
    "use strict";

    function XUIListBox()
    {
        if(this.disabled)
        {
            this.$.label.classList.add("disabled");
            this.$.options.classList.add("disabled");
        }


    }

    /**
    * Creates a dropdown
    *
    * @class  XUIDropdown
    * @constructor
    *
    * @example
    *     <xui-dropdown label="Dropdown Label"></xui-dropdown>
    */
    XUIListBox.prototype =
    {
       ready: XUIListBox,

        publish:
        {
            /**
             * Label for the dropdown
             *
             * @attribute   label
             * @type        String
             */
            label           : { value: "", reflect: true },

            /**
             * Disables/enables the dropdown
             *
             * @attribute   disabled
             * @type        Boolean
             * @default     false
             */
            disabled        : { value: false, reflect: true },

            /**
             * Sets the available options
             *
             * @attribute   optionlist
             * @type        String
             */
            optionlist      : { value: [], reflect: true },

            /**
             * Sets the class
             *
             * @attribute   class
             * @type        String
             */
            itemclass       : { value: "", reflect: true },

            selected        : { value: "", reflect: true }
        },

        selectOptions: function(event)
        {
            var items = this.$.options.getElementsByTagName("a");
            for(var i = 0; i < items.length; i++)
            {
                items[i].classList.remove("selected");
            }
            event.target.classList.add("selected");
            this.selected = event.target.getAttribute("value");
        }
    };

    Polymer.call({}, XUIListBox.prototype);
})();</script>
</polymer-element>
<polymer-element name="xui-overlay" constructor="XUIOverlay">
    <template>
        <style>#overlay
{
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
    z-index: 100;
    background: rgba(12, 12, 12, 0.5);
}

#modalWindow
{
    width: -webkit-max-content;
    height: -webkit-max-content;
    max-width: 80%;
    min-width: 250px;
    margin: 20% auto;
    background-color: #121212;
    color: #ccc;
    border: 1px solid #000;
    position: relative;
}

#modalHeader
{
    color: #ccc;
    background: #000;
    padding: 5px 10px;
}

#modalBody
{
    padding: 10px;
}

#modalFooter
{
    padding: 20px 10px 10px;
}

.right
{
    float: right;
}

.clear
{
    clear: both;
}</style>
        <div id="overlay" on-click="{{ toggleOverlay }}">
            <div id="modalWindow">
                <div id="modalHeader">
                    <content select="#header"></content>
                </div>
                <div id="modalBody">
                    <content select="#body"></content>
                </div>
                <div id="modalFooter">
                    <div class="right">
                        <content select="#footer"></content>
                    </div>
                    <div class="clear"></div>
                </div>
            </div>
        </div>
    </template>

    <script>/* global Polymer */
(function()
{
    "use strict";

    function XUIOverlay()
    {
        this.$.overlay.style.visibility = (this.visible) ? "visible" : "hidden";
    }

    /**
    * Creates a button
    *
    * @class  XUIButton
    * @constructor
    *
    * @example
    *     <xui-button>text</xui-button>
    */
    XUIOverlay.prototype =
    {
        ready: XUIOverlay,

        publish:
        {
            visible: { value: false, reflect: true }
        },

        visibleChanged: function()
        {
            this.$.overlay.style.visibility = (this.visible) ? "visible" : "hidden";
        },

        toggleOverlay: function(event)
        {
            if(event.target === this.$.overlay)
            {
                this.visible = false;
            }
        }

    };

    Polymer.call(this, XUIOverlay.prototype);
})();</script>
</polymer-element>
<polymer-element name="xui-colorpicker" constructor="XUIColorpicker">

    <template>
        <style>#colorPicker
{
	display: inline-block;
	vertical-align: middle;
	font-size: 11px;
}

#colorPicker:focus,
#colorPicker :focus
{
	outline: none;
}

#colorPicker span
{
	color: #FFFFFF;
	position: absolute;
	left: 42px;
	top: 5px;
}

#picker
{
	border: solid 1px #000000;
	height: 20px;
	width: 20px;
	position: relative;
}

#colorPicker div
{
	display: block;
}

#colorPicker div#paletteContainer
{
	background-color: #000000;
	border: 1px solid #555555;
	border-radius: 0;
	position: absolute;
	z-index: 10;
	text-align: center;
	margin-left: 24px;
	margin-top: -103px;
}

#colorPicker .picker-arrow
{
    background-color: #DBDBDB;
    width: 10px;
    height: 8px;
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAD1JREFUeNpi5OXlncnAwJDGgAoWMwIlOIGMY0BsABW8BsQmTEDiOxBHAPEXKA4CibFAVd0E4nQkNgNAgAEA3t8Km2aZ9fsAAAAASUVORK5CYII=");
    background-repeat: no-repeat;
    background-position: 2px 2px;
    position: absolute;
    right: 0;
    bottom: 0;
}

#palette
{
	overflow: hidden;
	width: 140px;
	margin: 5px;
	border: 1px solid #555555;
}


#colorPicker #paletteContainer input
{
	cursor: text;
	margin-top: 3px;
	margin-bottom: -2px;
	width: 46px;
	font-size: 90%;
	text-align: center;
	text-transform: uppercase;
}

#colorPicker button:not([disabled])
{
	cursor: pointer;
}

.swatch
{
	border: 1px solid #000000;
	width: 8px;
	height: 8px;
	float: left;
}

.swatch.selected, .swatch.overed
{
	border: 1px solid #FFFFFF;
}
</style>
        <div id="colorPicker">
            <div id="picker" tabindex="0" on-click="{{ showHidePicker }}" on-keydown="{{ onPickerKeydown }}">
                <div class="picker-arrow">
                </div>
            </div>
            <div id="paletteContainer">
                <span></span>
                <input id="inputColor" on-keydown="{{ onInputKeydown }}">
                <div id="palette">
                </div>
            </div>
        </div>
    </template>

    <script>/* globals Polymer, document */
(function()
{
    "use strict";
    var self;
    var mouseCancel = function(event)
        {
            if (event.target != self && !self.contains(event.target))
            {
                cancelChange();
            }
        },

        keyCancel = function(event)
        {
            if (event.which == 27)
            {
                self.$.picker.focus();
                cancelChange();
                event.stopPropagation();
            }
        },

        cancelChange = function()
        {
            document.body.removeEventListener('mousedown', mouseCancel, false);
            document.body.removeEventListener('keydown', keyCancel, false);
            self.$.paletteContainer.hidden = true;
            self.clearSelected();
            self.value = self.oldvalue;
            self = null;
        };

    function XUIColorpicker()
    {
        this.$.paletteContainer.hidden = true;
        this.colorlist = [
            "#000000", "#013380", "#42018C", "#60018C", "#640064", "#800133", "#800000",
            "#561F01", "#412A01", "#808000", "#395001", "#0F6501", "#01422D", "#013E45",

            "#121212", "#0000C5", "#5F01CC", "#8B01CC", "#800080", "#B9014A", "#BE0808",
            "#7E2D01", "#5F3D01", "#988F01", "#486401", "#008000", "#016042", "#015A64",

            "#2C2C2C", "#0000FF", "#7700FF", "#AE00FF", "#960096", "#E8015D", "#E61010",
            "#9D3801", "#774C01", "#B2A801", "#587C01", "#179D01", "#017852", "#008080",

            "#505050", "#0B33FF", "#861DFF", "#B71DFF", "#AB01AB", "#FF1270", "#FF0000",
            "#C24601", "#935E01", "#C9BF01", "#679101", "#1BB801", "#019565", "#00A3A3",

            "#888888", "#1F44FF", "#9335FF", "#BF35FF", "#D403D4", "#FF2C80", "#FF3A3A",
            "#E45101", "#AC6E01", "#DBD000", "#79AA01", "#1FD701", "#01AE77", "#00C1C1",

            "#C0C0C0", "#3F63FF", "#A253FF", "#C853FF", "#FF00FF", "#FF4A92", "#FF5656",
            "#FF630D", "#CA8101", "#F3E700", "#8BC301", "#00FF00", "#01CC8B", "#00DEDE",

            "#FFFFFF", "#627FFF", "#B270FF", "#D170FF", "#FF36E5", "#FF69A4", "#FF7373",
            "#FF7D36", "#E79401", "#FFFF00", "#A2E501", "#58FF3D", "#01EAA0", "#00FFFF",
        ];
        this.generateSwatches();
    }

    /**
    * Creates a colorpicker
    *
    * @class  XUIColorpicker
    * @constructor
    *
    * @example
    *     <xui-colorpicker></xui-colorpicker>
    */
    XUIColorpicker.prototype =
    {
        ready: XUIColorpicker,

        publish:
        {
            /**
             * Disables/enables the colorpicker
             *
             * @attribute   disabled
             * @type        Boolean
             * @default     false
             */
            disabled        : { value: false, reflect: true },

            /**
             * Whether the colorpicker allows no value(transparent) or not
             *
             * @attribute   allowTransparent
             * @type        Boolean
             * @default     false
             */
            allowTransparent    : { value: false, reflect: true },

            /**
             * Setsvalue
             *
             * @attribute   value
             * @type        String
             */
            value   : { value: "", reflect: true },

            /**
             * Sets the predefined colors
             *
             * @attribute   optionlist
             * @type        object
             */
            colorlist      : { value: [], reflect: true },

            /**
             * Sets the previous value
             *
             * @attribute   optionlist
             * @type        String
             */
            oldvalue      : { value: "", reflect: true }
        },

        valueChanged: function(oldValue, newValue)
        {
            var isOk  = /#([0-9A-F]{6}$)|#([0-9A-F]{3}$)/i.test(newValue);

            if (!isOk)
            {
                if ((this.allowTransparent && newValue == "#") || newValue == "")
                {

                }
                else
                {
                    this.value = oldValue;
                    return;
                }
            }

            if (newValue.length != 4)
            {
                newValue = (newValue).toUpperCase();
            }
            else
            {
                newValue = (newValue.charAt(0) + newValue.charAt(1) + newValue.charAt(1) + newValue.charAt(2) + newValue.charAt(2) + newValue.charAt(3) + newValue.charAt(3)).toUpperCase();
            }

            this.$.inputColor.value = newValue.replace("#","");

            if (newValue == "#")
            {
                this.$.picker.style.backgroundColor = "transparent";
            }
            else
            {
                this.$.picker.style.backgroundColor = newValue;
            }
            this.fire("change");
        },

        generateSwatches: function()
        {
            var _this = this,
                palette = _this.$.palette,
                colorCount = _this.colorlist.length;

            //remove all children of palette, faster equivalent of innerHTML = ""
            for (var i = palette.childNodes.length - 1; i >= 0; i--)
            {
                palette.removeChild(palette.childNodes[i]);
            }

            for (var i = 0; i < colorCount; i++)
            {
                var color = _this.colorlist[i],
                    swatch = document.createElement("div");

                swatch.classList.add("swatch");
                swatch.setAttribute("hexcolor", color);
                swatch.style.backgroundColor = color;

                swatch.addEventListener("mouseover", function()
                {
                    _this.value = this.getAttribute("hexcolor");
                    _this.clearSelected();
                    this.classList.add("overed");
                });

                swatch.addEventListener("click", function()
                {
                    var hexColor = this.getAttribute("hexcolor");
                    _this.value = hexColor;
                    _this.oldvalue = hexColor;
                    _this.clearSelected();
                    _this.$.paletteContainer.hidden = true;
                    document.body.removeEventListener('mousedown', mouseCancel.bind(_this), false);
                    document.body.removeEventListener('keydown', keyCancel.bind(_this), false);
                    _this.fire("set");
                });

                palette.appendChild(swatch);
            }
        },

        showHidePicker: function(event)
        {
            if (event.which != undefined && event.which != 1)
            {
                return;
            }

            var _this = this,
                paletteContainer = _this.$.paletteContainer,
                hidden = paletteContainer.hidden;
            paletteContainer.hidden = !hidden;

            if (hidden)
            {
                _this.showSelected();
                _this.oldvalue = _this.value;
                self = _this;
                document.body.addEventListener('mousedown', mouseCancel, false);
                document.body.addEventListener('keydown', keyCancel, false);
            }
            else
            {
                _this.clearSelected();
                document.body.removeEventListener('mousedown', mouseCancel, false);
                document.body.removeEventListener('keydown', keyCancel, false);
                self = null;
                //blur colorpicker
            }
        },

        showSelected: function()
        {
            var selfValue = this.value,
                paletteContainer = this.$.paletteContainer,
                selector = "[hexcolor='" + selfValue + "']",
                selectedSwatch = paletteContainer.querySelector(selector);

            if (selectedSwatch)
            {
                selectedSwatch.classList.add("selected");
            }
            this.$.inputColor.value = selfValue.replace("#","");
            this.$.inputColor.focus();
        },

        clearSelected: function()
        {
            var paletteContainer = this.$.paletteContainer;
            var selected = paletteContainer.querySelectorAll(".swatch.selected, .swatch.overed");
            if (selected.length > 0)
            {
                for (var i = selected.length - 1; i >= 0; i--)
                {
                    selected[i].classList.remove("selected", "overed");
                };
            }
        },

        onInputChange: function(event)
        {
            event.stopPropagation();
        },

        onInputKeydown: function(event)
        {
            if (event.which == 13)
            {
                this.value = "#" + this.$.inputColor.value;
                this.oldvalue = this.value;
                this.clearSelected();
                this.showSelected();
                this.fire("set");
            }
            else if (event.which == 9)
            {
                cancelChange();
            }
        },

        onInputDragstart: function(event)
        {
            event.preventDefault();
        },

        onPickerKeydown: function(event)
        {
            if (event.which == 13 || event.which == 32)
            {
                this.$.picker.click();
            }
        },

        reset: function()
        {
            this.value = "";
            this.$.inputColor.value = "";
            this.oldvalue = "";
            this.fire("reset");
        }
    };

    Polymer.call({}, XUIColorpicker.prototype);
})();</script>
</polymer-element>
<polymer-element name="xui-slider" constructor="XUISlider" attributes="value min max step">

    <template>
        <style>#slider
{
	display: inline-flex;
    vertical-align: middle;
}

#slider > *:not([type="text"])
{
    margin-top: 4px;
}

*
{
    outline: none;
}

input[type="range"]
{
    -webkit-appearance: none;
    margin: 0;
    border: 1px solid #141414;
    background-color: #141414;
    width: 70px;
    cursor: pointer;
    height: 12px;
    vertical-align: middle;
}

input[type="range"]::-webkit-slider-thumb
{
    -webkit-appearance: none;
    width: 12px;
    height: 12px;
    background-color: #DBDBDB;
}

#increment,
#decrement
{
    width: 14px;
    height: 14px;
    background-color: #141414;
    background-position: center;
    background-repeat: no-repeat;
    display: inline-block;
    cursor: pointer;
    vertical-align: middle;
}

#increment
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADpJREFUeNpi/P//PwOxgImBBEC54vT09P8Um8yI7EFsJs6cOZMRzgEpRsdpaWn/sYmT74yBC2eAAAMAs6YvUHy2jrAAAAAASUVORK5CYII=");
}

#decrement
{
    background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACtJREFUeNpi/P//PwOxgImBBDBIFLMgc9LT0zF8O3PmTEYYm3G4hwZAgAEATs8KEUeJt/kAAAAASUVORK5CYII=");
}

[type=text]
{
    width: 40px;
    margin-left: 5px;
    cursor: text;
    font-size: 12px;
    color: #999999;
    border: 1px solid #000000;
    height: 20px;
    background-color: #393939;
    padding: 0 4px 0 4px;
}

input[type=text]:not([disabled])
{
    cursor: text;
}

input[type=text]:hover
{
    background-color: #555555;
}
input[type=text]:focus
{
    color: #EEEEEE;
}</style>
        <div id="slider">
            <div id="decrement" on-mousedown=" {{ startDecrement }}" on-mouseout="{{ endDecrement }}"></div>
            <input type="range" value="{{ value }}" min="{{ min }}" max="{{ max }}" step="{{ step }}" id="inputRange" tabindex="-1" on-input="{{ onRangeInput }}" on-change="{{ onRangeChange }}">
            <div id="increment" on-mousedown=" {{ startIncrement }}" on-mouseout="{{ endIncrement }}"></div>
            <input type="text" id="inputText" on-keydown="{{ onInputKeydown }}" on-blur="{{ onInputBlur }}">
        </div>
    </template>

    <script>/* globals Polymer, document */
(function()
{
    "use strict";
    var self, isPressedUp = false, isPressedDown = false, pressedTimer,
        raised = function()
        {
            isPressedUp = false;
            isPressedDown = false;
            clearTimeout(pressedTimer);
            document.removeEventListener("mouseup", raised);
            self.fire("set");
            self = null;
        };

    function XUISlider()
    {
        this.$.inputText.value = this.value;
    }

    /**
    * Creates a slider
    *
    * @class  XUISlider
    * @constructor
    *
    * @example
    *     <xui-slider></xui-slider>
    */
    XUISlider.prototype =
    {
        ready: XUISlider,

        publish:
        {
            /**
             * Disables/enables the slider
             *
             * @attribute   slider
             * @type        Boolean
             * @default     false
             */
            disabled        : { value: false, reflect: true },

            /**
             * if change is due to range
             *
             * @attribute   isRangeChange
             * @type        Boolean
             * @default     false
             */
            isRangeChange : { value: false, reflect: true },

            /**
             * Sets Value
             *
             * @attribute   value
             * @type        String
             */
            value   : { value: 0, reflect: true },

            /**
             * Sets minimum value
             *
             * @attribute   min
             * @type        integer
             */
            min   : { value: 0, reflect: true },

            /**
             * Sets max value
             *
             * @attribute   max
             * @type        integer
             */
            max   : { value: 100, reflect: true },

            /**
             * Sets increment
             *
             * @attribute   step
             * @type        integer
             */
            step   : { value: 1, reflect: true }
        },

        valueChanged: function(oldValue, newValue)
        {
            if (oldValue == newValue)
            {
                return;
            }

            if (isNaN(newValue) ||
                (newValue.toString().trim() == "") ||
                (newValue < this.min) ||
                (newValue > this.max))
            {
                this.value = oldValue;
                return;
            }

            this.$.inputText.value = newValue;
            this.$.inputRange.value = this.value;
            this.fire("change");
        },

        onInputChange: function(event)
        {
            event.stopPropagation();
        },

        onInputDragstart: function(event)
        {
            event.preventDefault();
        },

        startDecrement: function(event)
        {
            if (event.which != 1)
            {
                return;
            }
            isPressedDown = true;
            var delay = 1000;
            var _this = this;
            self = _this;

            var manageDelay = function()
            {
                var pressValue = parseInt(_this.value) - 1;
                if (pressValue >= _this.min)
                {
                    _this.value = pressValue;
                    if (delay > 50)
                    {
                        delay = delay/2;
                    }
                    pressedTimer = setTimeout(manageDelay, delay);
                }
                else
                {
                    raised();
                }

            }
            document.addEventListener("mouseup", raised);
            manageDelay();
        },

        endDecrement: function()
        {
            if (!isPressedDown)
                return;
            raised();
        },

        startIncrement: function(event)
        {
            if (event.which != 1)
            {
                return;
            }
            isPressedUp = true;
            var delay = 1000;
            var _this = this;
            self = _this;

            var manageDelay = function()
            {
                var pressValue = parseInt(_this.value) + 1;
                if (pressValue <= _this.max)
                {
                    _this.value = pressValue;
                    if (delay > 50)
                    {
                        delay = delay/2;
                    }
                    pressedTimer = setTimeout(manageDelay, delay);
                }
                else
                {
                    raised();
                }

            }
            document.addEventListener("mouseup", raised);
            manageDelay();
        },

        endIncrement: function()
        {
            if (!isPressedUp)
                return;
            raised();
        },

        onRangeInput: function(event)
        {
            this.value = this.$.inputRange.value;
        },

        onRangeChange: function(event)
        {
            this.isRangeChange = true;
            this.value = this.$.inputRange.value;
            this.fire("set");
            event.stopPropagation();
        },

        onInputKeydown: function(event)
        {
            if (event.keyCode == 13)
            {
                this.value = this.$.inputText.value;
                this.fire("set");
            }
            else if (event.keyCode == 38)
            {
                this.value = parseInt(this.$.inputText.value) + 1;
                this.fire("set");
                event.preventDefault();
            }
            else if (event.keyCode == 40)
            {
                this.value = parseInt(this.$.inputText.value) - 1;
                this.fire("set");
                event.preventDefault();
            }
        },

        onInputBlur: function(event)
        {
            this.value = this.$.inputText.value;
            this.fire("set");
        }
    };

    Polymer.call({}, XUISlider.prototype);
})();</script>
</polymer-element>
<polymer-element name="xui-volume-slider" constructor="XUIVolumeSlider" attributes="value min max">

    <template>
        <style>:host
{
	overflow: hidden;
	display: inline-block;
	position: relative;
}

:host[disabled]
{

}

bar
{
	background-color: #000000;
	display: inline-block;
	height: 21px;
	width: 59px;
}

overlay
{
	height: 21px;
	width: 59px;
	position: absolute;
	top: 0;
	left: 0;
	z-index: 1;
	background-image: url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAAVCAYAAAD4g5b1AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAGZJREFUeNrs0jEOwCAMQ1GCuFLuv+dSdOmEqCohSkn4Hr1Zz6KqNQWMmUnb5XRQSoAN0um6b0XWu+BTkPUuiOzPsp8JIrtIdrkgspNltxFEdlB2e0FkX2TdCiJ7y4YTRPa0sZcAAwBb7g05oSoNSgAAAABJRU5ErkJggg==");
	pointer-events: none;
}

level
{
	display: block;
	height: 21px;
	background-color: #FFFFFF;
}

:host[disabled] level
{
	background-color: #555555;
}</style>
        <bar id="bar" on-mousedown=" {{ onBarDown }} ">
            <level id="level"></level>
        </bar>
        <overlay></overlay>
    </template>

    <script>/* globals Polymer, document */
(function()
{
    var mouse = {}, self,
        drag = function(event)
        {
            mouse = { x : event.clientX, y : event.clientY };
            var minVal = self.min,
                bar = self.$.bar,
                left = mouse.x - bar.getBoundingClientRect().left,
                maxLeft = bar.offsetWidth,
                range = self.max - minVal;

            if (left < 0)
            {
                left = 0;
            }

            if (left > maxLeft)
            {
                left = maxLeft;
            }
            self.value = (((left / maxLeft) * range) + minVal).toFixed(0);
        },
        drop = function(event)
        {
            mouse = { x : event.clientX, y : event.clientY };
            document.removeEventListener("mousemove", drag);
            document.removeEventListener("mouseup", drop);

            var minVal = self.min,
                bar = self.$.bar,
                left = mouse.x - bar.getBoundingClientRect().left,
                maxLeft = bar.offsetWidth,
                range = self.max - minVal;

            if (left < 0)
            {
                left = 0;
            }

            if (left > maxLeft)
            {
                left = maxLeft;
            }
            self.value = (((left / maxLeft) * range) + minVal).toFixed(0);
            self = null;
        };

    function XUIVolumeSlider()
    {
        this.reinitialise();
    }

    /**
    * Creates a volume slider
    *
    * @class  XUIVolumeSlider
    * @constructor
    *
    * @example
    *     <xui-volume-slider></xui-volume-slider>
    */
    XUIVolumeSlider.prototype =
    {
        ready: XUIVolumeSlider,

        publish:
        {
            /**
             * Disables/enables the volume slider
             *
             * @attribute   slider
             * @type        Boolean
             * @default     false
             */
            disabled        : { value: false, reflect: true },

            /**
             * Sets Value
             *
             * @attribute   value
             * @type        integer
             */
            value   : { value: 0, reflect: true },

            /**
             * Sets minimum value
             *
             * @attribute   min
             * @type        integer
             */
            min   : { value: 0, reflect: true },

            /**
             * Sets max value
             *
             * @attribute   max
             * @type        integer
             */
            max   : { value: 100, reflect: true }
        },

        valueChanged: function(oldValue, newValue)
        {
            if (oldValue == newValue)
            {
                return;
            }

            if (isNaN(newValue) ||
                (newValue.toString().trim() == "") ||
                (newValue < this.min) ||
                (newValue > this.max))
            {
                this.value = oldValue;
                return;
            }

            this.reinitialise();
            this.fire("change");
        },

        onBarDown: function(event)
        {
            if (event.which != 1)
            {
                return;
            }
            mouse = { x : event.clientX, y : event.clientY };
            self = this;
            document.addEventListener("mousemove", drag);
            document.addEventListener("mouseup", drop);
        },

        reinitialise: function()
        {
            var maxLeft = this.$.bar.offsetWidth,
                range = this.max - this.min;

            this.$.level.style.width = ((this.value - this.min) / range) * maxLeft + "px";
            this.setAttribute("title", this.value);
        }
    };

    Polymer.call({}, XUIVolumeSlider.prototype);
})();</script>
</polymer-element>

    <style>@font-face{font-family:"roboto";src:url("data:;base64,AAEAAAARAQAABAAQR1BPUyrL5ocAAd68AABTukdTVUJuAlWmAAIyeAAABUpMVFNIphSiHQAAEiQAAAQPT1MvMrnHATsAAAGYAAAAYGNtYXBSfzfTAAAWNAAABFRjdnQgHuACVAAAHeAAAAAwZnBnbS/mTqsAABqIAAABvGdhc3AACAATAAHesAAAAAxnbHlmzV4yOwAAJigAAZBMaGVhZP8Rz64AAAEcAAAANmhoZWENEwo2AAABVAAAACRobXR4ejx1MwAAAfgAABAsbG9jYVQFt6oAAB4QAAAIGG1heHAGOAOTAAABeAAAACBuYW1llj6naAABtnQAAASDcG9zdEIF7DQAAbr4AAAjtnByZXCxAbNQAAAcRAAAAZwAAQAAAAEAAIZbyAVfDzz1ABkIAAAAAADMR7gzAAAAAM4UzDH8LP3VCVwIdwAAAAkAAgAAAAAAAAABAAAIYv3VAAAJFvws/z8IggABAAAAAAAAAAAAAAAAAAAECwABAAAECwCXABYAXwAFAAEAAAAAAA4AAAIAApsAAwABAAMEnAGQAAUAAAWaBTMAAAEfBZoFMwAAA9EAZgIAAAACAAAAAAAAAAAA4AAC71AAIFsAAAAgAAAAAEdvb2cAAAAN//0IYv3VAAAIYgIrIAABn08BAAAEOgWwACAAIAACAf0AAAAAAAAB/QAAAf0AAAIbAKsCnABQBPwARgSBAG4F2gBoBPwAQAFnAFACpwCEAq8ABgN0ABwEigBOAZQAMAIxACMCJAChA1IAEASCAHEEgQC6BIEAXASBAF8EgQA3BIEAmASBAIQEgQBNBIEAZgSBAFMCBQChAg0AYwQQAEcEgQCYBDAAiAPOADoHKQBgBS4AFAUdALQFEQB2BUUAtAStALQEqQC0BXQAeAW1ALQCQwC+BGoAPQUlALQEUgC0BwcAtAW1ALQFdABxBSAAtAV0AHEFTQC0BP0AYQSwACIFagCTBQ8AFgcRADYFDwBCBOIAFATJAGECKACPA04AJwIoAAsDWAA9A6MABAKBAFIEZgBqBIwAjwQ/AGEEjABiBDsAYwLDADgEjABkBIwAjwIEAJ8CEv++BBoAkAIEAJ8G/gCPBIwAjwSMAGEEjACPBIwAYgK+AI8ELwBnAsQAIgSMAIsEBgAuBg4ALQQGAC4EBgAaBAYAXgK4AD8B+wCvArgAFQVvAIAB/QAAAfsAkARiAGsEqgBGBbAAaATbAB4B8wCRBOsAWgP9AKoGRABYA5UAeAPGAGIEcQB/AjEAIwZEAFgDtgB7AvsAgARJAGMDZABxA2wAagKOAIMEjACZA+4APwIcAKEB/QB3Ai0AXwOlAHgDxgBuBjsAuAasALgG9QB6A/UAcgUuABQFLgAUBS4AFAUuABQFLgAUBS4AFAeC/+wFEQB2BK0AtAStALQErQC0BK0AtAJD/94CQwC+AkP/8QJD/8sFYwAqBbUAtAV0AHEFdABxBXQAcQV0AHEFdABxBEgAWAV0AHEFagCTBWoAkwVqAJMFagCTBOIAFAS5AKMExQCJBGYAagRmAGoEZgBqBGYAagRmAGoEZgBqBsEAOgQ/AGEEOwBjBDsAYwQ7AGMEOwBjAgP/uQIDAJkCA//MAgP/pgSyAEgEjACPBIwAYQSMAGEEjABhBIwAYQSMAGEEkgBHBIwAYQSMAIsEjACLBIwAiwSMAIsEBgAaBKIAmQQGABoFLgAUBGYAagUuABQEZgBqBS4AFARmAGoFEQB2BD8AYQURAHYEPwBhBREAdgQ/AGEFEQB2BD8AYQVFALQFIgBiBWMAKgSqAGIErQC0BDsAYwStALQEOwBjBK0AtAQ7AGMErQC0BDsAYwStALQEOwBjBXQAeASMAGQFdAB4BIwAZAV0AHgEjABkBXQAeASMAGQFtQC0BIwAjwWfAB8EqgABAkP/yAID/6MCQ//AAgP/mwJD//gCA//TAkMALgIEAA4CQwC0AgMAmQatAL4EFgCfBGoAPQIL/7wFJQC0BBoAkAR4AJkEUgC0AgQAnwRSALQCBABuBFIAtAKaAJ8EUgC0AuAAnwQ1ACgCLgAlBbUAtASMAI8FtQC0BIwAjwW1ALQEjACPBIz/4AWIAKEEjACPBXQAcQSMAGEFdABxBIwAYQV0AHEEjABhB6gAaAc+AGEFTQC0Ar4AjwVNALQCvgBrBU0AtAK+AGUE/QBhBC8AZwT9AGEELwBnBP0AYQQvAGcE/QBhBC8AZwSwACICxAAiBLAAIgLsACIEsAAiAsT/+AVqAJMEjACLBWoAkwSMAIsFagCTBIwAiwVqAJMEjACLBWoAkwSMAIsFagCTBIwAiwcRADYGDgAtBOIAFAQGABoE4gAUBMkAYQQGAF4EyQBhBAYAXgTJAGEEBgBeAgQAnwK+/+kFewBsBJcAYQWWAJMEtACLAgv/vAUuABQEZgBqB4L/7AbBADoFdABxBIwAYQT9AGEELwBnAgv/vAGiAFAD0wCrA5oAjANsAIECLACgArgAhQIyAEQD0wCHAvoAZAKgALYAAPzRAAD9bwAA/I0AAP1bAAD8LAAA/TwCDgDDBBUAoQUuABQCHQChBRH/4wYZABQCpwAYBYgARAVG/4EFagA9AqD/zQUuABQFHQC0BHQAtAWnAB4ErQC0BMkAYQW1ALQFdABxAkMAvgUlALQFQQAxBwcAtAW1ALQElQB7BXQAcQW3ALQFIAC0BJUARgSwACIE4gAUBZ8AVAUPAEIFiABXBVYAcAJD/8sE4gAUBIYAYgRPAGIEjACPAqAAxQSMAI0EhgBiBL0AnQQHAC4EjABhBE8AYgQvAHMEjACPBI0AdwKgAMUEeACZBIwAOASMAJkEBgAuBBMAVgSMAGEExQBPBIwAjwROAGIEjABhBDAAUQSMAI0FqgBTBHcAXgWgAFsGzQBsAqD/2ASMAI0EjABhBIwAjQbNAGwE8QBxBEH/6gZIAE4ErQC0BK0AtAYBACkEdAC0BWoAhwT9AGECQwC+AkP/ywRqAD0ImQAyCKQAtAaGAEIFJQC0BbUAtAURAFUFtwC0BS4AFAUMAKMFHQC0BHQAtAYOADAErQC0B00AHAVpAHgFtQC0BbUAtAUlALQFqwAxBwcAtAW1ALQFdABxBbcAtAUgALQFEQB2BLAAIgUHAFUGNwBVBQ8AQgYoALUFgQCTB4wAtAfKALQGDAAWBvYAtAUKAKMFaQC1ByEAvgUhAGMEZgBqBG0AYQSMAJADUQCPBN8ALgQ7AGMGIAAVBBAAWASMAI8EjACPBD4AmQRtABoF+ACZBIwAjwSMAGEEjACPBIwAjwQ/AGEEGABHBAYAGgXNAGIEBgAuBMIAjwRrAH8GbQCPBsQAjwT0AB0GUQCtBFkAmQROAGMGhwCZBIsATgQ7AGMEOwBjBIz/5wNRAI8ETwBrBC8AZwIEAJ8CA/+mAhL/vgb2AEEG9QCPBIwAEwQ+AJkEjACPBAYAGgSMAI8HBQCdBhgAfAUK/80EWf/bBy0AvwX6AJcE0wArBEkADQcNANEGDQC6Bt8AlQXsAJUJFgC+B+MAmQQlAEoD2gBJBYgAVwWgAFsFdABxBI0AYQUPABYEBwAuBQ8AFgQH//4JegBxCJIAYQV0AHEEjABhBv4AnQYYAHsHBgCdBhkAfAU4AHYESwBiBQIAcASNANQEuQD7AxMBAANPASwIHAA7B9gATQW1ALQEjACPBQr/zQRZ/9sFHQC0BIsAjwRkAKMDkwCPBHT//ANR//ME5gC0BAgAjwdNABwGIAAVBL8AeAQQAFgFJQC0BD4AmQUPAKMEaACZBTn/9QQu/88GkABDBY4AQQW1ALQEjACPB8QAtAWwAI8IMwC0BvoAjwXuAHEE1wBsBREAdgQ/AGEEsAAiBBgARwTiABQEBwAuBOIAFAQHAC4FDwBCBAYALgc3ADcFkwAgBYEAkwRrAH8FdgCTBGwAfwV2AIoEbACUBssATQS//98GNgBNBL//3wJDAL4HTQAcBiAAFQUPAKMEYACZBasAMQRtABoFtQC0BIwAjwW1ALQEjACPBYEAkwRrAH8HBwC0BfgAmQJDAL4FLgAUBGYAagUuABQEZgBqB4L/7AbBADoErQC0BDsAYwWRAFkEQgB0BZEAWQRCAHQGlwAcBcEAFQVpAHgETwBYBKoAaQSqAGkFtQC0BIwAjwW1ALQEjACPBXQAcQSMAGEFdABxBI0AYQV0AHEEjQBhBWkAtQROAGMFBwBVBAYAGgUHAFUEBgAaBQcAVQQGABoFgQCTBGsAfwR0ALQDUQCPBvYAtAZRAK0EvwBBA0kAQgUPAEIEBgAuBQ8AQgQGAC4FBwBbBIwAYgakAFsG5QBiBlcANgUsADEESwBQBAkAewfCAEUGdgBBCAMAqQaiAI8E9wB2BB4AYgWuACQFIQBGBWkAnARPAGIFqwAxBG0AGgUuABQEZgBqBwcAtAb+AI8HEQA2Bg4ALQcRADYGDgAtBxEANgYOAC0FLgAUBGYAagUuABQEZgBqBS4AFARmAGoFLgAUBGb/owUuABQEZgBqBS4AFARmAGoFLgAUBGYAagUuABQEZgBqBS4AFARmAGoFLgAUBGYAagUuABQEZgBqBS4AFARmAGoErQC0BDsAYwStALQEOwBjBK0AtAQ7AGMErQC0BDsAYwSt/+wEO/+mBK0AtAQ7AGMErQC0BDsAYwStALQEOwBjAkMAvgIDAJkCQwC0AgQAlQV0AHEEjABhBXQAcQSMAGEFdABxBIwAYQV0ADIEjP++BXQAcQSMAGEFdABxBIwAYQV0AHEEjABhBXsAbASXAGEFewBsBJcAYQV7AGwElwBhBXsAbASXAGEFewBsBJcAYQVqAJMEjACLBWoAkwSMAIsFlgCTBLQAiwWWAJMEtACLBZYAkwS0AIsFlgCTBLQAiwWWAJMEtACLBOIAFAQGABoE4gAUBAYAGgTiABQEBgAaBOIAFAQGABoFdP8kBBQAAAgpAAAEFAAACCkAAAK5AAACCgAAAVwAAAR/AAACMAAAAaIAAADRAAAAAAAABYgAtAZ8ALwGfAC8A6cABQGiAFABogBQAaEAUAGiACsC6ABQAvAAUALWAFAEaQBGBJIAVwK3AIkDygChBWQAoQekAEABZwBQApwAUAJnAGwCZwBYBDYAqwOlADsDrQBHA2AAegSpABwEqgBGBpIApASqAGIEQABPBekAfAPSAGoIzACrBQQAZwUYAJgGvwBrB1YAbgeGAHAG3wBrBKIASAWcAKgEsgBGBJIAqATXAD8ILwBoAg3/vASCAGUEMACYBDgAngRAAJoECAApAggAZQR0ABwExwA4BzcAOAeKADgAAAAACDQAWwg1AFwCA/+ZA0wAaAOEAHADbABoBDAAeARoAEcEFgBaA+UAWQJeAE4EeQB4BEAATgRhAB4EiQA3BgIAPwS7ACcFBACJBDAARwRxAF0ErQCZBOMAcATeAIsEywBwBRwAmQOgAJIF+ACZA70AmQRhAJkEDwBAAgMAmQT7AJkE0wBwBB8AmQRHAJkEqgCZBJIAcAR5AJkCBwCgA6QAgQS6ACcECQB4BAr/VQQPAG4ECgBuA6QAgQOkAIEDpQCBAZEAYAIxABMCBP++Awz/oAMHADsEfwBbBKsAdASfAEYEnwCnBJ8AkwQBAB4E1QB9BJ8AYgR5AJkEHwBaA3wAeAN8AHIDlABXA2wAagNbAHECuACbAi0AXwOlAHgEKABHBDAAWAO9AEcDEQBfA2wAgQSq//YEqv/2BDAARwS6ACcEugAnBLoAJwS6ACcEugAnBLoAJwS6ACcEkgBwBEcAmQRHAJkERwCZBEcAmQID/7cCAwCZAgP/ygID/6QFHACZBMsAcATLAHAEywBwBMsAcATLAHAFBACJBQQAiQUEAIkFBACJBGEAHgS6ACcEugAnBLoAJwSSAHAEkgBwBJIAcASSAHAEqgCZBEcAmQRHAJkERwCZBEcAmQRHAJkE0wBwBNMAcATTAHAE0wBwBPsAmQID/6EFBACJ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AecAAwABBAkABwBAAgMAAwABBAkACQAMAkMAAwABBAkACwAUAk8AAwABBAkADAAmAmMAAwABBAkADQBcAokAAwABBAkADgBUAuVGb250IGRhdGEgY29weXJpZ2h0IEdvb2dsZSAyMDEyUm9ib3RvUmVndWxhckdvb2dsZTpSb2JvdG8gUmVndWxhcjoyMDEzUm9ib3RvIFJlZ3VsYXJWZXJzaW9uIDEuMTAwMTQxOyAyMDEzUm9ib3RvLVJlZ3VsYXJSb2JvdG8gaXMgYSB0cmFkZW1hcmsgb2YgR29vZ2xlLkdvb2dsZUdvb2dsZS5jb21DaHJpc3RpYW4gUm9iZXJ0c29uTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMABGAG8AbgB0ACAAZABhAHQAYQAgAGMAbwBwAHkAcgBpAGcAaAB0ACAARwBvAG8AZwBsAGUAIAAyADAAMQAyAFIAbwBiAG8AdABvAFIAZQBnAHUAbABhAHIARwBvAG8AZwBsAGUAOgBSAG8AYgBvAHQAbwAgAFIAZQBnAHUAbABhAHIAOgAyADAAMQAzAFIAbwBiAG8AdABvACAAUgBlAGcAdQBsAGEAcgBWAGUAcgBzAGkAbwBuACAAMQAuADEAMAAwADEANAAxADsAIAAyADAAMQAzAFIAbwBiAG8AdABvAC0AUgBlAGcAdQBsAGEAcgBSAG8AYgBvAHQAbwAgAGkAcwAgAGEAIAB0AHIAYQBkAGUAbQBhAHIAawAgAG8AZgAgAEcAbwBvAGcAbABlAC4ARwBvAG8AZwBsAGUARwBvAG8AZwBsAGUALgBjAG8AbQBDAGgAcgBpAHMAdABpAGEAbgAgAFIAbwBiAGUAcgB0AHMAbwBuAEwAaQBjAGUAbgBzAGUAZAAgAHUAbgBkAGUAcgAgAHQAaABlACAAQQBwAGEAYwBoAGUAIABMAGkAYwBlAG4AcwBlACwAIABWAGUAcgBzAGkAbwBuACAAMgAuADAAaAB0AHQAcAA6AC8ALwB3AHcAdwAuAGEAcABhAGMAaABlAC4AbwByAGcALwBsAGkAYwBlAG4AcwBlAHMALwBMAEkAQwBFAE4AUwBFAC0AMgAuADAAAAIAAAAAAAD/agBkAAAAAAAAAAAAAAAAAAAAAAAAAAAECwAAAQIAAgADAAQABQAGAAcACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEArACjAIQAhQC9AJYA6ACGAI4AiwCdAKkApAEDAIoBBACDAJMA8gDzAI0AlwCIAQUA3gDxAJ4AqgD1APQA9gCiAK0AyQDHAK4AYgBjAJAAZADLAGUAyADKAM8AzADNAM4A6QBmANMA0ADRAK8AZwDwAJEA1gDUANUAaADrAO0AiQBqAGkAawBtAGwAbgCgAG8AcQBwAHIAcwB1AHQAdgB3AOoAeAB6AHkAewB9AHwAuAChAH8AfgCAAIEA7ADuALoBBgEHAQgBCQEKAQsA/QD+AQwBDQEOAQ8A/wEAARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8A+AD5ASABIQEiASMBJAElASYBJwEoASkBKgErASwBLQEuAS8BMADXATEBMgEzATQBNQE2ATcBOAE5AToBOwE8AT0BPgE/AOIA4wFAAUEBQgFDAUQBRQFGAUcBSAFJAUoBSwFMAU0BTgCwALEBTwFQAVEBUgFTAVQBVQFWAVcBWAD7APwA5ADlAVkBWgFbAVwBXQFeAV8BYAFhAWIBYwFkAWUBZgFnAWgBaQFqAWsBbAFtAW4AuwFvAXABcQFyAOYA5wFzAKYBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIA2ADhANsA3ADdAOAA2QDfAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwCfAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEAmwHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B3wHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMB9AH1AfYB9wH4AfkB+gH7AfwB/QH+Af8CAAIBAgICAwIEAgUCBgIHAggCCQIKAgsCDAINAg4CDwIQAhECEgITAhQCFQIWAhcCGAIZAhoCGwIcAh0CHgIfAiACIQIiAiMCJAIlAiYCJwIoAikCKgIrAiwCLQIuAi8CMAIxAjICMwI0AjUCNgI3AjgCOQI6AjsCPAI9Aj4CPwJAAkECQgJDAkQCRQJGAkcCSAJJAkoCSwJMAk0CTgJPAlACUQJSAlMCVAJVAlYCVwJYAlkCWgJbAlwCXQJeAl8CYAJhAmICYwJkAmUCZgJnAmgCaQJqAmsCbAJtAm4CbwJwAnECcgJzAnQCdQJ2AncCeAJ5AnoCewJ8An0CfgJ/AoACgQKCAoMChAKFAoYChwKIAokCigKLAowCjQKOAo8CkAKRApICkwKUApUClgKXApgCmQKaApsCnAKdAp4CnwKgAqECogKjAqQCpQKmAqcCqAKpAqoCqwKsAq0CrgKvArACsQKyArMCtAK1ArYCtwK4ArkCugK7ArwCvQK+Ar8CwALBAsICwwLEAsUCxgLHAsgCyQLKAssCzALNAs4CzwLQAtEC0gLTAtQC1QLWAtcC2ALZAtoC2wLcAt0C3gLfAuAC4QLiAuMC5ALlAuYC5wLoAukC6gLrAuwC7QLuAu8C8ALxAvIC8wL0AvUC9gL3AvgC+QL6AvsC/AL9Av4C/wMAAwEDAgMDAwQDBQMGAwcDCAMJAwoDCwMMAw0DDgMPAxADEQMSAxMDFAMVAxYDFwMYAxkDGgMbAxwDHQMeAx8DIAMhAyIDIwMkAyUDJgMnAygDKQMqAysDLAMtAy4DLwMwAzEDMgMzAzQDNQM2AzcDOAM5AzoDOwM8Az0DPgM/A0ADQQNCA0MDRANFA0YDRwNIA0kDSgNLA0wDTQNOA08DUANRA1IDUwNUA1UDVgCyALMDVwNYALYAtwDEA1kAtAC1AMUAggDCAIcDWgCrAMYDWwNcAL4AvwNdALwDXgNfAPcDYANhA2IDYwNkA2UDZgCMA2cDaANpA2oDawCYAJoAmQDvAKUAkgCcAKcAjwCUAJUAuQNsAMADbQNuA28DcANxA3IDcwN0A3UDdgN3A3gDeQN6A3sDfAN9A34DfwOAA4EDggODA4QDhQOGA4cDiAOJA4oDiwOMA40DjgOPA5ADkQOSA5MDlAOVA5YDlwOYA5kDmgObA5wDnQOeA58DoAOhA6IDowOkA6UDpgOnA6gDqQOqA6sDrAOtA64DrwOwA7EDsgOzA7QDtQO2A7cDuAO5A7oDuwO8A70DvgO/A8ADwQPCA8MDxAPFA8YDxwPIA8kDygPLA8wDzQPOA88D0APRA9ID0wPUA9UD1gPXA9gD2QPaA9sD3APdA94D3wPgA+ED4gPjA+QD5QPmA+cD6APpA+oD6wPsA+0D7gPvA/AD8QPyA/MD9AP1A/YD9wP4A/kD+gP7A/wD/QP+A/8EAAQBBAIEAwQEBAUEBgQHBAgECQQKBAsEDAQNBA4EDwQQBBEEEgROVUxMB3VuaTAwQUQGbWFjcm9uDnBlcmlvZGNlbnRlcmVkB0FtYWNyb24HYW1hY3JvbgZBYnJldmUGYWJyZXZlB0FvZ29uZWsHYW9nb25lawtDY2lyY3VtZmxleAtjY2lyY3VtZmxleAd1bmkwMTBBB3VuaTAxMEIGRGNhcm9uBmRjYXJvbgZEY3JvYXQGZGNyb2F0B0VtYWNyb24HZW1hY3JvbgZFYnJldmUGZWJyZXZlCkVkb3RhY2NlbnQKZWRvdGFjY2VudAdFb2dvbmVrB2VvZ29uZWsGRWNhcm9uBmVjYXJvbgtHY2lyY3VtZmxleAtnY2lyY3VtZmxleAd1bmkwMTIwB3VuaTAxMjEMR2NvbW1hYWNjZW50DGdjb21tYWFjY2VudAtIY2lyY3VtZmxleAtoY2lyY3VtZmxleARIYmFyBGhiYXIGSXRpbGRlBml0aWxkZQdJbWFjcm9uB2ltYWNyb24GSWJyZXZlBmlicmV2ZQdJb2dvbmVrB2lvZ29uZWsKSWRvdGFjY2VudAJJSgJpagtKY2lyY3VtZmxleAtqY2lyY3VtZmxleAxLY29tbWFhY2NlbnQMa2NvbW1hYWNjZW50DGtncmVlbmxhbmRpYwZMYWN1dGUGbGFjdXRlDExjb21tYWFjY2VudAxsY29tbWFhY2NlbnQGTGNhcm9uBmxjYXJvbgRMZG90BGxkb3QGTmFjdXRlBm5hY3V0ZQxOY29tbWFhY2NlbnQMbmNvbW1hYWNjZW50Bk5jYXJvbgZuY2Fyb24LbmFwb3N0cm9waGUDRW5nA2VuZwdPbWFjcm9uB29tYWNyb24GT2JyZXZlBm9icmV2ZQ1PaHVuZ2FydW1sYXV0DW9odW5nYXJ1bWxhdXQGUmFjdXRlBnJhY3V0ZQxSY29tbWFhY2NlbnQMcmNvbW1hYWNjZW50BlJjYXJvbgZyY2Fyb24GU2FjdXRlBnNhY3V0ZQtTY2lyY3VtZmxleAtzY2lyY3VtZmxleAxUY29tbWFhY2NlbnQMdGNvbW1hYWNjZW50BlRjYXJvbgZ0Y2Fyb24EVGJhcgR0YmFyBlV0aWxkZQZ1dGlsZGUHVW1hY3Jvbgd1bWFjcm9uBlVicmV2ZQZ1YnJldmUFVXJpbmcFdXJpbmcNVWh1bmdhcnVtbGF1dA11aHVuZ2FydW1sYXV0B1VvZ29uZWsHdW9nb25lawtXY2lyY3VtZmxleAt3Y2lyY3VtZmxleAtZY2lyY3VtZmxleAt5Y2lyY3VtZmxleAZaYWN1dGUGemFjdXRlClpkb3RhY2NlbnQKemRvdGFjY2VudAVsb25ncwVPaG9ybgVvaG9ybgVVaG9ybgV1aG9ybgd1bmkwMUYwCkFyaW5nYWN1dGUKYXJpbmdhY3V0ZQdBRWFjdXRlB2FlYWN1dGULT3NsYXNoYWN1dGULb3NsYXNoYWN1dGUMU2NvbW1hYWNjZW50DHNjb21tYWFjY2VudAd1bmkwMjM3B3VuaTAyQkMHdW5pMDJGMwlncmF2ZWNvbWIJYWN1dGVjb21iCXRpbGRlY29tYgRob29rB3VuaTAzMEYIZG90YmVsb3cFdG9ub3MNZGllcmVzaXN0b25vcwpBbHBoYXRvbm9zCWFub3RlbGVpYQxFcHNpbG9udG9ub3MIRXRhdG9ub3MJSW90YXRvbm9zDE9taWNyb250b25vcwxVcHNpbG9udG9ub3MKT21lZ2F0b25vcxFpb3RhZGllcmVzaXN0b25vcwVBbHBoYQRCZXRhBUdhbW1hBURlbHRhB0Vwc2lsb24EWmV0YQNFdGEFVGhldGEESW90YQVLYXBwYQZMYW1iZGECTXUCTnUCWGkHT21pY3JvbgJQaQNSaG8FU2lnbWEDVGF1B1Vwc2lsb24DUGhpA0NoaQNQc2kMSW90YWRpZXJlc2lzD1Vwc2lsb25kaWVyZXNpcwphbHBoYXRvbm9zDGVwc2lsb250b25vcwhldGF0b25vcwlpb3RhdG9ub3MUdXBzaWxvbmRpZXJlc2lzdG9ub3MFYWxwaGEEYmV0YQVnYW1tYQVkZWx0YQdlcHNpbG9uBHpldGEDZXRhBXRoZXRhBGlvdGEFa2FwcGEGbGFtYmRhB3VuaTAzQkMCbnUCeGkHb21pY3JvbgNyaG8Gc2lnbWExBXNpZ21hA3RhdQd1cHNpbG9uA3BoaQNjaGkDcHNpBW9tZWdhDGlvdGFkaWVyZXNpcw91cHNpbG9uZGllcmVzaXMMb21pY3JvbnRvbm9zDHVwc2lsb250b25vcwpvbWVnYXRvbm9zB3VuaTAzRDEHdW5pMDNEMgd1bmkwM0Q2B3VuaTA0MDAHdW5pMDQwMQd1bmkwNDAyB3VuaTA0MDMHdW5pMDQwNAd1bmkwNDA1B3VuaTA0MDYHdW5pMDQwNwd1bmkwNDA4B3VuaTA0MDkHdW5pMDQwQQd1bmkwNDBCB3VuaTA0MEMHdW5pMDQwRAd1bmkwNDBFB3VuaTA0MEYHdW5pMDQxMAd1bmkwNDExB3VuaTA0MTIHdW5pMDQxMwd1bmkwNDE0B3VuaTA0MTUHdW5pMDQxNgd1bmkwNDE3B3VuaTA0MTgHdW5pMDQxOQd1bmkwNDFBB3VuaTA0MUIHdW5pMDQxQwd1bmkwNDFEB3VuaTA0MUUHdW5pMDQxRgd1bmkwNDIwB3VuaTA0MjEHdW5pMDQyMgd1bmkwNDIzB3VuaTA0MjQHdW5pMDQyNQd1bmkwNDI2B3VuaTA0MjcHdW5pMDQyOAd1bmkwNDI5B3VuaTA0MkEHdW5pMDQyQgd1bmkwNDJDB3VuaTA0MkQHdW5pMDQyRQd1bmkwNDJGB3VuaTA0MzAHdW5pMDQzMQd1bmkwNDMyB3VuaTA0MzMHdW5pMDQzNAd1bmkwNDM1B3VuaTA0MzYHdW5pMDQzNwd1bmkwNDM4B3VuaTA0MzkHdW5pMDQzQQd1bmkwNDNCB3VuaTA0M0MHdW5pMDQzRAd1bmkwNDNFB3VuaTA0M0YHdW5pMDQ0MAd1bmkwNDQxB3VuaTA0NDIHdW5pMDQ0Mwd1bmkwNDQ0B3VuaTA0NDUHdW5pMDQ0Ngd1bmkwNDQ3B3VuaTA0NDgHdW5pMDQ0OQd1bmkwNDRBB3VuaTA0NEIHdW5pMDQ0Qwd1bmkwNDREB3VuaTA0NEUHdW5pMDQ0Rgd1bmkwNDUwB3VuaTA0NTEHdW5pMDQ1Mgd1bmkwNDUzB3VuaTA0NTQHdW5pMDQ1NQd1bmkwNDU2B3VuaTA0NTcHdW5pMDQ1OAd1bmkwNDU5B3VuaTA0NUEHdW5pMDQ1Qgd1bmkwNDVDB3VuaTA0NUQHdW5pMDQ1RQd1bmkwNDVGB3VuaTA0NjAHdW5pMDQ2MQd1bmkwNDYyB3VuaTA0NjMHdW5pMDQ2NAd1bmkwNDY1B3VuaTA0NjYHdW5pMDQ2Nwd1bmkwNDY4B3VuaTA0NjkHdW5pMDQ2QQd1bmkwNDZCB3VuaTA0NkMHdW5pMDQ2RAd1bmkwNDZFB3VuaTA0NkYHdW5pMDQ3MAd1bmkwNDcxB3VuaTA0NzIHdW5pMDQ3Mwd1bmkwNDc0B3VuaTA0NzUHdW5pMDQ3Ngd1bmkwNDc3B3VuaTA0NzgHdW5pMDQ3OQd1bmkwNDdBB3VuaTA0N0IHdW5pMDQ3Qwd1bmkwNDdEB3VuaTA0N0UHdW5pMDQ3Rgd1bmkwNDgwB3VuaTA0ODEHdW5pMDQ4Mgd1bmkwNDgzB3VuaTA0ODQHdW5pMDQ4NQd1bmkwNDg2B3VuaTA0ODgHdW5pMDQ4OQd1bmkwNDhBB3VuaTA0OEIHdW5pMDQ4Qwd1bmkwNDhEB3VuaTA0OEUHdW5pMDQ4Rgd1bmkwNDkwB3VuaTA0OTEHdW5pMDQ5Mgd1bmkwNDkzB3VuaTA0OTQHdW5pMDQ5NQd1bmkwNDk2B3VuaTA0OTcHdW5pMDQ5OAd1bmkwNDk5B3VuaTA0OUEHdW5pMDQ5Qgd1bmkwNDlDB3VuaTA0OUQHdW5pMDQ5RQd1bmkwNDlGB3VuaTA0QTAHdW5pMDRBMQd1bmkwNEEyB3VuaTA0QTMHdW5pMDRBNAd1bmkwNEE1B3VuaTA0QTYHdW5pMDRBNwd1bmkwNEE4B3VuaTA0QTkHdW5pMDRBQQd1bmkwNEFCB3VuaTA0QUMHdW5pMDRBRAd1bmkwNEFFB3VuaTA0QUYHdW5pMDRCMAd1bmkwNEIxB3VuaTA0QjIHdW5pMDRCMwd1bmkwNEI0B3VuaTA0QjUHdW5pMDRCNgd1bmkwNEI3B3VuaTA0QjgHdW5pMDRCOQd1bmkwNEJBB3VuaTA0QkIHdW5pMDRCQwd1bmkwNEJEB3VuaTA0QkUHdW5pMDRCRgd1bmkwNEMwB3VuaTA0QzEHdW5pMDRDMgd1bmkwNEMzB3VuaTA0QzQHdW5pMDRDNQd1bmkwNEM2B3VuaTA0QzcHdW5pMDRDOAd1bmkwNEM5B3VuaTA0Q0EHdW5pMDRDQgd1bmkwNENDB3VuaTA0Q0QHdW5pMDRDRQd1bmkwNENGB3VuaTA0RDAHdW5pMDREMQd1bmkwNEQyB3VuaTA0RDMHdW5pMDRENAd1bmkwNEQ1B3VuaTA0RDYHdW5pMDRENwd1bmkwNEQ4B3VuaTA0RDkHdW5pMDREQQd1bmkwNERCB3VuaTA0REMHdW5pMDRERAd1bmkwNERFB3VuaTA0REYHdW5pMDRFMAd1bmkwNEUxB3VuaTA0RTIHdW5pMDRFMwd1bmkwNEU0B3VuaTA0RTUHdW5pMDRFNgd1bmkwNEU3B3VuaTA0RTgHdW5pMDRFOQd1bmkwNEVBB3VuaTA0RUIHdW5pMDRFQwd1bmkwNEVEB3VuaTA0RUUHdW5pMDRFRgd1bmkwNEYwB3VuaTA0RjEHdW5pMDRGMgd1bmkwNEYzB3VuaTA0RjQHdW5pMDRGNQd1bmkwNEY2B3VuaTA0RjcHdW5pMDRGOAd1bmkwNEY5B3VuaTA0RkEHdW5pMDRGQgd1bmkwNEZDB3VuaTA0RkQHdW5pMDRGRQd1bmkwNEZGB3VuaTA1MDAHdW5pMDUwMQd1bmkwNTAyB3VuaTA1MDMHdW5pMDUwNAd1bmkwNTA1B3VuaTA1MDYHdW5pMDUwNwd1bmkwNTA4B3VuaTA1MDkHdW5pMDUwQQd1bmkwNTBCB3VuaTA1MEMHdW5pMDUwRAd1bmkwNTBFB3VuaTA1MEYHdW5pMDUxMAd1bmkwNTExB3VuaTA1MTIHdW5pMDUxMwd1bmkxRTAwB3VuaTFFMDEHdW5pMUUzRQd1bmkxRTNGBldncmF2ZQZ3Z3JhdmUGV2FjdXRlBndhY3V0ZQlXZGllcmVzaXMJd2RpZXJlc2lzB3VuaTFFQTAHdW5pMUVBMQd1bmkxRUEyB3VuaTFFQTMHdW5pMUVBNAd1bmkxRUE1B3VuaTFFQTYHdW5pMUVBNwd1bmkxRUE4B3VuaTFFQTkHdW5pMUVBQQd1bmkxRUFCB3VuaTFFQUMHdW5pMUVBRAd1bmkxRUFFB3VuaTFFQUYHdW5pMUVCMAd1bmkxRUIxB3VuaTFFQjIHdW5pMUVCMwd1bmkxRUI0B3VuaTFFQjUHdW5pMUVCNgd1bmkxRUI3B3VuaTFFQjgHdW5pMUVCOQd1bmkxRUJBB3VuaTFFQkIHdW5pMUVCQwd1bmkxRUJEB3VuaTFFQkUHdW5pMUVCRgd1bmkxRUMwB3VuaTFFQzEHdW5pMUVDMgd1bmkxRUMzB3VuaTFFQzQHdW5pMUVDNQd1bmkxRUM2B3VuaTFFQzcHdW5pMUVDOAd1bmkxRUM5B3VuaTFFQ0EHdW5pMUVDQgd1bmkxRUNDB3VuaTFFQ0QHdW5pMUVDRQd1bmkxRUNGB3VuaTFFRDAHdW5pMUVEMQd1bmkxRUQyB3VuaTFFRDMHdW5pMUVENAd1bmkxRUQ1B3VuaTFFRDYHdW5pMUVENwd1bmkxRUQ4B3VuaTFFRDkHdW5pMUVEQQd1bmkxRURCB3VuaTFFREMHdW5pMUVERAd1bmkxRURFB3VuaTFFREYHdW5pMUVFMAd1bmkxRUUxB3VuaTFFRTIHdW5pMUVFMwd1bmkxRUU0B3VuaTFFRTUHdW5pMUVFNgd1bmkxRUU3B3VuaTFFRTgHdW5pMUVFOQd1bmkxRUVBB3VuaTFFRUIHdW5pMUVFQwd1bmkxRUVEB3VuaTFFRUUHdW5pMUVFRgd1bmkxRUYwB3VuaTFFRjEGWWdyYXZlBnlncmF2ZQd1bmkxRUY0B3VuaTFFRjUHdW5pMUVGNgd1bmkxRUY3B3VuaTFFRjgHdW5pMUVGOQd1bmkxRjREB3VuaTIwMDAHdW5pMjAwMQd1bmkyMDAyB3VuaTIwMDMHdW5pMjAwNAd1bmkyMDA1B3VuaTIwMDYHdW5pMjAwNwd1bmkyMDA4B3VuaTIwMDkHdW5pMjAwQQd1bmkyMDBCB3VuaTIwMTUNdW5kZXJzY29yZWRibA1xdW90ZXJldmVyc2VkB3VuaTIwMjUGbWludXRlBnNlY29uZAlleGNsYW1kYmwHdW5pMjA3NAluc3VwZXJpb3IEbGlyYQZwZXNldGEHdW5pMjBBQgRFdXJvB3VuaTIxMDUHdW5pMjExMwd1bmkyMTE2CWVzdGltYXRlZAlvbmVlaWdodGgMdGhyZWVlaWdodGhzC2ZpdmVlaWdodGhzDHNldmVuZWlnaHRocwtjb21tYWFjY2VudAd1bmlGQjAyB3VuaUZCMDMHdW5pRkIwNAd1bmlGRUZGB3VuaUZGRkMHdW5pRkZGRAxJbWFjcm9uLnNtY3AJZGFzaWFveGlhCWVpZ2h0LnN1cAhuaW5lLnN1cAhzaXguc21jcAlmb3VyLnNtY3AKdGhyZWUuc21jcAh0d28uc21jcAhvbmUuc21jcAl6ZXJvLnNtY3AGWi5zbWNwBlkuc21jcAZYLnNtY3AGVy5zbWNwBlYuc21jcAZVLnNtY3AGVC5zbWNwBlMuc21jcAZSLnNtY3AGUS5zbWNwCXplcm8ubG51bQZPLnNtY3AGTi5zbWNwCGNyb3NzYmFyBk0uc21jcAZMLnNtY3AGSy5zbWNwBkouc21jcAZJLnNtY3AGSC5zbWNwBkcuc21jcAZGLnNtY3AGRS5zbWNwBkQuc21jcAZDLnNtY3AGQi5zbWNwEWNvbW1hYWNjZW50cm90YXRlDmJyZXZlZ3JhdmVjb21iBkEuc21jcBNjaXJjdW1mbGV4YWN1dGVjb21iE2NpcmN1bWZsZXhncmF2ZWNvbWISY2lyY3VtZmxleGhvb2tjb21iE2NpcmN1bWZsZXh0aWxkZWNvbWIOYnJldmVhY3V0ZWNvbWINYnJldmVob29rY29tYg5icmV2ZXRpbGRlY29tYgtjeXJpbGxpY3RpYxBjeXJpbGxpY2hvb2tsZWZ0DGN5cmlsbGljaG9vaw5sYXJnZXJpZ2h0aG9vawhvbmUubG51bQh0d28ubG51bQp0aHJlZS5sbnVtCWZvdXIubG51bQlmaXZlLmxudW0Ic2l4LmxudW0Kc2V2ZW4ubG51bQplaWdodC5sbnVtCW5pbmUubG51bQZQLnNtY3AJZml2ZS5zbWNwB3NpeC5zdXAIZml2ZS5zdXAIZm91ci5zdXAJdGhyZWUuc3VwB3R3by5zdXAJcmluZ2FjdXRlB29uZS5zdXAIemVyby5zdXAJbmluZS5zbWNwCmVpZ2h0LnNtY3AKc2V2ZW4uc21jcAlzZXZlbi5zdXANY3lyaWxsaWNicmV2ZQtEY3JvYXQuc21jcAhFdGguc21jcAlUYmFyLnNtY3ALQWdyYXZlLnNtY3ALQWFjdXRlLnNtY3AQQWNpcmN1bWZsZXguc21jcAtBdGlsZGUuc21jcA5BZGllcmVzaXMuc21jcApBcmluZy5zbWNwD0FyaW5nYWN1dGUuc21jcA1DY2VkaWxsYS5zbWNwC0VncmF2ZS5zbWNwC0VhY3V0ZS5zbWNwEEVjaXJjdW1mbGV4LnNtY3AORWRpZXJlc2lzLnNtY3ALSWdyYXZlLnNtY3ALSWFjdXRlLnNtY3AQSWNpcmN1bWZsZXguc21jcA5JZGllcmVzaXMuc21jcAtOdGlsZGUuc21jcAtPZ3JhdmUuc21jcAtPYWN1dGUuc21jcBBPY2lyY3VtZmxleC5zbWNwC090aWxkZS5zbWNwDk9kaWVyZXNpcy5zbWNwC1VncmF2ZS5zbWNwC1VhY3V0ZS5zbWNwEFVjaXJjdW1mbGV4LnNtY3AOVWRpZXJlc2lzLnNtY3ALWWFjdXRlLnNtY3AMQW1hY3Jvbi5zbWNwC0FicmV2ZS5zbWNwDEFvZ29uZWsuc21jcAtDYWN1dGUuc21jcBBDY2lyY3VtZmxleC5zbWNwDHVuaTAxMEEuc21jcAtDY2Fyb24uc21jcAtEY2Fyb24uc21jcAxFbWFjcm9uLnNtY3ALRWJyZXZlLnNtY3APRWRvdGFjY2VudC5zbWNwDEVvZ29uZWsuc21jcAtFY2Fyb24uc21jcBBHY2lyY3VtZmxleC5zbWNwC0dicmV2ZS5zbWNwDHVuaTAxMjAuc21jcBFHY29tbWFhY2NlbnQuc21jcBBIY2lyY3VtZmxleC5zbWNwC0l0aWxkZS5zbWNwElVodW5nYXJ1bWxhdXQuc21jcAtJYnJldmUuc21jcAxJb2dvbmVrLnNtY3APSWRvdGFjY2VudC5zbWNwEEpjaXJjdW1mbGV4LnNtY3ARS2NvbW1hYWNjZW50LnNtY3ALTGFjdXRlLnNtY3ARTGNvbW1hYWNjZW50LnNtY3ALTGNhcm9uLnNtY3AJTGRvdC5zbWNwC05hY3V0ZS5zbWNwEU5jb21tYWFjY2VudC5zbWNwC05jYXJvbi5zbWNwDE9tYWNyb24uc21jcAtPYnJldmUuc21jcBJPaHVuZ2FydW1sYXV0LnNtY3ALUmFjdXRlLnNtY3ARUmNvbW1hYWNjZW50LnNtY3ALUmNhcm9uLnNtY3ALU2FjdXRlLnNtY3AQU2NpcmN1bWZsZXguc21jcA1TY2VkaWxsYS5zbWNwC1NjYXJvbi5zbWNwEVRjb21tYWFjY2VudC5zbWNwC1RjYXJvbi5zbWNwC1V0aWxkZS5zbWNwDFVtYWNyb24uc21jcAtVYnJldmUuc21jcApVcmluZy5zbWNwD2dlcm1hbmRibHMuc21jcAtaY2Fyb24uc21jcA9aZG90YWNjZW50LnNtY3ALWmFjdXRlLnNtY3AOWWRpZXJlc2lzLnNtY3AQWWNpcmN1bWZsZXguc21jcBBXY2lyY3VtZmxleC5zbWNwDFVvZ29uZWsuc21jcAAAAAEAAgAIAAL//wAPAAEAAAAKADAARAACREZMVAAObGF0bgAaAAQAAAAA//8AAQAAAAQAAAAA//8AAQABAAJrZXJuAA5rZXJuAA4AAAABAAAAAQAEAAIAAAACAAoyqAABAy4ABAAAAZIx5jHmBlYwPB70LaYxxDDEBqww4DDgLWQNeDDgMOAxxCH+CdYKUC24LSQwJi/KMSQNpAq2MKYukjDaCvgMIjECLpINljGmDRgwIDGmDTYwPDA8MDwwPDA8MDwtpjDEMMQwxDDEMOAw4DDgMOAxxDDgMcQxxDHEMcQxxDEkMKYwpjCmMKYwpjCmMNow2jDaMNoxAjECMQIxAjECMaYukjGmMDwwpjA8MKYwPDCmLaYtpi2mLaYxxDHEMMQw2jDEMNowxDDaMMQw2jDEMNow4DDgMOAw4DDgMOAtZA14DXgNeA14MOAw4DDgMcQxAjHEMQIxxDECDZYNlg2WLbgtuC24MCYxJDGmMSQNpA2kDaQwPDCmMeYwPDDEMOAw4DHEMSQwPB70LvowPDDEDaQw4DHEMOAtZDA8MOAw4A22McQh/g6gLbgxJA+OL8oQbDDgMSQRDjGmERQRHhPgFboxphakMQIukheeF6QZjhnEG1YbiDECMMQwxBwGLvow4DDgLNws3B10LWQurDDgMDweBh70Lvoe/jDEL8ohODDgLWQw4DDgMOAxxCH+LaYtuC6sL8ow4DDgIiAs3CzcI7IkcCT6MKYlVCYuL8AmtDDaMCAm2icEMQIukiheMaYukjAgKswrBi0CLQIukiwwMNow2i/ALLItAi0CMaYs3C0CMDwxAi0kMaYtJDGmLTouki76L8Au+i/KMCAtZC1kLWQtZDDgLaYtuDEkMaYxJC/KMCAw4C/KMCAw4DDgMOAwPDCmMDwwpjDEMNow2jDaL8owIDHEMQIxAi6SLqwxpi6sMaYurDGmLvovwC/AL8owIDA8MKYw4DAmMCYwJjA8MKYwPDCmMDwwpjA8MKYwPDCmMDwwpjA8MKYwPDCmMDwwpjA8MKYwPDCmMDwwpjDEMNowxDDaMMQw2jDEMNowxDDaMMQw2jDEMNowxDDaMOAw4DHEMQIxxDECMcQxAjHEMQIxxDECMcQxAjHEMQIxAjEkMaYxJDGmMSQxpjEkMaYxxDHmMeYx5jHmMeYx5jHmMggx7DJ0MgIyCDIOMiQyNjJIMloydDJ6MoQAAQGSAAUACgALACQAJQAmACcAKAApACsALAAuAC8AMAAxADIAMwA0ADUANwA5ADoAOwA8AD0APgBEAEUASABJAE4AUgBTAFUAWQBaAFsAXABeAIIAgwCEAIUAhgCHAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAnwCiAKMApAClAKYApwCqAKsArACtALQAtQC2ALcAuAC/AMAAwQDCAMMAxADFAMYAxwDIAMoAzADOANAA0gDUANUA1gDXANgA2QDaANsA3ADdAOYA6gDsAO4A8ADyAPgA+wD9AP8BAQEFAQcBCQEOAQ8BEAERARIBEwEXARkBGwEkASYBKAE2ATgBOQE6ATsBPQE/AUgBSQFRAWMBZQFmAWcBaAFpAWwBbQFuAW8BcAFxAXIBcwF0AXUBdgF3AXgBeQF6AXwBfQF+AX8BgAGBAYIBhAGFAYsBjQGOAZABkwGVAZcBmAGZAZsBnQGeAaABoQGiAaMBpgGsAa0BrgGvAbIBswG1AbYBtwG4AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHGAccByAHJAcoBzAHNAc4BzwHRAdIB1AHVAdYB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMB5gHqAewB7gHvAfAB8QHyAfUB9gH4AfkB+gH8Af0B/wIAAgUCBgIKAg4CDwISAh8CIAIhAiICIwItAjoCOwI8Aj0CQQJCAkUCRwJJAksCTQJVAlcCWQJaAlsCXQJeAmsCbAJtAnQCeAJ6AnsCfAJ9An4CgQKCAoQChgKHAogCkQKSApYCmAKZApoCmwKcAp0CngKhAqICpgKnAqgCvwLAAsECwwLFAscCyQLKAssCzALNAs4CzwLQAtEC0gLTAtQC1QLWAtcC2ALZAtoC2wLcAt0C3gLfAuAC4QLiAuMC5ALlAuYC5wLoAukC6gLrAuwC7QLuAu8C8ALxAvMC9QL2AvcC+AL5AvoC+wL8Av0C/gL/AwADAQMCAwoDGwMcAx0DHgMfAyADIQMiAyMDNAM1AzcDOAM5A0EDQgN1A3YDdwN4A3kDewN9A34DgAOEA4UDjAORABUAOQAUADoAJQA8ABYAnwAWATYAJQE4ABYBOgAWAWkAFgF/ABYBhQAWAiAAFAIiABQCWQAWAlsAFgLDACUCxQAlAscAJQMbABYDHQAWAx8AFgMhABYAygAP/u8AEf7vAB3+7wAk/8UANwAUAET/3gBG/+sAR//rAEj/6wBK/+sAUv/rAFT/6wBV/+YAWP/qAFn/6ABc/+gAgv/FAIP/xQCE/8UAhf/FAIb/xQCH/8UAov/eAKP/3gCk/94Apf/eAKb/3gCn/94Aqf/rAKr/6wCr/+sArP/rAK3/6wC0/+sAtf/rALb/6wC3/+sAuP/rALv/6gC8/+oAvf/qAL7/6gC//+gAwf/oAML/xQDD/94AxP/FAMX/3gDG/8UAx//eAMn/6wDL/+sAzf/rAM//6wDR/+sA1f/rANf/6wDZ/+sA2//rAN3/6wDf/+sA4f/rAOP/6wDl/+sBD//rARH/6wET/+sBFf/rASQAFAEmABQBK//qAS3/6gEv/+oBMf/qATP/6gE1/+oBOf/oAUT/6wFG/+oBSP/FAUn/3gFj/8UBbP/FAW//xQF2/8UBhv/rAYr/6gGL/+sBjf/oAZf/6AGZ/+sBnP/rAZ3/6wGf/+oBpf/qAab/6wGn/+oBrgAUAbcAFAG8/8UBzgAUAdz/3gHh/+sB6v/rAe3/6wHv/+gB8P/rAfz/6wH9/+sCAP/rAgr/6AIS/8UCH//rAiH/6AIj/+gCJf/rAin/6wIt/+sCSwAUAlT/6wJW/+sCVwAUAlr/6AJfABQCe//FAnz/3gJ9/8UCfv/eAoL/6wKE/+sChv/rApL/6wKU/+sClv/rApr/6AKc/+gCnv/oAqz/6wKt/+sCrv/rArj/6wK//8UCwP/eAsn/xQLK/94Cy//FAsz/3gLN/8UCzv/eAs//xQLQ/94C0f/FAtL/3gLT/8UC1P/eAtX/xQLW/94C1//FAtj/3gLZ/8UC2v/eAtv/xQLc/94C3f/FAt7/3gLf/8UC4P/eAuL/6wLk/+sC5v/rAuj/6wLq/+sC7P/rAu7/6wLw/+sC9v/rAvj/6wL6/+sC/P/rAv7/6wMA/+sDAv/rAwT/6wMG/+sDCP/rAwr/6wMM/+sDDv/qAxD/6gMS/+oDFP/qAxb/6gMY/+oDGv/qAxz/6AMe/+gDIP/oAyL/6AM2/u8DOv7vAz7+7wM//u8AHgA3/98AOf/kADr/7AA8/90An//dAST/3wEm/98BNv/sATj/3QE6/90Baf/dAX//3QGF/90Brv/fAbf/3wHO/98CIP/kAiL/5AJL/98CV//fAln/3QJb/90CX//fAsP/7ALF/+wCx//sAxv/3QMd/90DH//dAyH/3QAZADf/zgA5/+0APP/QAJ//0AEk/84BJv/OATj/0AE6/9ABaf/QAX//0AGF/9ABrv/OAbf/zgHO/84CIP/tAiL/7QJL/84CV//OAln/0AJb/9ACX//OAxv/0AMd/9ADH//QAyH/0AAQAC3/7gA4/+4Am//uAJz/7gCd/+4Anv/uAPb/7gEq/+4BLP/uAS7/7gEw/+4BMv/uATT/7gG0/+4DDf/uAw//7gBKAAUAEAAKABAADAAUAEAAEgBG/+gAR//oAEj/6ABK/+gAVP/oAGAAEwCp/+gAqv/oAKv/6ACs/+gArf/oAMn/6ADL/+gAzf/oAM//6ADR/+gA1f/oANf/6ADZ/+gA2//oAN3/6ADf/+gA4f/oAOP/6ADl/+gBFf/oAUT/6AFRABABhv/oAYv/6AGc/+gBnf/oAeH/6AHt/+gB8P/oAfz/6AH9/+gCAP/oAiX/6AIp/+gCLf/oAlT/6AJW/+gCgv/oAoT/6AKG/+gClP/oAqz/6AKt/+gCrv/oArj/6ALi/+gC5P/oAub/6ALo/+gC6v/oAuz/6ALu/+gC8P/oAwT/6AMG/+gDCP/oAwz/6AM0ABADNQAQAzcAEAM4ABADOQAQA0EAEANCABAAPQBG/+wAR//sAEj/7ABK/+wAVP/sAKn/7ACq/+wAq//sAKz/7ACt/+wAyf/sAMv/7ADN/+wAz//sANH/7ADV/+wA1//sANn/7ADb/+wA3f/sAN//7ADh/+wA4//sAOX/7AEV/+wBRP/sAYb/7AGL/+wBnP/sAZ3/7AHh/+wB7f/sAfD/7AH8/+wB/f/sAgD/7AIl/+wCKf/sAi3/7AJU/+wCVv/sAoL/7AKE/+wChv/sApT/7AKs/+wCrf/sAq7/7AK4/+wC4v/sAuT/7ALm/+wC6P/sAur/7ALs/+wC7v/sAvD/7AME/+wDBv/sAwj/7AMM/+wABwAP/4QAEf+EAB3/hAM2/4QDOv+EAz7/hAM//4QAEAAt/+wAOP/sAJv/7ACc/+wAnf/sAJ7/7AD2/+wBKv/sASz/7AEu/+wBMP/sATL/7AE0/+wBtP/sAw3/7AMP/+wABwBa/8wDdv+1A3j/1gN5/7cDev/uA3v/uwN+//IAAwBJAA8AVwARAFoAEQAEAFr/5QGA/8sBov/kA37/7AA6ACb/8wAq//MAMv/zADT/8wCJ//MAlP/zAJX/8wCW//MAl//zAJj/8wCa//MAyP/zAMr/8wDM//MAzv/zAN7/8wDg//MA4v/zAOT/8wEO//MBEP/zARL/8wEU//MBQ//zAUz/8wFo//MBc//zAXr/8wGVAA0BsP/zAcr/8wHN//MCDP/zAh7/8wIk//MCJv/zAij/8wIq//MCLP/zAlP/8wJV//MCkf/zApP/8wKV//MCt//zAvX/8wL3//MC+f/zAvv/8wL9//MC///zAwH/8wMD//MDBf/zAwf/8wMJ//MDC//zAyP/8wA7ACb/5gAq/+YAMv/mADT/5gCJ/+YAlP/mAJX/5gCW/+YAl//mAJj/5gCa/+YAyP/mAMr/5gDM/+YAzv/mAN7/5gDg/+YA4v/mAOT/5gEO/+YBEP/mARL/5gEU/+YBQ//mAUz/5gFo/+YBc//mAXr/5gGA/8IBlQAQAbD/5gHK/+YBzf/mAgz/5gIe/+YCJP/mAib/5gIo/+YCKv/mAiz/5gJT/+YCVf/mApH/5gKT/+YClf/mArf/5gL1/+YC9//mAvn/5gL7/+YC/f/mAv//5gMB/+YDA//mAwX/5gMH/+YDCf/mAwv/5gMj/+YANwAk/+QAO//SADz/0wCC/+QAg//kAIT/5ACF/+QAhv/kAIf/5ACf/9MAwv/kAMT/5ADG/+QBOP/TATr/0wFI/+QBY//kAWn/0wFs/+QBb//kAXb/5AF//9MBgf/SAYX/0wGV/+IBvP/kAcL/0gHR/9ICEv/kAkH/0gJZ/9MCW//TAl3/0gJs/9ICe//kAn3/5AKH/9ICp//SAr//5ALJ/+QCy//kAs3/5ALP/+QC0f/kAtP/5ALV/+QC1//kAtn/5ALb/+QC3f/kAt//5AMb/9MDHf/TAx//0wMh/9MAKAAP/0YAEf9GAB3/RgAk/80Agv/NAIP/zQCE/80Ahf/NAIb/zQCH/80Awv/NAMT/zQDG/80BSP/NAWP/zQFs/80Bb//NAXb/zQGb//IBvP/NAhL/zQJ7/80Cff/NAr//zQLJ/80Cy//NAs3/zQLP/80C0f/NAtP/zQLV/80C1//NAtn/zQLb/80C3f/NAt//zQM2/0YDOv9GAz7/RgM//0YAAQGVAA4AAgGe/+0Bof/sALAARv/cAEf/3ABI/9wASv/cAFD/wgBR/8IAUv/WAFP/wgBU/9wAWP/dAFn/4QBc/+EAqf/cAKr/3ACr/9wArP/cAK3/3ACz/8IAtP/WALX/1gC2/9YAt//WALj/1gC7/90AvP/dAL3/3QC+/90Av//hAMH/4QDJ/9wAy//cAM3/3ADP/9wA0f/cANX/3ADX/9wA2f/cANv/3ADd/9wA3//cAOH/3ADj/9wA5f/cAQb/wgEI/8IBCv/CAQv/wgEP/9YBEf/WARP/1gEV/9wBK//dAS3/3QEv/90BMf/dATP/3QE1/90BOf/hAUT/3AFG/90Bhv/cAYj/wgGK/90Bi//cAY3/4QGO/+4Bj//mAZH/wgGS/+sBk//pAZf/4QGY//ABmf/WAZr/5wGc/9wBnf/cAZ7/4wGf/90BoP/OAaL/1AGj/9sBpf/dAab/1gGn/90B3//CAeH/3AHk/8IB5f/CAeb/wgHo/8IB6f/CAer/1gHr/8IB7P/CAe3/3AHv/+EB8P/cAfL/wgH0/8IB9f/CAfj/wgH6/8IB/P/cAf3/3AH//8ICAP/cAgb/wgII/8ICCf/CAgr/4QIf/9YCIf/hAiP/4QIl/9wCKf/cAi3/3AI2/8ICRv/CAk7/wgJQ/8ICVP/cAlb/3AJa/+ECc//CAnX/wgJ5/8ICgv/cAoT/3AKG/9wCjv/CApD/wgKS/9YClP/cApb/1gKa/+ECnP/hAp7/4QKi/8ICpP/CAqb/wgKs/9wCrf/cAq7/3AK4/9wCwv/CAuL/3ALk/9wC5v/cAuj/3ALq/9wC7P/cAu7/3ALw/9wC9v/WAvj/1gL6/9YC/P/WAv7/1gMA/9YDAv/WAwT/3AMG/9wDCP/cAwr/1gMM/9wDDv/dAxD/3QMS/90DFP/dAxb/3QMY/90DGv/dAxz/4QMe/+EDIP/hAyL/4QB2AAX/2gAK/9oARv/wAEf/8ABI//AASv/wAFT/8ABY/+8AWf/cAFz/3ACp//AAqv/wAKv/8ACs//AArf/wALv/7wC8/+8Avf/vAL7/7wC//9wAwf/cAMn/8ADL//AAzf/wAM//8ADR//AA1f/wANf/8ADZ//AA2//wAN3/8ADf//AA4f/wAOP/8ADl//ABFf/wASv/7wEt/+8BL//vATH/7wEz/+8BNf/vATn/3AFE//ABRv/vAVH/2gGG//ABiv/vAYv/8AGN/9wBkv/sAZUADwGX/9wBmv/qAZz/8AGd//ABnv/cAZ//7wGg/+cBpf/vAaf/7wHh//AB7f/wAe//3AHw//AB/P/wAf3/8AIA//ACCv/cAiH/3AIj/9wCJf/wAin/8AIt//ACVP/wAlb/8AJa/9wCgv/wAoT/8AKG//AClP/wApr/3AKc/9wCnv/cAqz/8AKt//ACrv/wArj/8ALi//AC5P/wAub/8ALo//AC6v/wAuz/8ALu//AC8P/wAwT/8AMG//ADCP/wAwz/8AMO/+8DEP/vAxL/7wMU/+8DFv/vAxj/7wMa/+8DHP/cAx7/3AMg/9wDIv/cAzT/2gM1/9oDN//aAzj/2gM5/9oDQf/aA0L/2gA6AAX/oAAK/6AASf/pAFj/8QBZ/8UAXP/FALv/8QC8//EAvf/xAL7/8QC//8UAwf/FASv/8QEt//EBL//xATH/8QEz//EBNf/xATn/xQFG//EBUf+gAYr/8QGN/8UBkv/uAZUAEAGX/8UBmv/sAZ7/vgGf//EBof/aAaX/8QGn//EB7//FAgr/xQIh/8UCI//FAlr/xQKa/8UCnP/FAp7/xQMO//EDEP/xAxL/8QMU//EDFv/xAxj/8QMa//EDHP/FAx7/xQMg/8UDIv/FAzT/oAM1/6ADN/+gAzj/oAM5/6ADQf+gA0L/oAA+AEb/5wBH/+cASP/nAEr/5wBU/+cAqf/nAKr/5wCr/+cArP/nAK3/5wDJ/+cAy//nAM3/5wDP/+cA0f/nANX/5wDX/+cA2f/nANv/5wDd/+cA3//nAOH/5wDj/+cA5f/nARX/5wFE/+cBhv/nAYv/5wGVAA8BnP/nAZ3/5wHh/+cB7f/nAfD/5wH8/+cB/f/nAgD/5wIl/+cCKf/nAi3/5wJU/+cCVv/nAoL/5wKE/+cChv/nApT/5wKs/+cCrf/nAq7/5wK4/+cC4v/nAuT/5wLm/+cC6P/nAur/5wLs/+cC7v/nAvD/5wME/+cDBv/nAwj/5wMM/+cAAQGeAAsAegAFAAwACgAMAEb/6ABH/+gASP/oAEkADABK/+gAUv/qAFT/6ABZAAsAXAALAKn/6ACq/+gAq//oAKz/6ACt/+gAtP/qALX/6gC2/+oAt//qALj/6gC/AAsAwQALAMn/6ADL/+gAzf/oAM//6ADR/+gA1f/oANf/6ADZ/+gA2//oAN3/6ADf/+gA4f/oAOP/6ADl/+gBD//qARH/6gET/+oBFf/oATkACwFE/+gBUQAMAYb/6AGL/+gBjQALAY7/7QGXAAsBmf/qAZoACwGc/+gBnf/oAZ4ADAGm/+oB4f/oAer/6gHt/+gB7wALAfD/6AH8/+gB/f/oAgD/6AIKAAsCH//qAiEACwIjAAsCJf/oAin/6AIt/+gCVP/oAlb/6AJaAAsCgv/oAoT/6AKG/+gCkv/qApT/6AKW/+oCmgALApwACwKeAAsCrP/oAq3/6AKu/+gCuP/oAuL/6ALk/+gC5v/oAuj/6ALq/+gC7P/oAu7/6ALw/+gC9v/qAvj/6gL6/+oC/P/qAv7/6gMA/+oDAv/qAwT/6AMG/+gDCP/oAwr/6gMM/+gDHAALAx4ACwMgAAsDIgALAzQADAM1AAwDNwAMAzgADAM5AAwDQQAMA0IADAN2AA0DeQANA3sADgN8//UDfv/sAA0AW//tAF3/7QE8/+0BPv/tAUD/7QGh/+EB4v/tAfH/7QJC/+0CXv/tAm3/7QKI/+0CqP/tAGQABQALAAoACwBG/+sAR//rAEj/6wBJAAsASv/rAFL/6QBU/+sAqf/rAKr/6wCr/+sArP/rAK3/6wC0/+kAtf/pALb/6QC3/+kAuP/pAMn/6wDL/+sAzf/rAM//6wDR/+sA1f/rANf/6wDZ/+sA2//rAN3/6wDf/+sA4f/rAOP/6wDl/+sBD//pARH/6QET/+kBFf/rAUT/6wFRAAsBhv/rAYv/6wGO/+4Bj//yAZn/6QGc/+sBnf/rAaD/8QGhAA8Bo//vAab/6QHh/+sB6v/pAe3/6wHw/+sB/P/rAf3/6wIA/+sCH//pAiX/6wIp/+sCLf/rAlT/6wJW/+sCgv/rAoT/6wKG/+sCkv/pApT/6wKW/+kCrP/rAq3/6wKu/+sCuP/rAuL/6wLk/+sC5v/rAuj/6wLq/+sC7P/rAu7/6wLw/+sC9v/pAvj/6QL6/+kC/P/pAv7/6QMA/+kDAv/pAwT/6wMG/+sDCP/rAwr/6QMM/+sDNAALAzUACwM3AAsDOAALAzkACwNBAAsDQgALAAwAW//yAF3/8gE8//IBPv/yAUD/8gHi//IB8f/yAkL/8gJe//ICbf/yAoj/8gKo//IAHwBZ//QAW//yAFz/9ABd//MAv//0AMH/9AE5//QBPP/zAT7/8wFA//MBjf/0AZf/9AHi//IB7//0AfH/8gIK//QCIf/0AiP/9AJC//ICWv/0Al7/8gJt//ICiP/yApr/9AKc//QCnv/0Aqj/8gMc//QDHv/0AyD/9AMi//QAWwAF/8oACv/KADf/0gA5/9QAO//0ADz/0wBZ/+YAW//vAFz/5gCf/9MAv//mAMH/5gEk/9IBJv/SATj/0wE5/+YBOv/TAVH/ygFp/9MBf//TAYH/9AGF/9MBjf/mAZf/5gGu/9IBt//SAbr/7QHC//QBzv/SAc//7QHR//QB0//hAdj/1AHi/+8B7v/JAe//5gHx/+8CCv/mAg3/5QIg/9QCIf/mAiL/1AIj/+YCK//jAkH/9AJC/+8CS//SAkz/xAJX/9ICWf/TAlr/5gJb/9MCXf/0Al7/7wJf/9ICYf/hAmP/4QJs//QCbf/vAnb/4QKH//QCiP/vApn/7QKa/+YCm//tApz/5gKd/+0Cnv/mAp//4QKn//QCqP/vAq//1AKw//UCsf/nArn/ZwK6/8kDG//TAxz/5gMd/9MDHv/mAx//0wMg/+YDIf/TAyL/5gM0/8oDNf/KAzf/ygM4/8oDOf/KA0H/ygNC/8oAJAA3/74AWf/vAFz/7wC//+8Awf/vAST/vgEm/74BOf/vAY3/7wGX/+8Brv++Abf/vgHO/74B2P/JAe7/3wHv/+8CCv/vAg3/7QIh/+8CI//vAiv/6wJL/74CTP/fAlf/vgJa/+8CX/++Amf/6QKa/+8CnP/vAp7/7wKw//UCuv/gAxz/7wMe/+8DIP/vAyL/7wA7ADf/5gA5/+cAO//yADz/5wBb//EAn//nAST/5gEm/+YBOP/nATr/5wFp/+cBf//nAYH/8gGF/+cBrv/mAbf/5gG6/+4Bwv/yAc7/5gHP/+4B0f/yAdP/6AHY/+YB4v/xAe7/0AHx//ECIP/nAiL/5wJB//ICQv/xAkv/5gJM/84CV//mAln/5wJb/+cCXf/yAl7/8QJf/+YCYf/oAmP/6AJs//ICbf/xAnb/6AKH//ICiP/xApn/7gKb/+4Cnf/uAp//6AKn//ICqP/xAq//5wKx/+0Cuf/mArr/0AMb/+cDHf/nAx//5wMh/+cAAgIWAAsCuf/mAI4AJAAQACb/6AAq/+gAMv/oADT/6AA3/+AAOf/gADz/3wCCABAAgwAQAIQAEACFABAAhgAQAIcAEACJ/+gAlP/oAJX/6ACW/+gAl//oAJj/6ACa/+gAn//fAMIAEADEABAAxgAQAMj/6ADK/+gAzP/oAM7/6ADe/+gA4P/oAOL/6ADk/+gBDv/oARD/6AES/+gBFP/oAST/4AEm/+ABOP/fATr/3wFD/+gBSAAQAUz/6AFjABABaP/oAWn/3wFsABABbwAQAXP/6AF2ABABev/oAX//3wGF/98Brv/gAbD/6AG1ABABt//gAbwAEAHAABQBxwAQAcr/6AHN/+gBzv/gAdP/4QHY/+AB4AATAecAEAHz/+ACBQAQAgz/6AISABACHv/oAiD/4AIi/+ACJP/oAib/6AIo/+gCKv/oAiz/6AJL/+ACU//oAlX/6AJX/+ACWf/fAlv/3wJf/+ACYf/hAmL/4AJj/+ECZP/gAmj/4QJwABACcQAQAnb/4QJ3/+ACewAQAn0AEAKD/+kCkf/oApP/6AKV/+gCn//hAqD/4AKv/98Csf/eArMAEAK3/+gCuf/fArv/8gK9ABACvgAQAr8AEALJABACywAQAs0AEALPABAC0QAQAtMAEALVABAC1wAQAtkAEALbABAC3QAQAt8AEAL1/+gC9//oAvn/6AL7/+gC/f/oAv//6AMB/+gDA//oAwX/6AMH/+gDCf/oAwv/6AMb/98DHf/fAx//3wMh/98DI//oADEAGv/yADf/8QA5//QAO//0ADz/8ACf//ABJP/xASb/8QE4//ABOv/wAWn/8AF///ABgf/0AYX/8AGu//EBtf/1Abf/8QG6//MBwv/0Acf/9QHO//EBz//zAdH/9AHY//ECIP/0AiL/9AJB//QCS//xAlf/8QJZ//ACW//wAl3/9AJf//ECbP/0AnD/9QKH//QCmf/zApv/8wKd//MCp//0Aq//8gKx//ICs//1Arn/8gK9//UDG//wAx3/8AMf//ADIf/wAAgAVwAOAIj+2wGO/9gBlf+aAZv/yAHA/xUB4P9VAqv/0ABkACQADwA3/+YAOf/mADsADgA8/+YAggAPAIMADwCEAA8AhQAPAIYADwCHAA8An//mAMIADwDEAA8AxgAPAST/5gEm/+YBOP/mATr/5gFIAA8BYwAPAWn/5gFsAA8BbwAPAXYADwF//+YBgQAOAYX/5gGu/+YBtQAOAbf/5gG6AAsBvAAPAcAAEwHCAA4BxwAOAc7/5gHPAAsB0QAOAdP/5QHY/+YB2f/0AeAAEgHnAA8B7v/nAfP/6AIFAA8CEgAPAiD/5gIi/+YCQQAOAkv/5gJM/+cCV//mAln/5gJb/+YCXQAOAl//5gJh/+UCYv/oAmP/5QJk/+gCbAAOAnAADgJxAA8Cdv/lAnf/6AJ7AA8CfQAPAocADgKZAAsCmwALAp0ACwKf/+UCoP/oAqcADgKv/+YCsf/mArMADgK5/+YCuv/nAr0ADgK+AA8CvwAPAskADwLLAA8CzQAPAs8ADwLRAA8C0wAPAtUADwLXAA8C2QAPAtsADwLdAA8C3wAPAxv/5gMd/+YDH//mAyH/5gAvADf/4wA7/+UAPP/kAJ//5AEk/+MBJv/jATj/5AE6/+QBaf/kAX//5AGB/+UBhf/kAa7/4wG1/+UBt//jAbr/6QHA/+IBwv/lAcf/5QHO/+MBz//pAdH/5QHn/+oCBf/qAkH/5QJL/+MCV//jAln/5AJb/+QCXf/lAl//4wJs/+UCcP/lAnH/6gKH/+UCmf/pApv/6QKd/+kCp//lArP/5QK5/+QCvf/lAr7/6gMb/+QDHf/kAx//5AMh/+QAIgA3/+IAO//kAST/4gEm/+IBgf/kAa7/4gG1/+QBt//iAbr/6QHA/+EBwv/kAcf/5AHO/+IBz//pAdH/5AHg/+QB5//rAgX/6wJB/+QCS//iAlf/4gJd/+QCX//iAmz/5AJw/+QCcf/rAof/5AKZ/+kCm//pAp3/6QKn/+QCs//kAr3/5AK+/+sAFgA3/+sAPP/zAJ//8wEk/+sBJv/rATj/8wE6//MBaf/zAX//8wGF//MBrv/rAbf/6wHO/+sCS//rAlf/6wJZ//MCW//zAl//6wMb//MDHf/zAx//8wMh//MANgBQ/+8AUf/vAFP/7wBb//AAs//vAQb/7wEI/+8BCv/vAQv/7wGI/+8Bkf/vAd//7wHg/+4B4v/wAeT/7wHl/+8B5v/vAej/7wHp/+8B6//vAez/7wHu/+4B8f/wAfL/7wH0/+8B9f/vAfj/7wH6/+8B///vAgb/7wII/+8CCf/vAg3/9AIr//ECNv/vAkL/8AJG/+8CTP/vAk7/7wJQ/+8CXv/wAm3/8AJz/+8Cdf/vAnn/7wKI//ACjv/vApD/7wKi/+8CpP/vAqb/7wKo//ACuv/vAsL/7wAhAAX/8gAK//IAWf/1AFz/9QC///UAwf/1ATn/9QFR//IBjf/1AZf/9QHu//QB7//1Agr/9QIN//UCIf/1AiP/9QJM//UCWv/1Apr/9QKc//UCnv/1Arr/9QMc//UDHv/1AyD/9QMi//UDNP/yAzX/8gM3//IDOP/yAzn/8gNB//IDQv/yAAkB4AAUAe7/7QHz/+0CTP/tAmL/7QJk/+0Cd//tAqD/7QK6/+0ACgAF//UACv/1AVH/9QM0//UDNf/1Azf/9QM4//UDOf/1A0H/9QNC//UAVgBG//AAR//wAEj/8ABK//AAUv/IAFT/8ACp//AAqv/wAKv/8ACs//AArf/wALT/yAC1/8gAtv/IALf/yAC4/8gAyf/wAMv/8ADN//AAz//wANH/8ADV//AA1//wANn/8ADb//AA3f/wAN//8ADh//AA4//wAOX/8AEP/8gBEf/IARP/yAEV//ABRP/wAYb/8AGL//ABmf/IAZz/8AGd//ABpv/IAeH/8AHq/8gB7f/wAfD/8AH8//AB/f/wAgD/8AIf/8gCJf/wAif/6wIp//ACLf/wAlT/8AJW//ACgv/wAoT/8AKG//ACkv/IApT/8AKW/8gCrP/wAq3/8AKu//ACuP/wAuL/8ALk//AC5v/wAuj/8ALq//AC7P/wAu7/8ALw//AC9v/IAvj/yAL6/8gC/P/IAv7/yAMA/8gDAv/IAwT/8AMG//ADCP/wAwr/yAMM//ADfv/rAJsABQANAAoADQBE//AARv/uAEf/7gBI/+4ASQANAEr/7gBS/+oAVP/uAFkACwBcAAsAov/wAKP/8ACk//AApf/wAKb/8ACn//AAqf/uAKr/7gCr/+4ArP/uAK3/7gC0/+oAtf/qALb/6gC3/+oAuP/qAL8ACwDBAAsAw//wAMX/8ADH//AAyf/uAMv/7gDN/+4Az//uANH/7gDV/+4A1//uANn/7gDb/+4A3f/uAN//7gDh/+4A4//uAOX/7gEP/+oBEf/qARP/6gEV/+4BOQALAUT/7gFJ//ABUQANAYb/7gGL/+4BjQALAZcACwGZ/+oBnP/uAZ3/7gGm/+oB3P/wAeD/yAHh/+4B5//XAer/6gHt/+4B7wALAfD/7gH8/+4B/f/uAgD/7gIF/9cCCgALAh//6gIhAAsCIwALAiX/7gIn/+wCKf/uAisADAIt/+4CVP/uAlb/7gJaAAsCcf/XAnz/8AJ+//ACgv/uAoT/7gKG/+4Ckv/qApT/7gKW/+oCmgALApwACwKeAAsCrP/uAq3/7gKu/+4CsAALArIACwK4/+4Cvv/XAsD/8ALK//ACzP/wAs7/8ALQ//AC0v/wAtT/8ALW//AC2P/wAtr/8ALc//AC3v/wAuD/8ALi/+4C5P/uAub/7gLo/+4C6v/uAuz/7gLu/+4C8P/uAvb/6gL4/+oC+v/qAvz/6gL+/+oDAP/qAwL/6gME/+4DBv/uAwj/7gMK/+oDDP/uAxwACwMeAAsDIAALAyIACwM0AA0DNQANAzcADQM4AA0DOQANA0EADQNCAA0DdgANA3kADQN7AA4DfP/1A37/7AAOAeAAFAHnABAB7v/wAfP/8AH7AAwCBQAQAkz/8AJi//ACZP/wAnEAEAJ3//ACoP/wArr/8AK+ABAASgBG/+4AR//uAEj/7gBK/+4AVP/uAKn/7gCq/+4Aq//uAKz/7gCt/+4Ayf/uAMv/7gDN/+4Az//uANH/7gDV/+4A1//uANn/7gDb/+4A3f/uAN//7gDh/+4A4//uAOX/7gEV/+4BRP/uAYb/7gGL/+4BnP/uAZ3/7gHgABIB4f/uAecADgHt/+4B7v/jAfD/7gHz/+MB/P/uAf3/7gIA/+4CBQAOAiX/7gIp/+4CLf/uAkz/4gJU/+4CVv/uAmL/4wJk/+MCcQAOAnf/4wKC/+4ChP/uAob/7gKU/+4CoP/jAqz/7gKt/+4Crv/uArj/7gK6/+MCvgAOAuL/7gLk/+4C5v/uAuj/7gLq/+4C7P/uAu7/7gLw/+4DBP/uAwb/7gMI/+4DDP/uACAAWf/0AFv/8ABc//QAv//0AMH/9AE5//QBjf/0AZf/9AHg/+8B4v/wAef/8wHv//QB8f/wAgX/8wIK//QCIf/0AiP/9AJC//ACWv/0Al7/8AJt//ACcf/zAoj/8AKa//QCnP/0Ap7/9AKo//ACvv/zAxz/9AMe//QDIP/0AyL/9AAKAAX/1gAK/9YBUf/WAzT/1gM1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AP8BAQEFAQYBBwEIAQkBCgELAQ4BDwEQAREBEgETARcBGQEbASQBJgEoASoBLAEuATABMgE0ATYBOAE5AToBOwE8AT0BPgE/AUABSQFRAWUBZgFnAWgBaQFtAW4BcAFxAXIBcwF0AXUBdwF4AXoBfAF+AX8BgQGEAYUBiAGNAZEBlwGZAZsBpgGsAa0BrwGyAbMBtAG1AbYBuAG6AbsBvgG/AcEBwgHEAcYBxwHIAckBygHMAc0BzgHPAdEB0gHUAdYB2AHcAd8B4QHiAeoB7AHtAe8B8AHxAfYB+AH5AfwB/QH/AgUCBgIKAg4CDwIfAiACIQIiAiMCOgI7AjwCPQJBAkICRQJHAkkCSwJNAlUCVgJXAlkCWgJbAl0CXgJmAmsCbAJtAnQCeAJ6AnwCfgKBAoIChAKGAocCiAKRApIClgKYApkCmgKbApwCnQKeAqECogKmAqcCqALAAsECwgLDAsUCxwLKAswCzgLQAtIC1ALWAtgC2gLcAt4C4ALhAuIC4wLkAuUC5gLnAugC6QLqAusC7ALtAu4C7wLwAvEC8wL1AvYC9wL4AvkC+gL7AvwC/QL+Av8DAAMBAwIDCgMNAw8DGwMcAx0DHgMfAyADIQMiAyMDNAM1AzYDNwM4AzkDOgM+Az8DQQNCAAIByAAPAA8AAQAQABAAAAARABEAAQASABwAAAAdAB0AAQAeACQAAAAlACUAAgAmACYAAwAnACcABAAoACgABQApACoAAAArACwABgAtAC0ABwAuAC4ACAAvAC8ACQAwADEABgAyADIABAAzADMACgA0ADYAAAA3ADcACwA4ADgABwA5ADkADAA6ADoADQA7ADsADgA8ADwADwA9AD0AEAA+AEMAAABEAEQAEQBFAEUAEgBGAEYAEwBHAEcAAABIAEgAFABJAEoAAABLAEsAFQBMAE8AAABQAFEAFQBSAFIAFgBTAFMAEgBUAFQAAABVAFUAFwBWAFgAAABZAFkAGABaAFoAAABbAFsAGQBcAFwAGABdAF0AGgBeAIgAAACJAIkAAwCKAI0ABQCOAJEABgCSAJIABACTAJMABgCUAJgABACZAJoAAACbAJ4ABwCfAJ8ADwCgAKEAAACiAKcAEQCoAKgAAACpAKkAEwCqAK0AFACuALIAAACzALMAFQC0ALgAFgC5AL4AAAC/AL8AGADAAMAAEgDBAMEAGADCAMIAAADDAMMAEQDEAMQAAADFAMUAEQDGAMYAAADHAMcAEQDIAMgAAwDJAMkAEwDKAMoAAwDLAMsAEwDMAMwAAwDNAM0AEwDOAM4AAwDPAM8AEwDQANAABADRANEAAADSANIABADTANMAAADUANQABQDVANUAFADWANYABQDXANcAFADYANgABQDZANkAFADaANoABQDbANsAFADcANwABQDdAN0AFADeAOUAAADmAOYABgDnAOcAFQDoAOkAAADqAOoABgDrAOsAAADsAOwABgDtAO0AAADuAO4ABgDvAO8AAADwAPAABgDxAPEAAADyAPIABgDzAPUAAAD2APYABwD3APcAAAD4APgACAD5APoAAAD7APsACQD8APwAAAD9AP0ACQD+AP4AAAD/AP8ACQEAAQAAAAEBAQEACQECAQQAAAEFAQUABgEGAQYAFQEHAQcABgEIAQgAFQEJAQkABgEKAQsAFQEMAQ0AAAEOAQ4ABAEPAQ8AFgEQARAABAERAREAFgESARIABAETARMAFgEUARYAAAEXARcAFwEYARgAAAEZARkAFwEaARoAAAEbARsAFwEcASMAAAEkASQACwElASUAAAEmASYACwEnAScAAAEoASgACwEpASkAAAEqASoABwErASsAAAEsASwABwEtAS0AAAEuAS4ABwEvAS8AAAEwATAABwExATEAAAEyATIABwEzATMAAAE0ATQABwE1ATUAAAE2ATYADQE3ATcAAAE4ATgADwE5ATkAGAE6AToADwE7ATsAEAE8ATwAGgE9AT0AEAE+AT4AGgE/AT8AEAFAAUAAGgFBAUgAAAFJAUkAEQFKAWQAAAFlAWUABQFmAWcABgFoAWgABAFpAWkADwFqAWwAAAFtAW0AAgFuAW4AGwFvAW8AAAFwAXAABQFxAXEAEAFyAXIABgFzAXMABAF0AXQABgF1AXUACAF2AXYAAAF3AXgABgF5AXkAAAF6AXoABAF7AXsAAAF8AXwACgF9AX0AAAF+AX4ACwF/AX8ADwGAAYAAAAGBAYEADgGCAYMAAAGEAYQABgGFAYUADwGGAYcAAAGIAYgAFQGJAYwAAAGNAY0AGAGOAZAAAAGRAZEAFQGSAZYAAAGXAZcAGAGYAZgAAAGZAZkAFgGaAZoAAAGbAZsAEgGcAaUAAAGmAaYAFgGnAasAAAGs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") format("truetype");font-weight:normal;font-style:normal}body{background-color:#313131;font-size:10px;margin:0;font-family:'roboto'}h3{color:#fff}label{display:inline-block;}label[for=party-search]{display:block;font-size:13px;color:#eee;margin-left:auto;margin-right:auto;margin-top:25px}xui-dialog{border:0;width:100%;height:390px;}xui-dialog div[content]{background-image:url("data:;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABQAAD/4QNvaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjMtYzAxMSA2Ni4xNDU2NjEsIDIwMTIvMDIvMDYtMTQ6NTY6MjcgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NjdGQjg4MkU1NEVBRTQxMUEyOUQ4NTFDRTQzQTg1RDkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RTIwN0VENjJFQTY3MTFFNEFCMDRBQzlGQkU2NjVBQTkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RTIwN0VENjFFQTY3MTFFNEFCMDRBQzlGQkU2NjVBQTkiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpERjhGQTU0RjY3RUFFNDExQTI5RDg1MUNFNDNBODVEOSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2N0ZCODgyRTU0RUFFNDExQTI5RDg1MUNFNDNBODVEOSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6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")}xui-dialog::shadow #titlebar{display:none}xui-dialog::shadow #footer{display:none}xui-tab-content{padding:10px;position:relative}xui-radio-group{margin-left:20px;}xui-radio-group xui-radio{display:block;font-size:12px;}xui-radio-group xui-radio span{color:#ccc}xui-radio-group xui-radio[value=light]{margin-top:10px}xui-radio-group xui-radio[value=funky]{margin-top:13px}xui-radio-group xui-radio[value=dark]{margin-top:18px}.form{margin-top:20px;text-align:right}.confirm-button{width:85px;float:right}.center{text-align:center;position:relative}#logo{width:161px;height:40px;background-image:url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAAKEAAAAoCAYAAACW7pqmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAHapJREFUeNrsXAl0HMWZruruOTQa3Zd1+bYsLGM72JZxDBjbgIGQZNkAGxInG8Jjc0GWhc3BLhuSkCwkxLvZJISHEwKPhAcbDgPhMgTb2AbfFpaxZcmyY1mndUszo5npme7e7+9j1HNoJFvJe2Gj9iurj7q66qvvP+rv4T/d1cTO59AEzoSgzKY//AqTBgJMEwXjAef2bE8jfVpj7Nv4+yO9HKeyxkMlKrFpBZ2spuYQU1WBWSW1CbQvKSH2p7LVrLniSv3cfqiqylwuF5NE0VYXnZktaJp5alyfaWlhUUVheXl5LBwO4xV4XBkN+SkVFxezQCCA+hUWjSp6Xp/PZ8uffKR7Zj8EQdDbz8rysj/96fRor9Gu2+1mLqeTufBXlmX93bzeTCZHImygfyDWN6ojGAwyWX8HQc87EhxhEeSjflC+6dMrWSgUZt3d3Xp+ezv2c+pLSUkx8w379HZyc3MwntLoeMbGMPnoaO/Qx6WiooKpyNfW1hbXVtK7s/M8uKoxJcfDBldUY1JwDhBS4gCApv/Tp7DInOpp3ASgU9ZYfo+qpwIfQFx5CgOksanjb/eQJlNYVFTWPX0aa6meD3RJOgsW9fezGZ1dTAFTAnNRM2sURMccMmNVH8jM4wdIcUMoCDBX5jBTVGFqJv6Gj0nPPrFyGKJCdjhYWJJYa0kJ6wV1ixBvmk2oqQBleUuEZQKACvCqikwHqqbxqVmYAuHkDw4kUhLoL67bAMQoAMlNGJIO6PVB/PZAl5L+fJ3n2pQY/38CQidLnxzMpoFmIT2J9AvzYaJuukJQ1dcCGRk3jECJFlTNYkKtpC3KxKhuoLyIVD6KpNhZEfK9gL/3W4tDUwFjRTD+JiWBRUXXBM2YqeOvWidUhMNpHqvASCbANNNEi1aN/z5nPvwp7jQz0v1GcXAT0jVgKCfSc7q0JmMkwtScARUimf0z7k1DehbpKcjjUaNVY7X4/3pcrqO6Ab4+KWeEeRZ0MC5FDasmztJV2VB4A+PKFAg//CAUd6XT+PTJFvlK6HjLcB6xxHcIkBC0qMLektxsdnYGKx0JsaggqJYhkggZE0PhGP+hJjXkY5EmB3MuCjNNjnFiEJk5lxTm/UgLEwt9qE1I2S9+VjVqnFIrP+zWsXM80wMMVgc2nAHGK8DsK/pdp8C1o74oOwwQDM8oZiUNrYQFS0uL09Z4PHoIkVAgUdDTzeS9XiZVRhnPguw2IawBdBnzug0AylIKiavF/UltMBm+PS2xTFLvRn1kVpmk7ibd/8sc59oO5SWf6LmUi42LrUwqX2ZinUnjmaa9scdzDBDy1NNrh9AcjckFqnBkn6isZQRCKiMDM/uHosylqiu7sj2t7bnetspBH7HhhFRRzd3PoCQu0AKSJB9117svCYANuU6ZgiuiuWd3Q+kTPorMjUg9KZUFTAAlztXEQchyOBwXiYIgTMBZzZGtPhKN9oqiWOF0OnN0mk0YBEVRBqLRaBeSxv8CzIv6yaE7C/0uw+VeNureSppg9EF3QCN/gcvlKsQ9FUDqwb1BekZ5xugjlyRpuShGh3F+fKz6qS+orxx5L8DfOtweQb9qRUEUJuCspvE8gnp6UH6pir7hvM7AYmpASgnTx2jfglaGapTyIL2KeudrPLCIOqP7B9F4a0gNdMrKKgdnu2TOdwWd4qWCljR5ycAmuSyGIpqz3wuzeTua82h+YZYlqskQcc/q9gvZoU8zWXwKt55HuiFWkQ3jBQXlLEOowK1QHDCzs7O/XV1d/W+JgDUmhyd57+tycn51qK7uu1dddVWd2+3O5imoARMcHBwcbDx58uT/dnZ2/AoTNfznYr9oNIJ3KfjIlVde+XpWVlbJ4ODQVV1dnW9J5GHgPMZUBDD0vaSiomLDzJkz/y4/P38BQOilaoLB4PDAwMDR06dPv9De3v4k+jdEvEXvisVljUv1unVX7PX7/adaWk4vEAQxTM/wXuzw4cN6Psrv9XpnXXHFFW8VFxfPwf2N4XC4c8WKFT+Z6HiizJP79+//9tq1a3cDR9Fnn/39/HBYbh1r10Q6HhiMk1IuQWTlbg/ziBIBMRO3S0z2IoOizQAhZ+1hVQEblmYYFZdxdWyo88QrDmWSK6hbKCDPDv7l47ZiAU3wyATmmabBMt26L+eDHL2G0BfBft6BPexs20wmiSMxdxANDhiwy+fzDXHauzImWsvAgQlzyLIcxbMRO9B8fv8Zt8udl5OTU6gvQHOA7QeVxeQsBwCWt7W13bJ3795b+vr69k8GgDTp1E5mpmfuNddc+1JhYaE+1k6Hw0u7UNQFa+LA1Kxk2rQNtbW1DwCwFVYdBEzqc25ubhHS5bNmzbr87Nmzt+/evfvOnp6e1y2QUDtg+UwcVCyzoKBQoPtgONba2mqMG/qD5wXr169/oaysbM7w8PDAkSNHHsc719rHk4YUi1UfTwA0GggE4sYTIG/FO2Rker0O1CthbD30PmOCUFbjySsMfESCKpufmaPreDaxoCQ6GLFGFRN30XRKmpYSlrpNTQaMM0n8GVaM1W6EnioeziI5PFY+yhystPBh1tfnYydaPskc0oi5/cdZb0/vz3t6e1/AAHMafLCYVllZ+dDixYtvBpO9eurUqa+BZbjFRC0tLe1goIvoHIMafnHz5k+EZblTMEcNA6kWFRXNnjFjxsfAQBswKTVglTdefvnl9RjwA8RY5+zjxJwBFMzj8ZStWbPmRbBO5eh4aaqVhxLtBV+4aNG9q1atup/a6u/v7wVwnu7o6NjW1dV1gsBRXl6+oKSkZC36eBP+Vl199dV/2L59+5dPnDjxawKX+a6qqcIopvhnvb299P6WSuC4+OKLfwcALiFwbdmyZQPaOopHR2U5vEWSHLo4DgWDWkV5+feWLlt2K8q+0tzcfDvqMnGoMbBxh8vlrrLaInmcTj9M0gmJ5YJKlPVHwqzY6eZKWsVy1L+SivNY2rvxJdNTBliwQDAKqHZGdbHFF/yWCRjkky2fwEoeGTW+BaGdBpkGgtgCw+43JzaAFdxuV5wJDNZKptEaGBysw8T3CObkUR0g0iNNTU0vffDBB49BbD+bl5dXuXr16ic2b958MYr6xwpUGGvgTbbNB7A2l5aW1oRCIZBdNAi2zdaXtwlCAsvcuXO/etlll91P142Njb8/sP/AN90edwumlw0NDen5wOL1ANQz9fX1G1HnL8CIV0AcbgJLdQOsL4/FxGfOnNHHh4Ikli1b9sgFF1xwNbW5a9eu28GkrxFT0jgidVB+ykvBCVFF8elkJAgBLOB2CuawxtMgzBhrGu+SBgep+LEWL/WtXjmUo2hqZDwdnKetnqWBn05bznHtXLLHMyAiXWwWAPjvupiOTbDAFNXJLpz/OJtZ8SaTI964fpksqAdY8FFZoBOcpW/RJJqK+OigCIJbM/7qE2XpShS9gvx733777RtGRkaCYNeauXPmbDBVAGuyjHKCkHJULMUfZVyXXnrpM2CuWuojWOdLEO/1sZc2o17AuAvBlBupf4cOHXrs2NGj/4CKWyxw2PtH91Cm8dDBg9cBrG9gcfF169Y9hgVUmchEVB9F3IBJ9WtIie9C1N9K5zt37PjPurq6Rwlw9vzUb9t4idZw0ViSmLeY1TCaJo4JIRlA/CFM4INYp5/BRWB8MKUXvEl3yZJV3E4W9fRrXH0U7/ZbZDiD5BqrlaiHJoR9B6c/QLorjkk1YjuJVc95huXnNGGFug2BRgCUZQg21RTT8e4GmjgAKcYkSUuE2Ir2v20TR/kjEZnYYx90pd/RvXlVVTdT59QE14eWwllFbQIQNGEcAPwNjKcrKd/WrVv/tfnEiccBokz7gNFkL1my5D6UcUP81u/Zs+drEI8xgyCViCcA9A8MhHfu3HkL8nZBTyysqan5lhKNN7YJOMSCAD6bM2fOLTA87qP7R48eferYsWP3JqoYOgAHh2I6aOLCogVAYW4D6J/AOUvyE6dJQjKYNCc9QjXZjI0fY6VNSPAmFoKtr2SSPvllXH1eLIkCLQkRPTbcaMaas2guM1m0OZjLOcxWLHmQ5WS1YxVm6Banaum7Wur1Ybh3eMp3spLFkiSC+vr79Jg6l8tJes8zNPjQFRdANBdDJBFrxRJdx/sltRgIIS4fXbp0KS1ytmPHju83NTZuxH3SX7m9TF5u7tz58+d/nPoJa/O76EuYYvtospWoktR3Apof/QxisQwODHTt3bPnIboPcX6jOyPDYenZFqvBgGFVVVXXQr3YRKBraGjYCj3yVtLh7EaE8f5+fUzTxUfqzEkMzuOHm4+TpGQNjahKr0Ixm3OOOrbZhHU+wWAAl/ncEV9AVTTJRyz8UzTl0frEr8T5xfSICJQxuuQy30hJNJC0uJUKJd/dzebPfonVN94N8TuSPArn6UJRYSeAUZhNwafJ6IYepEHk5cFqzcfq77b6Q6J4YGBAZwVum0wKMl20aNGPFyxYcBtdw8L+GVjnPgpWBYC4zTBhToj+8oqKa8io7+7uPg397A1SB6z2YRBZumwMKKSXWVYuPWs5c2YTmG0uyr5LXgFDu9YZmbe3twcBmgsBwKegD0oQy8ffeeedm8kws1hQZzic07W+oMdxkHKTAXmCC1EbmwdiwCpAuhLpj0i9JguyiKqKIcijDFGqR18WgDdO4ZlnIravis4MezOZd2TkTVzOwsrYFmNdCqmRgrImBvNxfoe+ARflD+Bp2AQgiw5mOlDJYVMdOJiov3Jjpc3Df+S7fMXyMUYVDyvOfw9seA0b8lfByJLTMuFEQejN9OoTAQtRV7phZJL4kWgyMZFhiOkwtzpmHiTm7NfhsMwWLlx4F8TeN+j62LGjTx0/3nAniTHdSEnQs0OhIEU3L6FrAGQ3rOggASvOk0ER1BZ12PyJtsMPAH/V5xu2nnFTZIc7OzuroS/+Hoyd29/f1wWV4Cbc77aLYcqLdmNR2RMarxSoGM8wkUw9i8Tir5Fus7JGwciDUVnziNIVqBKyomgQz2qTmxSSugAi410FBaykr/9BAPDBjBGVSVHNo8XMYc0Clay7aDgTYx0Wocudzc5U/a5XBI88UxN5n+qIC5Iw/ejsGaSLkL6EtMkyVBySj+VmHWeDw1g3onxewIsNGOmOYDIYD2x4eFjXiUjnogQ9ajkBCIp4G6xP3RK3gEi6pF13ovwQibdi0jdSvvfff/+FHTveuYU2dESId4thbaOo34dYLzMB3dAN0ZkIQgvkpINRe5bbxfILGm3LYM1A3PYcLPEg+n8PDKtq2gHasuXNWwHKI8S0diDTuQNtnstWYirAjceEgrlF1Iy0J7GoOazzcX+5xn1xWrbhm46Z4aK9adrXygiFKdR/KcDzvYiTV6ggjZQaJmfMrkLoq1okmaKrASuhHFRQpIxNW7LOtiOdQFNHadw4tz+dXJikfdBInAqm9ekhR6/eWc21aPGiOykvlHtieZkYRJQMQNEqofwkUjPAJDULF9547bXXbiLQQu96a/v2bRswsRHNzBfXf5sRg2cuy08Zy2RPo9a8ricSM+rf1qAf1BZNFxYIDKpADFzUJtjNjfsPw3DpI38p9M6bCeBCgoWv64VmjCifAKOdh5jR+0qz9QQS0f5jsQ17/HMIgpIrOaHaaeRjglgNL7G27Uh4FDi5IELqmpM2YoKEm0yolcJUx8X3cPmdqMhvg4IpjzXjcdhUwGbThvyCJ/wZIO9lPHzE3BpOdEbeTZ4FpHdHJ0NhciSf9Q0uxrl83mOTNNgxVonAsvUKq1Zd8svy8ooFwWAw0tTU+EvLH0limixyYkLLoszPz18HS/gJTLLQ0tJygPQuACKou4nAdoKpWyRaeKQ/ov5euoA+OpfEIrlBrGRdSwksmrzdGDVVCM1uGbuQ9m3btu0O6uNFF120AUC8m4BMjGol40OpoGFsTIDRzsNjr/ffooxAYtUOLqhOIwAg2yxRZBgt9MEIY9PdYmaRk29XNO2zoqZ9waWo5EcWrEmk70+YaZCAATP4eI4emzIhZoUoVLvUvFeUxv8TjGePEOs4u4YNB2ZjcqOTY0La0zXFqpkc3szM1bW1tW9g0r5I+Xbv3n1ff19/veX7i8iRmDVNZSBOl69du/YZAMYDcdewc+fOv0fWPsvyFMyvAZMmlvRQr5dUgGN0OW3atI+iPifEKDNSMPbVXUwk64zKY0Ed9EUgeRRgCD1SUVHxT6Z40KzFAVHshnHy9IEDBx6le1goPywvL7/EsIBHyZb0YM1kw3OVIuMaMWbfU1m8LrMyciQTwaW0Sl1ga68oRHqY+rQT8seNFRcXXmKcquYunDquMsvjLBsWC9cBFsxnlh/RmfqlwIJyLjvTeS30OHnSYoJ0oZycHJro5dNnzPiP7Kys2WC1GhJbAIACq/NHbW1tD0gOw/DXzMnXAQkAerOyqq+++uoXyU8Hne70nj17Po5nrYIg6sSqiyFBGNWjeTxDhMBAba2trwF83yktLa0qLCi4vOts15uSKfKzAFKnqa9R27TjQQfprlQXsfb06ZXXwxD6Mu6NYBE8hbxRyzUFg4QDdOzdd9+9GyCvhd77kTVr1tAO0AqU7SNns+XKIWA6HM7Y5xR8EpLFbkRZ7CykIBnSEYcwnAe0RNdKbGuPsR5ZC3aElQUS106HReGJoQwXE22cr50raafJLob0hxR9O2z2L9nCIhbsXsN8I9MxuRE2GUVGwSTRd73Lli1jy5cvv65q3ryPY6JqrEnfsWPHPXV1df+umM5snXlMhy3Ax0pKS8s/dt11mwsLC8ugd/W88sorn4SFezIQIF9bWAeJboxoWkrqsCR0d0/3AYjwPQTWZcuX36spqo6DkuISHXSqbd/f+j7ZCFDgBBoX+v9Nenby5MmXsRACdtKh/AA3MXZg+7ZtnwdQh3E9Z9WqVY8Y9RqDRu0FgyE20fC1lMNt3tB4aiteSFH0TjS8UOL8TT7qIE7YcObsdFAJjyhaDfJQlMvl3BgQNZX3kJ8f9mIPxRGNQiU24nQh0iOpWDAMFmwhFiS3zFiu+YlGt2DS6aPv9957j9Iz+/fv/++33377W+RLowGsqqq6we/3Z9Fui313hP4HEAsuu+yyl8rKyqp9Pt/wq6++en1vb089WakkQg0bwxCdabun18vUgwcP3k9l5s2bd+nKVat+mEf+SkmKuQhSbQmSKF+5cuXP0YeF0Cvl+vr6BxwGY3P7DkhRURErKiwkp/UHO95553ZqZ/HixTdChH+DnlsGjiXitfMXLGb4YUo3UkozMoJ8bWVOj640j9WwarxQ1Hyv8GSMgPGWFQVhOwIa7Zy0pt6ID7F2sKDfYsFJ68uGTkeiDUzWAEvyrpOnTv14y5Ytnx3BMX369NpLLrnkEQOAamz3BcmDyX8eOthSZAu9/vrrN6L8u5ZT2ZoAh2M0TtCe4tefAe7W1tbXsRB+RvdQ9z0Lamp+hr5lk7hN3CY07+XW1NQ8ASDdZu7I3NvX21uf2AblJ51yGtiQwNbY2PjbA/v3664usOEPwPyXhaF/6rou6pXDslH+fMxjTYvFIGgptjcFipKxpygGtdiZwXKgA6hp/EP8HLQDbTJoNF9agoJA+KItPPJ3W4mJKgtHCtiZjmuxaGT25zg0UybSoJPYpElygREwmYe2bd36L/QYxsln58+v+opiRjJjskRM3pNz585dDcZTYQV/ESLwTZOB4twplrWacq/Zpt3rW1po//Dhw3e///77+l710qVL78AC2FNeVvZ19GsR6stG8iItgDj96vr163cvWbLkHynvoUOHHjnR1PSQw5n6Ew4CWElJie5Kol2bg4cO3U171BDrztWrVz+GxVOgW/roWzAUmpjjP4U8BnOXI5VhLMsTUgXGOEeqdGfGDb+IAcoDAG0hXK5RX+Bo86baIhk7LGMHH6TBF7cZGfGUa+z5OWLtA2wEwIwuKMkZ8RuTghBk7cOXspHwTOaQAinJ3fR5Sea5RMaBFXliYz/BzCfypDhcHtsOa2pq2jTt4MGVAMMX1q274r/6+wcOQ9zugwh+FJP/KZpYiO+v9Pb2Pk0AJBGcGDjAxxgMattsThgNi+JUJrp/377PDwwMnLj44hX3gKUuQPofWMoKxG23GbRblGHsD9M+99C+ffvuB4NvJBamgFhznzz2jvQuRGzQW8n6Zh2dnUyNRPzboB9ef/317wDQcy9fs+Y3W7du/TTyBy1Rr++oGAs0Np5WJI9hbMTeiAIMaVtTQn2vobySCgojgUCbVOJyJ6+Q0ZrIENiBVAOBcxyzn2c9r3SLLpfAKeCxHbm3q8LYXuIUUTQSV92Dmhjag557INs7rRAtinhRhjJgAbDdtGOFtNXQaMl5BuU/rCVuUrPIECwpv485hcAYG+sRNuzz0fchFDXTOTjYr1t7ZCiQK0P/FYlweAgiNIJJHYkqSjAWz0c7EeSiIdcLTSDuQTzeUVBQUAOxvBzpuuHhoabq6upbUIcK3fEuGAKbrJB6g+H4qMFBoWlasrMA9VOIvp/KKIoacDgdsT1bE4hac3Pz93H9B4DmjuLi4vWw1svAWqXWFh6s9Ubody9jAWzq7OxodrszWNDmtkEeP95RIV21u7tbtViegErvSNe4fxhA/DoY9fGZM2d+Ii8vbybKNRB4zRA0XTwT+Onv4OBgN21RUh0UZaSZuiO1hXYo1tCLPmaNpfaQxS6lD1rVt9U+Bf04g2t5tG1XamzpwUJz8YzpbuHYqaC6SFK14ayQTJ6VCcpnUeJyTph5guv0TYM8xU/+cYMqVCa35Xvcs7u3irkji5gi9MaZjUlRuAJERZB1dXYwlxQaM4A0HJZ/AGZ4FsBrom8qrB0BayssFAo2Pvfcc0tyc3OAB6XHCjxQzAm0D5wgcP+uXTvXa6o2G5mb0fchgI8CUyVM4hH79xeJCrqqpvZWkUsW4P7cvn17y0Oh8J6cnNxYaJZiOr9NI6HuxIkTX2xoaCiAJTw7EAiUADxhMFoHWLo5Nzc37CUntuSINWq1CeA0gtkWy3I40N3dE7b3z9o6NLcin3z++efrVCME+7jlTqG+WAes9p9QsCzunaRgDUuqWGpFKBg8/eKLm5eCdLPHFuAa7WsMTiAuXQlzlhEWlIVxxq8IyqrNkdhxOdpfNeBjZUMjLCpOdLsM9cggVUf/iAAsOmtCTLN9qaxGRBZsLmHeFad64j8qGNPxPtYGvn3P1A/wHSSjwAJgQiArRaYc83gyxt2wN3dIBgb6Bw5mwhI1f5KtgZjAEsH8HD/Jo/wA8UkA5KTHk5k2H7EX+teH/vb19PTobdJPuUlmxMtYbRPQ0cZRRYnG7VcnLgx6BhY7Ym7xJY6jBTY/pMohem7fr9ZsebFAmmR57PAvMurIrSTRJxzpVHQiKEm5HASUy2wfv4sRVRMqvQ62ri/ISk51MVMcSzEvTqKuqtmc4xzmRRQWY7SIudY1MO4Bc0S4aLKcyCWFy+35TD4zyJwz+ljslxpS+osU2muemOtlnC2uRGCOBxpLD7LpnZMyiKxI6XPJbzmvz+V3EFWVTyjfeIELExnPdH2j8EnjHaLXpGUs+hkQrtFHYDpYrU/zSDPzkVd9uSqzfhLFTh1fZ80dkm7V5t4BhnjEyZkjog3iGX0p1qNvjLs8TCoFAA2VtTe2hQhSILL0H5zFPCMu5IuOCUKRh1nE59V1w6njw3lIgjZzAg6LGFvSB9NrTL9gBz2hX+9QR8O5H9Y4PyEq6nuSorsQ9cj6KCTgUL5Av8x1kyqy2ajyzZiSpFDUjH71nka/YwNjBLd9OnVixQbqK9O6BJxahIU8hYznqFO/jfRhBWF6cZzy2J7mmV8RhBeK+weYJwQyMzwOOkn1TJNYUWe0AZKzIQ1W3oiXeWBLKb1SyLWJi+Op46/zmPyPZJILgPQMMuEh/x0w9cugLNvjLsgrE4J+2z7DAWUSjaqjaeqYOqTJAtChKCzb79d/LljCeXl3D8vQWXD0k0fdEQtC6ykVoeOpzOOnDX8orVmwu7k2JUWnQHieBzleFZVV7D7KvM2nmUaGiWlNqaNWouUJd3IzLuz0XIeu7hlMmcsuHCpkhQVnmaKIU7MxJY7PkQXJtB4MsIyTnUx1SDoraqZYth1/QKJdlT+aKp4ugvW/5ESNiKy3p2Tq1/v/xo//E2AAVqADg+8WFYQAAAAASUVORK5CYII=");margin-left:auto;margin-right:auto;margin-top:16px}#instructions{font-size:11px;color:#888;margin-left:auto;margin-right:auto;margin-top:7px}#results{background-color:#000;position:absolute;width:250px;margin-left:27px;margin-top:0;border:1px solid #555;padding-left:0;max-height:87px;overflow-y:scroll;display:none;}#results li{list-style:none;font-size:12px;height:25px;padding-left:11px;padding-top:6px;}#results li:hover{background-color:#043151;cursor:pointer}#loading-icon{background-image:url("data:;base64,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");background-repeat:no-repeat;background-position:center;background-color:#393939;width:23px;height:23px;position:absolute;margin-left:303px;margin-top:-24px;display:none}#select-theme{margin-left:auto;margin-right:auto;margin-top:32px;font-size:13px;color:#eee}#theme-radio-group{margin-top:10px;}#theme-radio-group > *{float:left}#theme-images{width:218px;height:114px;background-image:url("data:;base64,iVBORw0KGgoAAAANSUhEUgAAANoAAAByCAYAAAA1Us9YAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo2N0ZCODgyRTU0RUFFNDExQTI5RDg1MUNFNDNBODVEOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowMTQ2QTkyQUVBNjgxMUU0QkRCNTgwODVGN0ZDNDlENCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowMTQ2QTkyOUVBNjgxMUU0QkRCNTgwODVGN0ZDNDlENCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkRGOEZBNTRGNjdFQUU0MTFBMjlEODUxQ0U0M0E4NUQ5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY3RkI4ODJFNTRFQUU0MTFBMjlEODUxQ0U0M0E4NUQ5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+86bhpAAAJMpJREFUeNrsfQecVcXZ/nP73d4L23dZytI7LCAdARFFUVFDTEhQ8w8mhiTqP180P1tMYr7EmEjsUaNGsCRGCYhIr4YOgVVYyhaWhWXL3b63fvPM2XO5u9ylGOnz7G9+c87MnDln75ln3nfemfOOISoqqg6AQQQ3FBQuLMwiOOfNmxd7xf+jDocj/HxVHh0djYyMDDQ2NqKoqAgul0s1LYX2CLtaepTTIiOhK0aZM7H42DpUeZvOqtLOnTvjxz/+MQYPHgyj0SjT6uvr8fe//x0vvvgiWlpaVPNSuKpgDJZotduRntdXkMSE2KhOSDPFIM8QjxCzEUOzwmE1GzqskOR6/fXXMXToUEmyakcdamrrER4ejrvuugsvv/wyQkJC1C+vcFXBJMKjbUSc1Yiug3ORMepWVFc3old8N2TXuJDjMMMe2ozrR4Wg3FuHoxWnVkYyvfrqqzI+UFSFZWt2ot4djn2lDhwqrkSo3YSc7HSpUq5du1b9+goSY8aMeeyqUx2TeiVi+PThKGxMhKHvWNiOOeD21SIeVgwxxyIqrBZz7jDg0T8Bx4/72lx74403IioqCg6hJv7lnY8QGmoWY7P/wB4Sg8jkbjAdKEVKUpQs9+c//xk1NTX+a3fOApIDtPWPC4FpuSeP5ywHbs8Bnp0IvLUH+Mk6YFwy8PJ1guAWrYyO7ceAHw8BVha1rePpTcCSmcDWcuC2xcAjg4D7Bp68prTuZHkdq0uAh1dr1/18FbDgoCKGwn+pOiYMSEHqiHQ0OJoBjxfW0Gg4Xc2o9NSjGi3Y722Ao9GLkFADZn/HhEEDTchIP6lG9uvXT8YlpftQU74XJyobsXHF5ygtq8DerStg91XiaMmXMJlM6N+/f5sHufUfJ8lyxz+BtAit8ZNUt/cAugoS3txdy5+QpcUkGUnD8kUO7Zq8OOAXI4AP952sg/Wyjpl5Gimv66zVF23X6rl/GTAyXauDx4lhWvz4eq3sk6PFGNOpSKbwNREtXkgze4QVxQXFcNc74HEcR5O7CSXOSiHPTOhhjUBDkw/bdvuQ182I/Hwjunc/WUVERIQmJs016B5fDVPxZgxMjYXp2A50DisTBHPAZ2pbVse+BsDRaiNZUa7FbPyzegKLD2j5o8X5c1uBzjGadMuJFqSu1co/sUW7pm+SIIVLk3hEl1gxbuwEHBPXT87RSMfjB4e1mrysmpQ8UA0sLBBSulFLZzz/P1r6rYLgL+1QjUXha1Idj6wtQsj4LPQfPAiFxw1wnSiFzRyGXFsyQtEEs8EMT7gBmX0NWLvRi08/9aKq8qT6eOTIEQwaNAhdQmwwRZegtlsYwlN6ocmcjKHdDCi11iA0JlGWLS0tPePDrSvR4tRwTc0jKXRVb0I20CAIFWXTzru2qp07j2lk+91I7ZyS6LPDwIvbgW3fAXJjtHpIPqY3ODWpSUIHA8tQpSXpFBS+FolWe6gapaJ1u5qaBFHiYEzOEUSzwW60CHlmhMPrQpjdhJJiH955242iw17U1Z0k2vLly7WDyFyEhiUgITUFx+IGoTm6F8Kd1UJVS0CYGK8dP34cO3acnYh4fZdGHEojSjaqiQv2AmMztZgq4bF7gdemauXrnBqp7m3VTI/Wa9KNEoySjNc/tFKTijpJdel3b3/VIBTODzjAamPRMJmNyOiZifTBM7Br2RIMTeqPa8o8cJQWYU1YAaaODcWCgjLsPeALWuEf//hHDB8+HC01ZTCWrMOO0hh4I9MxprsbTXG9ZJmHHnroJCnbgZKJaqIuoXhMowcNFTwOVo5jMaqPwa7RzwPzCObr1wS7n66+Bt5L4fzg0UcfNVx1RJNizmhEdFIqqo6WoGfGUEw2pWHp4XUowHFkxNhQVNMMrzd4hTTt//rXv8awYcNOyfN4PHjmmWewYMEC1boUFNH+60oNBowdOxYTJ05EVlYWmoQqumfPHrz//vtyKZaCwtVGNPP5qNTn82HFihUyKCgoCKLZ7Xb1KygonG+iUa1TULiYeOyxK34FVvBFxQoKCopoCgqKaAoKCqchmtfrxYYNG1BZWYmNGzd2GJ84cQKbNm3yx1zl0R4NDQ0yvX2ensb8wLT252e6RkHhsiVaYWEhbrnlFvlh5owZM/DSSy8FjZ999lncfPPN8jMXxn/5y19OIcYNN9yAa665BklJSZK8TLvjjjvkOcOAAQOwa9cumc5zlieRWJbnTGd++2sU2RQuV/jn0TixzKVR48ePR2hoKMaNG4ewsDA58azHXPUxevRo2fBHjRqFIUOGIC8vr02F27dvl/NnBw4ckOe85vHHH5fkYZp+/qtf/UqSluAC48WLFyMyMlKe0+3BvHnzZN3Hjh3z16ugcNkTrbi4GH/605/gdrvx/PPPw+l04oUXXjgl5seab7zxhjynX5D26NKlC7p27YopU6bgySefxK233oqCggJMnToVOTk5sgzJetttt/mJdu+99+Lhhx+W5Yn9+/dLsj744IOSYFxVQowcOVK9MYXLm2jZ2dmYP38+evbsKX16kAyUbJRcjHlOyUaVMCEhQcbBQDItWbJE+g0hmd59992g5UhGSi5i+vTp0mkPnfcEw8GDB+WzzZo1Sz6DgsJlSzR+9Txp0iSUl5dLiUbXcK+88oo/pqTj+M3hcODtt9+W6SRlMFIQ9913H9avX4+SkhKpAm7evFnmUXUkoTjm4rGuXlKaUaoFSkVez3pqa2sl0RQULnui6YiLi8P9998v1TRKD37ywnjEiBEyzs/Pl2Oz7t27B61w69atUpLpUovSirj77rulGzri9ttv96uNOqhikoD79u2TxHvvvfdk2hNPPOGvS0kzhSuGaNXV1XjttdekBHvzzTdPifmpyz333NNhhSSHbsAgMXRyfPTRR36rYWJior88y+rnlJwkIM8Ztm3b5r8msC4FhStCoj311FNSglCyUHrpMf18MD4TAomkoyOiBJZtX0aRS+GKJRrHajR8cEJ64cKFUoLxOzJOaFOdY8wx1GlRLsZpWz4ERs4CohPbphPRScCrc4DvvgLYW4lUc1zkFwLdh6u3onDlE01HbGwsZs+ejb59+0pJRldylHK6if60WPM6ULReVJIODLgO2LYYaKoFSrYDDZVA5mAgQZC1WaiF6xcAIZFa/pqngel/BPpPUm9G4YpCh2sdOV9GMz2d6DCmkYLuCYKphW1A8pBkEx4Etv9dO1/6sEYmqQ/GaQRkmXVvAV98pqUzPzwN6NRFvRWFq0eixcTE4Pvf/z4yMzPlGK13795nV+PhnUB9KfCZkE7lK4BD39YINPxWoKrVf1yP0UKSvaCplicOaoQc/m0tLzlHvRWFq0ei0e8HvQnTUc/KlSvlao2zwq5PgElPAne/Awx9BNi//mReak9g84vA3tXauR4T2f01gm54T70VhSsOBh8dfJwGzN67dy/S09P9axHPqDrqBo7mgEXAgUYPGkj0cjxnzKCXtytL49WExx57TDnnoWQLtgKkQwSSJBhhdCuknhdolVQEU7jaVMf/Bjt37kSgLxLdWWpVVZXMaw89n3ks0x76JzR6rKBwxUm0cwUJ9stf/lIuAB44cKB/UTEXJi9btkwu5dJXiXDBsp7Pz3M4d8dV+3369JH5NMToUvVvf/ubNMow/uSTT2Q9/LyGay+5zIuLmCdPniyXjCkoXPFE43QACbJo0SL5/RlJw4846aGYn8MQzCO4gFnP18FzruRnHazru9/9rvy6OxBcbEwr6NNPPy3POX7k5oac81NQuCqIRqnFT2hIkrKyMv8K/V69esnV+5zwTktLkxPgXOeor/bXwXOWpcSi5EpNTYXFYpHftHGFCletcDJ99+7d8guACRMmSCMNyaaWaylcqjij1fFcwTEWiaCP0ajekVjt8yiluJSL0wbM5zdwTNfL6GMxqpQEv9AOlID8EoDqpZ7GY0W0yxNXg9Xxayfa1znWU5vKK6JdKbhk3c0pkikooikoKJybMeRqENsKCkqiKSgooikoKCiiKSgooikoKCiiKSgooikoKKIpKCgooikoKKIpKFyVON2qEKsI3PxslAj5IuSKkNCa7lM/3Vf6rS+Xjk1/v3Zon1L5Omg3zSK4z9COzvcz6jEdzlSI8IUI60SgV6hCEbzBLn700Ucv6MN29D1afxG+KcIdIiQrjih0gIhL7HnoFJSf2H9HBLpte6s1HLzUVEeTCN8S4U0R5imSKVzGIOkeE+F1ESZfSkSziPAjEf4oQk/1nhSuEHDHzFdFmHmpEO0uER4XIVK9G4UrDCki/F6EiRebaP1E+JkIoUFH8QYDLFYbTGazfyzcK603ftl7JvoZ01vLADazAVbTVxvvc7teblY4ceJE6SPkbMFN7emmjv5HdI9agWl0EPS73/1OpjONgZt1MDCfMcG92XjOQOc/errCFUW2/xEh/WIRjZYl7izYucNSgkW9Ro5Fep7mZSottTsSY1NR0VyHnqZkdLPEiooMGNc1GkPTz00g2u12uScbXY/TMQ8bOreKOltwQ3niueeek1vwEtwCmPtjv/XWW3IHUm5qP3fuXCQnJ0v/IryGfkq4YQdjOgHiLqQff/yxvKaurs5ff0ZGBm666aYzP8h3HtFCewwcp8UPvyJ+uADy8jhNkfkCY4wIt+EiWElJtF7QrIvBCwgJFRJuRf/R+Yjtkw9jaAS6ZvRDVkw6Gl3NGGFPxzBXOkINZoxOjMeoAVaEh2oS7myQlJQkHfDQOxbdF5B43IPtbEFy0VEP3c/R5yMJw7pInp/85CdyX2w67uE+AgTJzDL6rjiMuY3wggUL5PXEnj175O45+vPl5uZKspF09MIVFRUlvTe38eB8+31a0El3v5CiE24HXlyukWzUtJOEY/pjrwG/fU+R7cLjm63S7YITbbQI0R0ViE+PwsDrBsDjNsBjtCByyCR4rFa4nE2iWzCh0tuIDLMNt0SkoqUFiIr0Ys50M+Kiz45pdMJDt3R0hEoPWCQOvVnR4erZgPtlkyTXXXcd3nnnHWRlZcn0YB6PiQ8//FDGP/jBD07Ju/POO6XjV0pAqp86uD8cO4A5c+bIvbuZR3LSxZ3ELXOBxnotkGQTbwGGTdCCjlhB7L+sBXoO1tJDw1WTvzigWjbkYhAtP6i2aDTAHGJBdFYsuvTLAXxGeC02hGT3FtLKCLfHDaOIm31uRBks6CkkncfgQ6jNgJH9jejeTUhC+5nJRunVIhhKdZH7ZNMpF9U7+nakOnkmUCWkI1U6XaV04piMEoySh5g5c6Yk7vbt2/3XsKzubJVu7KiuDh48WEq0+++//5R70IMySWwVHcwXX3whJRz9TW7cuFErQGlF4jD0G6GlffAS8OQc7ViP13wMxCULMZomxOZmLZTuU03/wmPixSBal46Ilj2xG9IHp6PB0SiI5uXWMvByxxdxbDSaYDGYEGGw4YCvFh84jqDe5YZFXFctisy82Ywxozv2z8otfGn0IMGam5sl2SjdnE6nHCM1NjbibDzhceN6bipPL8j0Bcntf3UJRwI99NBDePXVVzF//nz/NVQpmUdC0u8kjTB09Mo9AGgU0dP9o+iUFPzwhz+UvihXr14Nm80mVVBKYYn+I4EFz2lheLvdSpsaNHWRGDQWqCwXA78uJwk6cJxq9hce/S/0DcmEmGAZqUMzEZUdC2ejEzu3/Qd9hubCZAuFQUgdk9mCGkclDtQUYow3DYmGEGRZwxAtevzCI3Uo/NKDMdeaMSLfjCVLXUFvzI0OOf4hqUg0Es7lckmpRrKdrbtJSiZdzaPffoIqHqUcDR0kjD7eogdl/XjKlCky5jkDx3l6PYHXbN68WZKSz6qn6eM4P350A7BVuzeK9wPVx0+eM4/Y9BnwxTahNorOdNMyTZJR5dTLKVxIxFwMonk7sjRyGRnbu9sp1ESTQe5f5iwtgscXBpPRLMZoBrjgQSfY0TskElaLBydcXgjBJhegnc4gQiKRXFQdOwqcVmA4k3FEJ1ggdAK1Twt2fLp6JHeKi2XQsWXLFklAPwLJ8tmCthe3J9L7Afd9f75q8hcHF3ytLlXHoFaDI58XwXGoCrYwG/qN743wqFi4HSfQUlYoJE8z4kKiMSi6M8KF6tgg6OYUZKDqmJlswvWjjeB02vqN7g5vTMlFVZEqIwOlmK466jFdg1MqUVU7V9BCGOw4ELQeMpyuTDDQoqlwWaPyYhCtMCjlPV4c/mw/SreUIDIuEh5BDENUPCKHXCfGVlY0C7K5fR64hUC0iGrChYQTl8BuNSI+yoj33ndj1Wr3aY0gmuA0+OPAY30cZzab/ecdgab3Bx54oE0a99/WwW2daOxoD6qKurrYURmC0wGcxCaoRipc9th2MVRH7iZx6ylE8/rgEuMzR3ENigpKkJGeC59o8HUOraGZjCZ4hfpnN5hR63WjtKkOmQYLWsSQbFuBF/sOetHYFFxCc4JaN4JwXEZQgpFQlHQ62fS0M01g0wpIEzyJwmOOtwhaHjkuo6GD9+ScGqXnwoULcdddd0krYqA1ctKkSRgzZow8Xrx4sSTwk08+Ka/Vd8WhZZMrULj3G6cKSFCC+7Pdd999ctMNtX3UJY+lF0OicRBxvKMCFcXV2LxoC3wWoWoJMjmXvwu3EF2htlCh6HoQawxFqacFH9WVISTEgOoaI178wIWKqo7VYDZaSiua70kkxsGCXuZMKiKJQFJyApmNnOTQDSVLly6V83ScDNcJR5LQmBFIMvnri7LMLywslKStqKgIes+SkhJZF9VOTo4zcBNEklCR7JLH5xxmXwyiFYjwdkcFPC4P6qoasGP1ZpTv/hzOBgcOH9yGgzWlCLXYsLG5FBstxajxurCyrAKrtjhRWQOpRnYEWhopWSjRSJDAWE8PNPmTcJzADrbxBUnDuS2ShA2epNI3PCQh8vPzER8fLy2JNM+zLOuk5Gu/NzfLsgyXbXFimmUJ7vnG5VtcJ0mzPglGyUVwHo5TCmrcdtmA36ddcP2fqiN1N35GcC06+jxGCKc9a5eJcZWmwpUe2YtoIWnGRffEas9ufOGtkhbGlftr4POdeZKa4y6qg4xpfTS3LlYmoTh20xcV63lclUE1j3mBe2NLo54gBeezGDh+YswFwUuWLJGWQkomzslRgjEmYWkxJAnl/9I6X0Y1kOqnfk7ic85Mt1DecccdyMvLk6SjgYbSkHNzHOPp6fo4TuGSBXvDDy7GjQNZcbsIL0J9JuNXSQNN+gqXPQ5A+6hZ9oYX2pVB4ACI35hwKXyFeidQJLvySPYjnWQXA4FE87ZKtO9Bs0QqKFwJWCTC7Nb4oiHYYsS/i7AD2qffs0Tood6VwmUICou/ivAPnMaqfjGJRtBr0K9b1clhIoxtJVw8TrdsS+F0oOMjW+u42BdkjHwp4XJwN6drYc7W52Nc3iokVkIz4R+5VH5Qw4UeFCooXI1QnooVFBTRFBQU0RQUFBTRFBQU0RQUFNEUFBQU0RQUFNEUFBQU0RQUFNEUFBTRFBQUFNEUFBTRFBQU0RQUFBTRFBQU0RQUFM4Ghm+GDN0kYjqe9+EiOP+/zDolo/qNFL4K+Jk6XRREXBBWG41I6paB6IxEGE0m1JZXonzvYbibnepNKFzxRGs530Qzmk3oc9MoDJ51LUJj27qNdDW1YO/ijdj02mI0OxrUG+kAUWO6wNYpChXvb4fP5VE/yGVItPMKe1QYrv/lPUjtmyvPy44UoaryuNxRNCYqFinpOeg7Ywyyh/fGx///BZw4WKbeShB4WtyiU3LKXVcVLj+Y+lrS6DT1lJ3ZjVYLTGGh8LY4YUtIwbCEXHhrmlBnaEFoiDZS8Z7hnZssZkz/7VxJssrKany6bDU81hi5GcSKbdVwNAEb1q5CmM2AlOxMdBk7AF9+tgXOxmb1ZuQPaIR5YCcYUsLhqW2CGx54SmoV2S7TAX5QhHaLR9iUifCERyAio4tUVwa7O8EuxlkjexqR3dl9xsr73TIGKX06o6y8Am++/Qm6D5yA+gYXikqqEBUWgbxuWegxcgb++u4mHDhUhpDocIz98Uz1VvyDWvGCImwwRYmeLcwKQ5RdkexKUh0taTYkjsvGYW8yKgYMQYrHIsRXlRB7BuT7QhBnbkHM2Co4miNxrNje4bhs4DcmyuOi4r249qbb8MG7r2PP1m24Z+5c9Ogch4Wvv4yMrj0xe85MPPOH1/HUI7ORM7IPYjKSUF3cdsOP0v83p+0z1tUicvcuVA4f6U9L/vgjmEs1X5lNfbvLvKiCPYhYtdFfpurGyajoPxiWhnpkvPM2mnI7ozEtHUlvvYu6Mflw5PVE2vOvtLlf3IZ1CNn5hf85eG+WJ/Rr9Gdi+rFZt8EVEXnK8xL6dawnsN6gECpDU3mNxrkmN3xuJ3zxNrREmhBS0gRjy5nda4598Db0GD4QezdsxcqntXunj+qO4TOnID41uU06y4ZFR2LR/7ziPy8/UIKCD7Tf7/qn5iCzRxecOFKODQuXoGTNF4pBX5Vo3lgzTNdEIjK3EzyHrKhPzYCvqEzbS9rAjQcNaBENoHN2CwZOq8G69+JRe/xUvqb0zkFIVDhaXM0Ii83G2jUrseqzZXj2pVewYulibN+2GXPnPYQ/P/s8sgXZxk0chfq6CkRGZIrxWq82RHOnJWLnZG3Dv6rYeMRWnYC9qRGd4xOxdsYsed4QEoowUWbS3O9Isu255z4U9BmEnMICjGgl2sEH5mH9DTNleaIhMVnGxeL+k1atwpp5P0dS6WHECZKuvHNOm3rH/eKnOHrtFHm9Tdz7ZlGe9zk8dToK+g5GmEhj2Zz8UWgJDUNNbIL/WYm8dcvltdNLS1AxeBi2TJyGaYJop4WQXk3h4p0YWrf9CfHAEmOGOzUEvuNivHYGos2cPw/jbpuGwl17Mf37d6Fw0y50ElrEd596EM0NjbLM0GtHSyLOn/6QLBOTKDSZqAgsnPuMPN+3Yw/Kdh3Azz58Tubxuq79emL41PG4P+t6xaCvqjp6xkTBkGyBY3eZyOV2t0b4vF5Ut9TD7fPiOMcJHgMOfhGC+GwnRsyqDloxpRIREhaJE2XHsGjh8+g7cDBKRQ+96B9/w+G9O2EwhyMlLQkrPv0UAwf2QGOdtr9GbGZy295ANOipN16Pvp98KM/Z6MfffhvMLc3+8+GiTjZsV1ysJObBLj2QcqQYR1Iz5TkDG3feri2yLobct17z32PHz34h454vPedP4/2mPPVzWS+l49EefWSdLYJQla07gxIkGevL27kZx9KyMGL2bPlMeh3Mo/QkQUnMQwPzZdmOpJlPvJW6WIMgmQG+8gYYRECV+F+PNcJQ2QxvaR3QfGbVnRKLxFjw2HOSFJRAU4T2UH38hDxn+PzT1egzYjCiuiTKa5hHcurnxOQffUOS7A/f+7n/uv+966f+/JDu8cj49vAzPs+Xjz4ipX17UPtg2DL/uVPS2yP55n6IGp7VJq37z6bJZyASpvbs8FkC887mmdlRUaoTDyx/TmoCX98YLdIMX6MXLkczzE1CGh0tFR2rFy0eobaIv64GK8JtQOVxC5yNRkTEBzc1W0K0Dd6rq47C07QPuanhSE2Ow5ql/wQqahHlC8X6VUvhqCrHof+sRdXRA6io0EhrDbWf0z9ROGu2lHgkERtv+bQbZPqQF57RJNYd35AEJEGS/7PjZANpbeiURJR+g977a5vG35DUSRJDB0nba9H7kmwlQnL5y4nrd//2N1KyUXIFVR1EZzFo2ceyTKUgbiDJT+nsTOL3TTehJsmIOrsbNaFu1Ns8cIS40WAXnV6IC27zmcdqm/+1EvawUDz8wZ8x+81HtE4sKQEl+w/5yxTt3S86w1BEdoqV5xv+tdxPLn9DHtRHEpaSbe6Hv5GBqqffZhNihSUiRDZkNmDGBAlhirb5SfPv8VP9vxtVZ2oY/N1WPP6/UluIqDgmVXGmM2Y6yanDmh6JuN7ZiOqa4icL72WymuUz8DgsLR5Gm0Xel+c6KQPzOnpmXsNjnbT8vxMzU+Vx7/xByB3Wx08+dkSBx1SreX7WRDOtqBEjMSPihufA4HSJcUAzjCYLOoXGwULpJt6vW2gsfYfVwes2YM0bMUErbqyq0+JGByLigKzcVGxcvgi1NZXo1n8MOnXvJ8h1CM1H9woV0AqzoRnhUdq4pv6E45x7DDb22MMHtMYzZISMdZJQEulwhp86ZUiJRBUvkDySwP2HSrVyxEcL5XUk6vG+AzU1VEhMSkkdVBflC928qcNnpFQjcvbvPe3YzCh+X5tQDe2VLlir3Qg54Ya11g0bz2s94twFn8cnSCe0C2PHhPv3y5/gyRnfx671mzF2xtTTNgT/7+iok+Up1fzvsl6b33TsPy60jnqkd8mWqmObjjVcM1xn3pSPmO7pCO+fgk6je/vzi2+6Ff02rZYdGn83quausHCEHS/3q/Ek4r+/N8+v0rdH7OAc1OwrRURmkiQF7+XvNFNiJJF0pM8chsicZPkMOslOEQYBz2yNFO1nRC6SRveENTY86P0nfesWST7iR2/9Bv1FZ3D7A99DtzEDMO3uO89NohmLW+D7vFZItAYxoI9AfXKq3MHALdRHg8+ARiHduLtnU4MR2/8VhfIvbUErPrKzUBP1idlwN3vRL9WCoQm1iGnYj3EZ9ZiY3YTyfZsxtFscbr1xNFwtx5CeofU+R3cfOCeSUTqw8VI15Euk5Ek9UiTzGB/MzYM7JkaqblTb2FsyBKoxlGZsBIFGEF3ty/ntM/I6SjIiseSQJB0lpU7UQXPvk/Gub93T8YBYSDWWsTWefmLeIzSHSksTqm1O1FidqLS3oNbiQpVVxFYXKk1NqIh0ojC1BY4wz2lVn/CEGCnZpCU5MhxVxyqkqpg3I1+qQgPHj0DZoeI2ho2Pfq9JW6qLRMHnO+Qx6/vs5ffaSEQdzVW1qPjXHildag+VI2VcHzQerYSnpsXfae0YNtqvYRDdHn0C0fsKEF1VgdR12jN2W/2p7NxoYGJ6wvbNJ5Wt7GREd03TSCdIwXvxnvKdDOqKhtITMsh3khzrfy6SLDAv2DPXF1XIDsIeGwnHhsNtOhgdb/ziGYSEh8kxbefeeTKt7GARsvvlyZjj2nOyOrbsasDRiAJx4xR4N6yCO6c3TCajIJoZG8RLvkb0oltXxuLAdluHFdcdq8KRHfuR2q8LBmTk4eiBjbB1iYBdiOvhXbJQWe1BYrfemNI/WtywDqX2SEREJYlDMY7ZtOecJVrOp4skUfSXOPSRh2TDlqrIE89IA8SE+U/js7kP4sMntB+EkkoHrYF5QqJtuOlOTCnYc8pYoSw1A9e++Hu/1bD4n4ukpIw8cXJHIKqNOtm/KpwmdmhAuFDL7U6DlFg+0bNZhfYg+jqENBvgFF1faJMRToMXNmfHG7lkdO+MqbO16RKSiSQh5j7/OH72pvYbNAmV8NX/ebrNdSTdinc/ltdSgtEKSWsjpZxe34HdBW21AtGwO/9gvGy8VZsPShXvxI4Dfsss8c1rhsmO7MvR156UKg6H7Bjj+w/2ayM0dFFtZ4dUMH0mRvzzE786t+exfyB2fBfE9MiQ98q6VyNv6bLtSMrXxlDO+iZU7j6EsNQ4bfiyu6hNXrBnJrlYpu5wuT9/y9I10iBEKcbfb9j0CWgS5KNEX/nBv9BtgCaxjxcd8Uu6DmdqvhkylBaIU+SqOdoOS2wymg4ViR4hF/0N4agsKkOB4RhSEoDaRh/qG06/W09SXiZmvvBTucaxbv86LH/jV2JMl4a4fjOwfrcDw3pEI7JuO3K75MLQfRpnuLHqD+9i5werO6yTjT5Q7Qo814/Z0HUzv55uqaySaczjeE0fo+mkCJwWYPrp7qNbQttLq46eJxDt79dG3bZ4sCfOgYRGG+qsQmV0m+ARrPMIXTLUZUK91YPIFjOq7S5EN1tQFeJEZm0YYputHf5e+gC+vSleT689WiVVQjmmEmMN/VgvE3gd8/WxXPv6OH6yxoeL9lIJU4QNObNGY//zn/olWuBvQeKZq6vbnIcUHpBTLUxvyspCrCAXfyum6dMzvIezpNY/PnOW1yEkOw7OE/UynWmeBm3dLM+pvnqanGj64sQpee2fmc/Z9SeTUbZiF+q3n1ydRMkfERsl1XD+/1QTv1y1Tf5OQ+6ejLoqh5z+aP9bnTXR2uiyYVHoFpGA4vIjqEXTOfXQvadfg3GchBa98rF9W2FvOAxTeCZeWlKGW27MR7TxOCLTtcFzwSef49On3rxqJ2WbTR4cimpATIsV9UJVtHs0oslpFUG6BkHECJcZDqE+RjktknAptTZEuqyX1P/B8VN4j05+FexyASVl1fL952ftwdkQ7b9F1/EDMXbeTLnuMeiYxOXG5jeX4vPXl1zVKx8ajW7sCa9EojMUNZYWhHrMmkQTgce1Zidi3HacEOO3eFeIjGOdNlSamxDqtSCvMVZNWF0uE9bnA/uWb0XR53vRa9oIZOX3QnRaAix2K2rLq1Cy9Uvs+nANHEdOXPUvwycI1QI3XPDI2CzGYjSMuOCFBRybueH0udHi0+ImnwsugwUtRg8sPpNqzZcwLohEU1C42qG+GFZQuEBES1A/g4LC+cX/CTAArw75zNmwFt8AAAAASUVORK5CYII=");margin-left:18px}#confirm-button-container{margin-top:33px}#cancel-button{margin-right:27px;margin-left:6px}#party-search{background-color:#393939;border:1px solid #000;color:#ccc;width:280px;height:25px;margin-left:auto;margin-right:auto;margin-top:4px;padding:0 25px 0 5px}.tt-loader{background-image:url("data:;base64,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");display:none;height:16px;position:absolute;right:40px;top:9px;width:16px;z-index:1;}.tt-loader[show]{display:block}.typeahead,.tt-query,.tt-hint{width:396px;height:30px;padding:8px 12px;font-size:24px;line-height:30px;border:2px solid #ccc;border-radius:8px;outline:none}.tt-hint{color:#999}.tt-menu{background-color:#000;border:1px solid rgba(57,57,57,0.75);margin:0;padding:0;text-align:left;width:280px}.tt-suggestion{color:#888;padding:5px;font-size:11px;line-height:21px;}.tt-suggestion:hover{cursor:pointer;background-color:#043151}.tt-suggestion.tt-cursor{background-color:#043151}.tt-suggestion strong{color:#ccc}.empty-message{color:#888;padding:5px;font-size:11px;line-height:21px}</style>

  </head>
  <body>
    <xui-dialog>
      <div titlebar="">Tracktl Party Search</div>
      <div content="">
        <div id="logo"></div>
        <label for="party-search">Search a Trackparty</label>
        <span id="instructions">You may enter a trackparty ID, name, or URL</span>
        <div class="center">
          <div class="tt-loader"></div>
          <input id="party-search" type="text" placeholder="Search here">
        </div>
        <ul id="results"></ul>
        <div id="loading-icon"></div>
        <span id="select-theme">Select a Theme</span>
        <div id="theme-radio-group">
          <xui-radio-group>
            <xui-radio value="light" selected><span>Light</span></xui-radio>
            <xui-radio value="dark"><span>Dark</span></xui-radio>
            <xui-radio value="funky"><span>Funky</span></xui-radio>
          </xui-radio-group>
          <div id="theme-images"></div>
        </div>
        <div id="confirm-button-container">
          <xui-button class="confirm-button" id="cancel-button">Cancel</xui-button>
          <xui-button class="confirm-button" id="ok-button" disabled>OK</xui-button>
        </div>
      </div>
    </xui-dialog>

    <script>/*! jQuery v2.1.4 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m="2.1.4",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)+1>=0},isPlainObject:function(a){return"object"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=l.createElement("script"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b="length"in a&&a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N=M.replace("w","w#"),O="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+N+"))|)"+L+"*\\]",P=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",Q=new RegExp(L+"+","g"),R=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),S=new RegExp("^"+L+"*,"+L+"*"),T=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),U=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),V=new RegExp(P),W=new RegExp("^"+N+"$"),X={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+P),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,aa=/[+~]/,ba=/'|\\/g,ca=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),da=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,"string"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(ba,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(",")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",ea,!1):e.attachEvent&&e.attachEvent("onunload",ea)),p=!f(g),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\f]' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){var b=g.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",P)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||"").replace(ca,da),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(Q," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^.[^:#\[\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return g.call(b,a)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+" "+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,"string"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=n.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:l,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=l.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=l,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};A.prototype=n.fn,y=n(l);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?"string"==typeof a?g.call(n(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,"parentNode")},parentsUntil:function(a,b,c){return n.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return n.dir(a,"nextSibling")},prevAll:function(a){return n.dir(a,"previousSibling")},nextUntil:function(a,b,c){return n.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return n.dir(a,"previousSibling",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(C[a]||n.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return n.each(a.match(E)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){n.each(b,function(b,c){var d=n.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&n.each(arguments,function(a,b){var c;while((c=n.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(H.resolveWith(l,[n]),n.fn.triggerHandler&&(n(l).triggerHandler("ready"),n(l).off("ready"))))}});function I(){l.removeEventListener("DOMContentLoaded",I,!1),a.removeEventListener("load",I,!1),n.ready()}n.ready.promise=function(b){return H||(H=n.Deferred(),"complete"===l.readyState?setTimeout(n.ready):(l.addEventListener("DOMContentLoaded",I,!1),a.addEventListener("load",I,!1))),H.promise(b)},n.ready.promise();var J=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};n.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=n.expando+K.uid++}K.uid=1,K.accepts=n.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,n.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if("string"==typeof b)f[b]=c;else if(n.isEmptyObject(f))n.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&"string"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!n.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(O,"-$1").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){
return M.access(a,b,c)},removeData:function(a,b){M.remove(a,b)},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));L.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=n.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf("-")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=L.get(a,b),c&&(!d||n.isArray(c)?d=L.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return L.get(a,c)||L.access(a,c,{empty:n.Callbacks("once memory").add(function(){L.remove(a,[b+"queue",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=L.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,R=["Top","Right","Bottom","Left"],S=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=l.createDocumentFragment(),b=a.appendChild(l.createElement("div")),c=l.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U="undefined";k.focusinBubbles="onfocusin"in a;var V=/^key/,W=/^(?:mouse|pointer|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return l.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof n!==U&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(E)||[""],j=b.length;while(j--)h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&(delete r.handle,L.remove(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,m,o,p=[d||l],q=j.call(b,"type")?b.type:b,r=j.call(b,"namespace")?b.namespace.split("."):[];if(g=h=d=d||l,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+n.event.triggered)&&(q.indexOf(".")>=0&&(r=q.split("."),q=r.shift(),r.sort()),k=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},e||!o.trigger||o.trigger.apply(d,c)!==!1)){if(!e&&!o.noBubble&&!n.isWindow(d)){for(i=o.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||l)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:o.bindType||q,m=(L.get(g,"events")||{})[b.type]&&L.get(g,"handle"),m&&m.apply(g,c),m=k&&g[k],m&&m.apply&&n.acceptData(g)&&(b.result=m.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!n.acceptData(d)||k&&n.isFunction(d[q])&&!n.isWindow(d)&&(h=d[k],h&&(d[k]=null),n.event.triggered=q,d[q](),n.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||"click"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>=0:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||l,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=l),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&n.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?Z:$):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=Z,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.focusinBubbles||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return n().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,ba=/<([\w:]+)/,ca=/<|&#?\w+;/,da=/<(?:script|style|link)/i,ea=/checked\s*(?:[^=]|=\s*.checked.)/i,fa=/^$|\/(?:java|ecma)script/i,ga=/^true\/(.*)/,ha=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ia={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ia.optgroup=ia.option,ia.tbody=ia.tfoot=ia.colgroup=ia.caption=ia.thead,ia.th=ia.td;function ja(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function ka(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function la(a){var b=ga.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function ma(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],"globalEval",!b||L.get(b[c],"globalEval"))}function na(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=n.extend({},h),M.set(b,i))}}function oa(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||"*"):a.querySelectorAll?a.querySelectorAll(b||"*"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function pa(a,b){var c=b.nodeName.toLowerCase();"input"===c&&T.test(a.type)?b.checked=a.checked:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}n.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=oa(h),f=oa(a),d=0,e=f.length;e>d;d++)pa(f[d],g[d]);if(b)if(c)for(f=f||oa(a),g=g||oa(h),d=0,e=f.length;e>d;d++)na(f[d],g[d]);else na(a,h);return g=oa(h,"script"),g.length>0&&ma(g,!i&&oa(a,"script")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,o=a.length;o>m;m++)if(e=a[m],e||0===e)if("object"===n.type(e))n.merge(l,e.nodeType?[e]:e);else if(ca.test(e)){f=f||k.appendChild(b.createElement("div")),g=(ba.exec(e)||["",""])[1].toLowerCase(),h=ia[g]||ia._default,f.innerHTML=h[1]+e.replace(aa,"<$1></$2>")+h[2],j=h[0];while(j--)f=f.lastChild;n.merge(l,f.childNodes),f=k.firstChild,f.textContent=""}else l.push(b.createTextNode(e));k.textContent="",m=0;while(e=l[m++])if((!d||-1===n.inArray(e,d))&&(i=n.contains(e.ownerDocument,e),f=oa(k.appendChild(e),"script"),i&&ma(f),c)){j=0;while(e=f[j++])fa.test(e.type||"")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f=n.event.special,g=0;void 0!==(c=a[g]);g++){if(n.acceptData(c)&&(e=c[L.expando],e&&(b=L.cache[e]))){if(b.events)for(d in b.events)f[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);L.cache[e]&&delete L.cache[e]}delete M.cache[c[M.expando]]}}}),n.fn.extend({text:function(a){return J(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(oa(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&ma(oa(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(oa(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!da.test(a)&&!ia[(ba.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(aa,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(oa(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(oa(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,m=this,o=l-1,p=a[0],q=n.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&ea.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(c=n.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=n.map(oa(c,"script"),ka),g=f.length;l>j;j++)h=c,j!==o&&(h=n.clone(h,!0,!0),g&&n.merge(f,oa(h,"script"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,n.map(f,la),j=0;g>j;j++)h=f[j],fa.test(h.type||"")&&!L.access(h,"globalEval")&&n.contains(i,h)&&(h.src?n._evalUrl&&n._evalUrl(h.src):n.globalEval(h.textContent.replace(ha,"")))}return this}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),n(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qa,ra={};function sa(b,c){var d,e=n(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:n.css(e[0],"display");return e.detach(),f}function ta(a){var b=l,c=ra[a];return c||(c=sa(a,b),"none"!==c&&c||(qa=(qa||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=qa[0].contentDocument,b.write(),b.close(),c=sa(a,b),qa.detach()),ra[a]=c),c}var ua=/^margin/,va=new RegExp("^("+Q+")(?!px)[a-z%]+$","i"),wa=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)};function xa(a,b,c){var d,e,f,g,h=a.style;return c=c||wa(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(""!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),va.test(g)&&ua.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function ya(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d=l.documentElement,e=l.createElement("div"),f=l.createElement("div");if(f.style){f.style.backgroundClip="content-box",f.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===f.style.backgroundClip,e.style.cssText="border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute",e.appendChild(f);function g(){f.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",f.innerHTML="",d.appendChild(e);var g=a.getComputedStyle(f,null);b="1%"!==g.top,c="4px"===g.width,d.removeChild(e)}a.getComputedStyle&&n.extend(k,{pixelPosition:function(){return g(),b},boxSizingReliable:function(){return null==c&&g(),c},reliableMarginRight:function(){var b,c=f.appendChild(l.createElement("div"));return c.style.cssText=f.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",c.style.marginRight=c.style.width="0",f.style.width="1px",d.appendChild(e),b=!parseFloat(a.getComputedStyle(c,null).marginRight),d.removeChild(e),f.removeChild(c),b}})}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var za=/^(none|table(?!-c[ea]).+)/,Aa=new RegExp("^("+Q+")(.*)$","i"),Ba=new RegExp("^([+-])=("+Q+")","i"),Ca={position:"absolute",visibility:"hidden",display:"block"},Da={letterSpacing:"0",fontWeight:"400"},Ea=["Webkit","O","Moz","ms"];function Fa(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Ea.length;while(e--)if(b=Ea[e]+c,b in a)return b;return d}function Ga(a,b,c){var d=Aa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Ha(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+R[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+R[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+R[f]+"Width",!0,e))):(g+=n.css(a,"padding"+R[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+R[f]+"Width",!0,e)));return g}function Ia(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=wa(a),g="border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=xa(a,b,f),(0>e||null==e)&&(e=a.style[b]),va.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Ha(a,b,c||(g?"border":"content"),d,f)+"px"}function Ja(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&S(d)&&(f[g]=L.access(d,"olddisplay",ta(d.nodeName)))):(e=S(d),"none"===c&&e||L.set(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xa(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Fa(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=Ba.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||n.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Fa(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xa(a,b,d)),"normal"===e&&b in Da&&(e=Da[b]),""===c||c?(f=parseFloat(e),c===!0||n.isNumeric(f)?f||0:e):e}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?za.test(n.css(a,"display"))&&0===a.offsetWidth?n.swap(a,Ca,function(){return Ia(a,b,d)}):Ia(a,b,d):void 0},set:function(a,c,d){var e=d&&wa(a);return Ga(a,c,d?Ha(a,b,d,"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),n.cssHooks.marginRight=ya(k.reliableMarginRight,function(a,b){return b?n.swap(a,{display:"inline-block"},xa,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ua.test(a)||(n.cssHooks[a+b].set=Ga)}),n.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=wa(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Ja(this,!0)},hide:function(){return Ja(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?n(this).show():n(this).hide()})}});function Ka(a,b,c,d,e){return new Ka.prototype.init(a,b,c,d,e)}n.Tween=Ka,Ka.prototype={constructor:Ka,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=Ka.propHooks[this.prop];return a&&a.get?a.get(this):Ka.propHooks._default.get(this)},run:function(a){var b,c=Ka.propHooks[this.prop];return this.options.duration?this.pos=b=n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Ka.propHooks._default.set(this),this}},Ka.prototype.init.prototype=Ka.prototype,Ka.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Ka.propHooks.scrollTop=Ka.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=Ka.prototype.init,n.fx.step={};var La,Ma,Na=/^(?:toggle|show|hide)$/,Oa=new RegExp("^(?:([+-])=|)("+Q+")([a-z%]*)$","i"),Pa=/queueHooks$/,Qa=[Va],Ra={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Oa.exec(b),f=e&&e[3]||(n.cssNumber[a]?"":"px"),g=(n.cssNumber[a]||"px"!==f&&+d)&&Oa.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sa(){return setTimeout(function(){La=void 0}),La=n.now()}function Ta(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function Ua(a,b,c){for(var d,e=(Ra[b]||[]).concat(Ra["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Va(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&S(a),q=L.get(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,"display"),k="none"===j?L.get(a,"olddisplay")||ta(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(o.display="inline-block")),c.overflow&&(o.overflow="hidden",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Na.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))"inline"===("none"===j?ta(a.nodeName):j)&&(o.display=j);else{q?"hidden"in q&&(p=q.hidden):q=L.access(a,"fxshow",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;L.remove(a,"fxshow");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ua(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function Wa(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xa(a,b,c){var d,e,f=0,g=Qa.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=La||Sa(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:La||Sa(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wa(k,j.opts.specialEasing);g>f;f++)if(d=Qa[f].call(j,a,k,j.opts))return d;return n.map(k,Ua,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(Xa,{tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Ra[c]=Ra[c]||[],Ra[c].unshift(b)},prefilter:function(a,b){b?Qa.unshift(a):Qa.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=Xa(this,n.extend({},a),f);(e||L.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pa.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=L.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(Ta(b,!0),a,d,e)}}),n.each({slideDown:Ta("show"),slideUp:Ta("hide"),slideToggle:Ta("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(La=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),La=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Ma||(Ma=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(Ma),Ma=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=l.createElement("input"),b=l.createElement("select"),c=b.appendChild(l.createElement("option"));a.type="checkbox",k.checkOn=""!==a.value,k.optSelected=c.selected,b.disabled=!0,k.optDisabled=!c.disabled,a=l.createElement("input"),a.value="t",a.type="radio",k.radioValue="t"===a.value}();var Ya,Za,$a=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return J(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?Za:Ya)),
void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void n.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),Za={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=$a[b]||n.find.attr;$a[b]=function(a,b,d){var e,f;return d||(f=$a[b],$a[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$a[b]=f),e}});var _a=/^(?:input|select|textarea|button)$/i;n.fn.extend({prop:function(a,b){return J(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute("tabindex")||_a.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),k.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this});var ab=/[\t\r\n\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h="string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ab," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||"string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ab," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?n.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=n(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||"boolean"===c)&&(this.className&&L.set(this,"__className__",this.className),this.className=this.className||a===!1?"":L.get(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ab," ").indexOf(b)>=0)return!0;return!1}});var bb=/\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(bb,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(d.value,f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},k.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var cb=n.now(),db=/\?/;n.parseJSON=function(a){return JSON.parse(a+"")},n.parseXML=function(a){var b,c;if(!a||"string"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,"text/xml")}catch(d){b=void 0}return(!b||b.getElementsByTagName("parsererror").length)&&n.error("Invalid XML: "+a),b};var eb=/#.*$/,fb=/([?&])_=[^&]*/,gb=/^(.*?):[ \t]*([^\r\n]*)$/gm,hb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,ib=/^(?:GET|HEAD)$/,jb=/^\/\//,kb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,lb={},mb={},nb="*/".concat("*"),ob=a.location.href,pb=kb.exec(ob.toLowerCase())||[];function qb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(n.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function rb(a,b,c,d){var e={},f=a===mb;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function sb(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function tb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function ub(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:ob,type:"GET",isLocal:hb.test(pb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":nb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?sb(sb(a,n.ajaxSettings),b):sb(n.ajaxSettings,a)},ajaxPrefilter:qb(lb),ajaxTransport:qb(mb),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=gb.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||ob)+"").replace(eb,"").replace(jb,pb[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(h=kb.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===pb[1]&&h[2]===pb[2]&&(h[3]||("http:"===h[1]?"80":"443"))===(pb[3]||("http:"===pb[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),rb(lb,k,b,v),2===t)return v;i=n.event&&k.global,i&&0===n.active++&&n.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!ib.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(db.test(d)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=fb.test(d)?d.replace(fb,"$1_="+cb++):d+(db.test(d)?"&":"?")+"_="+cb++)),k.ifModified&&(n.lastModified[d]&&v.setRequestHeader("If-Modified-Since",n.lastModified[d]),n.etag[d]&&v.setRequestHeader("If-None-Match",n.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+nb+"; q=0.01":""):k.accepts["*"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=rb(mb,k,b,v)){v.readyState=1,i&&m.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=tb(k,v,f)),u=ub(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(n.lastModified[d]=w),w=v.getResponseHeader("etag"),w&&(n.etag[d]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger("ajaxComplete",[v,k]),--n.active||n.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var vb=/%20/g,wb=/\[\]$/,xb=/\r?\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Ab(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join("&").replace(vb,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(xb,"\r\n")}}):{name:b.name,value:c.replace(xb,"\r\n")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Bb=0,Cb={},Db={0:200,1223:204},Eb=n.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in Cb)Cb[a]()}),k.cors=!!Eb&&"withCredentials"in Eb,k.ajax=Eb=!!Eb,n.ajaxTransport(function(a){var b;return k.cors||Eb&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Bb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Cb[g],b=f.onload=f.onerror=null,"abort"===a?f.abort():"error"===a?d(f.status,f.statusText):d(Db[f.status]||f.status,f.statusText,"string"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b("error"),b=Cb[g]=b("abort");try{f.send(a.hasContent&&a.data||null)}catch(h){if(b)throw h}},abort:function(){b&&b()}}:void 0}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=n("<script>").prop({async:!0,charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&e("error"===a.type?404:200,a.type)}),l.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Fb=[],Gb=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Fb.pop()||n.expando+"_"+cb++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Gb.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Gb.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Gb,"$1"+e):b.jsonp!==!1&&(b.url+=(db.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Fb.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||l;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var Hb=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&Hb)return Hb.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e,dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var Ib=a.document.documentElement;function Jb(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Jb(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===n.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(d=a.offset()),d.top+=n.css(a[0],"borderTopWidth",!0),d.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-d.top-n.css(c,"marginTop",!0),left:b.left-d.left-n.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Ib;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Ib})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(b,c){var d="pageYOffset"===c;n.fn[b]=function(e){return J(this,function(b,e,f){var g=Jb(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=ya(k.pixelPosition,function(a,c){return c?(c=xa(a,b),va.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return J(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var Kb=a.jQuery,Lb=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Lb),b&&a.jQuery===n&&(a.jQuery=Kb),n},typeof b===U&&(a.jQuery=a.$=n),n});
//# sourceMappingURL=jquery.min.map</script>
    <script>/*!
 * typeahead.js 0.11.1
 * https://github.com/twitter/typeahead.js
 * Copyright 2013-2015 Twitter, Inc. and other contributors; Licensed MIT
 */

!function(a,b){"function"==typeof define&&define.amd?define("bloodhound",["jquery"],function(c){return a.Bloodhound=b(c)}):"object"==typeof exports?module.exports=b(require("jquery")):a.Bloodhound=b(jQuery)}(this,function(a){var b=function(){"use strict";return{isMsie:function(){return/(msie|trident)/i.test(navigator.userAgent)?navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2]:!1},isBlankString:function(a){return!a||/^\s*$/.test(a)},escapeRegExChars:function(a){return a.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")},isString:function(a){return"string"==typeof a},isNumber:function(a){return"number"==typeof a},isArray:a.isArray,isFunction:a.isFunction,isObject:a.isPlainObject,isUndefined:function(a){return"undefined"==typeof a},isElement:function(a){return!(!a||1!==a.nodeType)},isJQuery:function(b){return b instanceof a},toStr:function(a){return b.isUndefined(a)||null===a?"":a+""},bind:a.proxy,each:function(b,c){function d(a,b){return c(b,a)}a.each(b,d)},map:a.map,filter:a.grep,every:function(b,c){var d=!0;return b?(a.each(b,function(a,e){return(d=c.call(null,e,a,b))?void 0:!1}),!!d):d},some:function(b,c){var d=!1;return b?(a.each(b,function(a,e){return(d=c.call(null,e,a,b))?!1:void 0}),!!d):d},mixin:a.extend,identity:function(a){return a},clone:function(b){return a.extend(!0,{},b)},getIdGenerator:function(){var a=0;return function(){return a++}},templatify:function(b){function c(){return String(b)}return a.isFunction(b)?b:c},defer:function(a){setTimeout(a,0)},debounce:function(a,b,c){var d,e;return function(){var f,g,h=this,i=arguments;return f=function(){d=null,c||(e=a.apply(h,i))},g=c&&!d,clearTimeout(d),d=setTimeout(f,b),g&&(e=a.apply(h,i)),e}},throttle:function(a,b){var c,d,e,f,g,h;return g=0,h=function(){g=new Date,e=null,f=a.apply(c,d)},function(){var i=new Date,j=b-(i-g);return c=this,d=arguments,0>=j?(clearTimeout(e),e=null,g=i,f=a.apply(c,d)):e||(e=setTimeout(h,j)),f}},stringify:function(a){return b.isString(a)?a:JSON.stringify(a)},noop:function(){}}}(),c="0.11.1",d=function(){"use strict";function a(a){return a=b.toStr(a),a?a.split(/\s+/):[]}function c(a){return a=b.toStr(a),a?a.split(/\W+/):[]}function d(a){return function(c){return c=b.isArray(c)?c:[].slice.call(arguments,0),function(d){var e=[];return b.each(c,function(c){e=e.concat(a(b.toStr(d[c])))}),e}}}return{nonword:c,whitespace:a,obj:{nonword:d(c),whitespace:d(a)}}}(),e=function(){"use strict";function c(c){this.maxSize=b.isNumber(c)?c:100,this.reset(),this.maxSize<=0&&(this.set=this.get=a.noop)}function d(){this.head=this.tail=null}function e(a,b){this.key=a,this.val=b,this.prev=this.next=null}return b.mixin(c.prototype,{set:function(a,b){var c,d=this.list.tail;this.size>=this.maxSize&&(this.list.remove(d),delete this.hash[d.key],this.size--),(c=this.hash[a])?(c.val=b,this.list.moveToFront(c)):(c=new e(a,b),this.list.add(c),this.hash[a]=c,this.size++)},get:function(a){var b=this.hash[a];return b?(this.list.moveToFront(b),b.val):void 0},reset:function(){this.size=0,this.hash={},this.list=new d}}),b.mixin(d.prototype,{add:function(a){this.head&&(a.next=this.head,this.head.prev=a),this.head=a,this.tail=this.tail||a},remove:function(a){a.prev?a.prev.next=a.next:this.head=a.next,a.next?a.next.prev=a.prev:this.tail=a.prev},moveToFront:function(a){this.remove(a),this.add(a)}}),c}(),f=function(){"use strict";function c(a,c){this.prefix=["__",a,"__"].join(""),this.ttlKey="__ttl__",this.keyMatcher=new RegExp("^"+b.escapeRegExChars(this.prefix)),this.ls=c||h,!this.ls&&this._noop()}function d(){return(new Date).getTime()}function e(a){return JSON.stringify(b.isUndefined(a)?null:a)}function f(b){return a.parseJSON(b)}function g(a){var b,c,d=[],e=h.length;for(b=0;e>b;b++)(c=h.key(b)).match(a)&&d.push(c.replace(a,""));return d}var h;try{h=window.localStorage,h.setItem("~~~","!"),h.removeItem("~~~")}catch(i){h=null}return b.mixin(c.prototype,{_prefix:function(a){return this.prefix+a},_ttlKey:function(a){return this._prefix(a)+this.ttlKey},_noop:function(){this.get=this.set=this.remove=this.clear=this.isExpired=b.noop},_safeSet:function(a,b){try{this.ls.setItem(a,b)}catch(c){"QuotaExceededError"===c.name&&(this.clear(),this._noop())}},get:function(a){return this.isExpired(a)&&this.remove(a),f(this.ls.getItem(this._prefix(a)))},set:function(a,c,f){return b.isNumber(f)?this._safeSet(this._ttlKey(a),e(d()+f)):this.ls.removeItem(this._ttlKey(a)),this._safeSet(this._prefix(a),e(c))},remove:function(a){return this.ls.removeItem(this._ttlKey(a)),this.ls.removeItem(this._prefix(a)),this},clear:function(){var a,b=g(this.keyMatcher);for(a=b.length;a--;)this.remove(b[a]);return this},isExpired:function(a){var c=f(this.ls.getItem(this._ttlKey(a)));return b.isNumber(c)&&d()>c?!0:!1}}),c}(),g=function(){"use strict";function c(a){a=a||{},this.cancelled=!1,this.lastReq=null,this._send=a.transport,this._get=a.limiter?a.limiter(this._get):this._get,this._cache=a.cache===!1?new e(0):h}var d=0,f={},g=6,h=new e(10);return c.setMaxPendingRequests=function(a){g=a},c.resetCache=function(){h.reset()},b.mixin(c.prototype,{_fingerprint:function(b){return b=b||{},b.url+b.type+a.param(b.data||{})},_get:function(a,b){function c(a){b(null,a),k._cache.set(i,a)}function e(){b(!0)}function h(){d--,delete f[i],k.onDeckRequestArgs&&(k._get.apply(k,k.onDeckRequestArgs),k.onDeckRequestArgs=null)}var i,j,k=this;i=this._fingerprint(a),this.cancelled||i!==this.lastReq||((j=f[i])?j.done(c).fail(e):g>d?(d++,f[i]=this._send(a).done(c).fail(e).always(h)):this.onDeckRequestArgs=[].slice.call(arguments,0))},get:function(c,d){var e,f;d=d||a.noop,c=b.isString(c)?{url:c}:c||{},f=this._fingerprint(c),this.cancelled=!1,this.lastReq=f,(e=this._cache.get(f))?d(null,e):this._get(c,d)},cancel:function(){this.cancelled=!0}}),c}(),h=window.SearchIndex=function(){"use strict";function c(c){c=c||{},c.datumTokenizer&&c.queryTokenizer||a.error("datumTokenizer and queryTokenizer are both required"),this.identify=c.identify||b.stringify,this.datumTokenizer=c.datumTokenizer,this.queryTokenizer=c.queryTokenizer,this.reset()}function d(a){return a=b.filter(a,function(a){return!!a}),a=b.map(a,function(a){return a.toLowerCase()})}function e(){var a={};return a[i]=[],a[h]={},a}function f(a){for(var b={},c=[],d=0,e=a.length;e>d;d++)b[a[d]]||(b[a[d]]=!0,c.push(a[d]));return c}function g(a,b){var c=0,d=0,e=[];a=a.sort(),b=b.sort();for(var f=a.length,g=b.length;f>c&&g>d;)a[c]<b[d]?c++:a[c]>b[d]?d++:(e.push(a[c]),c++,d++);return e}var h="c",i="i";return b.mixin(c.prototype,{bootstrap:function(a){this.datums=a.datums,this.trie=a.trie},add:function(a){var c=this;a=b.isArray(a)?a:[a],b.each(a,function(a){var f,g;c.datums[f=c.identify(a)]=a,g=d(c.datumTokenizer(a)),b.each(g,function(a){var b,d,g;for(b=c.trie,d=a.split("");g=d.shift();)b=b[h][g]||(b[h][g]=e()),b[i].push(f)})})},get:function(a){var c=this;return b.map(a,function(a){return c.datums[a]})},search:function(a){var c,e,j=this;return c=d(this.queryTokenizer(a)),b.each(c,function(a){var b,c,d,f;if(e&&0===e.length)return!1;for(b=j.trie,c=a.split("");b&&(d=c.shift());)b=b[h][d];return b&&0===c.length?(f=b[i].slice(0),void(e=e?g(e,f):f)):(e=[],!1)}),e?b.map(f(e),function(a){return j.datums[a]}):[]},all:function(){var a=[];for(var b in this.datums)a.push(this.datums[b]);return a},reset:function(){this.datums={},this.trie=e()},serialize:function(){return{datums:this.datums,trie:this.trie}}}),c}(),i=function(){"use strict";function a(a){this.url=a.url,this.ttl=a.ttl,this.cache=a.cache,this.prepare=a.prepare,this.transform=a.transform,this.transport=a.transport,this.thumbprint=a.thumbprint,this.storage=new f(a.cacheKey)}var c;return c={data:"data",protocol:"protocol",thumbprint:"thumbprint"},b.mixin(a.prototype,{_settings:function(){return{url:this.url,type:"GET",dataType:"json"}},store:function(a){this.cache&&(this.storage.set(c.data,a,this.ttl),this.storage.set(c.protocol,location.protocol,this.ttl),this.storage.set(c.thumbprint,this.thumbprint,this.ttl))},fromCache:function(){var a,b={};return this.cache?(b.data=this.storage.get(c.data),b.protocol=this.storage.get(c.protocol),b.thumbprint=this.storage.get(c.thumbprint),a=b.thumbprint!==this.thumbprint||b.protocol!==location.protocol,b.data&&!a?b.data:null):null},fromNetwork:function(a){function b(){a(!0)}function c(b){a(null,e.transform(b))}var d,e=this;a&&(d=this.prepare(this._settings()),this.transport(d).fail(b).done(c))},clear:function(){return this.storage.clear(),this}}),a}(),j=function(){"use strict";function a(a){this.url=a.url,this.prepare=a.prepare,this.transform=a.transform,this.transport=new g({cache:a.cache,limiter:a.limiter,transport:a.transport})}return b.mixin(a.prototype,{_settings:function(){return{url:this.url,type:"GET",dataType:"json"}},get:function(a,b){function c(a,c){b(a?[]:e.transform(c))}var d,e=this;if(b)return a=a||"",d=this.prepare(a,this._settings()),this.transport.get(d,c)},cancelLastRequest:function(){this.transport.cancel()}}),a}(),k=function(){"use strict";function d(d){var e;return d?(e={url:null,ttl:864e5,cache:!0,cacheKey:null,thumbprint:"",prepare:b.identity,transform:b.identity,transport:null},d=b.isString(d)?{url:d}:d,d=b.mixin(e,d),!d.url&&a.error("prefetch requires url to be set"),d.transform=d.filter||d.transform,d.cacheKey=d.cacheKey||d.url,d.thumbprint=c+d.thumbprint,d.transport=d.transport?h(d.transport):a.ajax,d):null}function e(c){var d;if(c)return d={url:null,cache:!0,prepare:null,replace:null,wildcard:null,limiter:null,rateLimitBy:"debounce",rateLimitWait:300,transform:b.identity,transport:null},c=b.isString(c)?{url:c}:c,c=b.mixin(d,c),!c.url&&a.error("remote requires url to be set"),c.transform=c.filter||c.transform,c.prepare=f(c),c.limiter=g(c),c.transport=c.transport?h(c.transport):a.ajax,delete c.replace,delete c.wildcard,delete c.rateLimitBy,delete c.rateLimitWait,c}function f(a){function b(a,b){return b.url=f(b.url,a),b}function c(a,b){return b.url=b.url.replace(g,encodeURIComponent(a)),b}function d(a,b){return b}var e,f,g;return e=a.prepare,f=a.replace,g=a.wildcard,e?e:e=f?b:a.wildcard?c:d}function g(a){function c(a){return function(c){return b.debounce(c,a)}}function d(a){return function(c){return b.throttle(c,a)}}var e,f,g;return e=a.limiter,f=a.rateLimitBy,g=a.rateLimitWait,e||(e=/^throttle$/i.test(f)?d(g):c(g)),e}function h(c){return function(d){function e(a){b.defer(function(){g.resolve(a)})}function f(a){b.defer(function(){g.reject(a)})}var g=a.Deferred();return c(d,e,f),g}}return function(c){var f,g;return f={initialize:!0,identify:b.stringify,datumTokenizer:null,queryTokenizer:null,sufficient:5,sorter:null,local:[],prefetch:null,remote:null},c=b.mixin(f,c||{}),!c.datumTokenizer&&a.error("datumTokenizer is required"),!c.queryTokenizer&&a.error("queryTokenizer is required"),g=c.sorter,c.sorter=g?function(a){return a.sort(g)}:b.identity,c.local=b.isFunction(c.local)?c.local():c.local,c.prefetch=d(c.prefetch),c.remote=e(c.remote),c}}(),l=function(){"use strict";function c(a){a=k(a),this.sorter=a.sorter,this.identify=a.identify,this.sufficient=a.sufficient,this.local=a.local,this.remote=a.remote?new j(a.remote):null,this.prefetch=a.prefetch?new i(a.prefetch):null,this.index=new h({identify:this.identify,datumTokenizer:a.datumTokenizer,queryTokenizer:a.queryTokenizer}),a.initialize!==!1&&this.initialize()}var e;return e=window&&window.Bloodhound,c.noConflict=function(){return window&&(window.Bloodhound=e),c},c.tokenizers=d,b.mixin(c.prototype,{__ttAdapter:function(){function a(a,b,d){return c.search(a,b,d)}function b(a,b){return c.search(a,b)}var c=this;return this.remote?a:b},_loadPrefetch:function(){function b(a,b){return a?c.reject():(e.add(b),e.prefetch.store(e.index.serialize()),void c.resolve())}var c,d,e=this;return c=a.Deferred(),this.prefetch?(d=this.prefetch.fromCache())?(this.index.bootstrap(d),c.resolve()):this.prefetch.fromNetwork(b):c.resolve(),c.promise()},_initialize:function(){function a(){b.add(b.local)}var b=this;return this.clear(),(this.initPromise=this._loadPrefetch()).done(a),this.initPromise},initialize:function(a){return!this.initPromise||a?this._initialize():this.initPromise},add:function(a){return this.index.add(a),this},get:function(a){return a=b.isArray(a)?a:[].slice.call(arguments),this.index.get(a)},search:function(a,c,d){function e(a){var c=[];b.each(a,function(a){!b.some(f,function(b){return g.identify(a)===g.identify(b)})&&c.push(a)}),d&&d(c)}var f,g=this;return f=this.sorter(this.index.search(a)),c(this.remote?f.slice():f),this.remote&&f.length<this.sufficient?this.remote.get(a,e):this.remote&&this.remote.cancelLastRequest(),this},all:function(){return this.index.all()},clear:function(){return this.index.reset(),this},clearPrefetchCache:function(){return this.prefetch&&this.prefetch.clear(),this},clearRemoteCache:function(){return g.resetCache(),this},ttAdapter:function(){return this.__ttAdapter()}}),c}();return l}),function(a,b){"function"==typeof define&&define.amd?define("typeahead.js",["jquery"],function(a){return b(a)}):"object"==typeof exports?module.exports=b(require("jquery")):b(jQuery)}(this,function(a){var b=function(){"use strict";return{isMsie:function(){return/(msie|trident)/i.test(navigator.userAgent)?navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2]:!1},isBlankString:function(a){return!a||/^\s*$/.test(a)},escapeRegExChars:function(a){return a.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")},isString:function(a){return"string"==typeof a},isNumber:function(a){return"number"==typeof a},isArray:a.isArray,isFunction:a.isFunction,isObject:a.isPlainObject,isUndefined:function(a){return"undefined"==typeof a},isElement:function(a){return!(!a||1!==a.nodeType)},isJQuery:function(b){return b instanceof a},toStr:function(a){return b.isUndefined(a)||null===a?"":a+""},bind:a.proxy,each:function(b,c){function d(a,b){return c(b,a)}a.each(b,d)},map:a.map,filter:a.grep,every:function(b,c){var d=!0;return b?(a.each(b,function(a,e){return(d=c.call(null,e,a,b))?void 0:!1}),!!d):d},some:function(b,c){var d=!1;return b?(a.each(b,function(a,e){return(d=c.call(null,e,a,b))?!1:void 0}),!!d):d},mixin:a.extend,identity:function(a){return a},clone:function(b){return a.extend(!0,{},b)},getIdGenerator:function(){var a=0;return function(){return a++}},templatify:function(b){function c(){return String(b)}return a.isFunction(b)?b:c},defer:function(a){setTimeout(a,0)},debounce:function(a,b,c){var d,e;return function(){var f,g,h=this,i=arguments;return f=function(){d=null,c||(e=a.apply(h,i))},g=c&&!d,clearTimeout(d),d=setTimeout(f,b),g&&(e=a.apply(h,i)),e}},throttle:function(a,b){var c,d,e,f,g,h;return g=0,h=function(){g=new Date,e=null,f=a.apply(c,d)},function(){var i=new Date,j=b-(i-g);return c=this,d=arguments,0>=j?(clearTimeout(e),e=null,g=i,f=a.apply(c,d)):e||(e=setTimeout(h,j)),f}},stringify:function(a){return b.isString(a)?a:JSON.stringify(a)},noop:function(){}}}(),c=function(){"use strict";function a(a){var g,h;return h=b.mixin({},f,a),g={css:e(),classes:h,html:c(h),selectors:d(h)},{css:g.css,html:g.html,classes:g.classes,selectors:g.selectors,mixin:function(a){b.mixin(a,g)}}}function c(a){return{wrapper:'<span class="'+a.wrapper+'"></span>',menu:'<div class="'+a.menu+'"></div>'}}function d(a){var c={};return b.each(a,function(a,b){c[b]="."+a}),c}function e(){var a={wrapper:{position:"relative",display:"inline-block"},hint:{position:"absolute",top:"0",left:"0",borderColor:"transparent",boxShadow:"none",opacity:"1"},input:{position:"relative",verticalAlign:"top",backgroundColor:"transparent"},inputWithNoHint:{position:"relative",verticalAlign:"top"},menu:{position:"absolute",top:"100%",left:"0",zIndex:"100",display:"none"},ltr:{left:"0",right:"auto"},rtl:{left:"auto",right:" 0"}};return b.isMsie()&&b.mixin(a.input,{backgroundImage:"url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"}),a}var f={wrapper:"twitter-typeahead",input:"tt-input",hint:"tt-hint",menu:"tt-menu",dataset:"tt-dataset",suggestion:"tt-suggestion",selectable:"tt-selectable",empty:"tt-empty",open:"tt-open",cursor:"tt-cursor",highlight:"tt-highlight"};return a}(),d=function(){"use strict";function c(b){b&&b.el||a.error("EventBus initialized without el"),this.$el=a(b.el)}var d,e;return d="typeahead:",e={render:"rendered",cursorchange:"cursorchanged",select:"selected",autocomplete:"autocompleted"},b.mixin(c.prototype,{_trigger:function(b,c){var e;return e=a.Event(d+b),(c=c||[]).unshift(e),this.$el.trigger.apply(this.$el,c),e},before:function(a){var b,c;return b=[].slice.call(arguments,1),c=this._trigger("before"+a,b),c.isDefaultPrevented()},trigger:function(a){var b;this._trigger(a,[].slice.call(arguments,1)),(b=e[a])&&this._trigger(b,[].slice.call(arguments,1))}}),c}(),e=function(){"use strict";function a(a,b,c,d){var e;if(!c)return this;for(b=b.split(i),c=d?h(c,d):c,this._callbacks=this._callbacks||{};e=b.shift();)this._callbacks[e]=this._callbacks[e]||{sync:[],async:[]},this._callbacks[e][a].push(c);return this}function b(b,c,d){return a.call(this,"async",b,c,d)}function c(b,c,d){return a.call(this,"sync",b,c,d)}function d(a){var b;if(!this._callbacks)return this;for(a=a.split(i);b=a.shift();)delete this._callbacks[b];return this}function e(a){var b,c,d,e,g;if(!this._callbacks)return this;for(a=a.split(i),d=[].slice.call(arguments,1);(b=a.shift())&&(c=this._callbacks[b]);)e=f(c.sync,this,[b].concat(d)),g=f(c.async,this,[b].concat(d)),e()&&j(g);return this}function f(a,b,c){function d(){for(var d,e=0,f=a.length;!d&&f>e;e+=1)d=a[e].apply(b,c)===!1;return!d}return d}function g(){var a;return a=window.setImmediate?function(a){setImmediate(function(){a()})}:function(a){setTimeout(function(){a()},0)}}function h(a,b){return a.bind?a.bind(b):function(){a.apply(b,[].slice.call(arguments,0))}}var i=/\s+/,j=g();return{onSync:c,onAsync:b,off:d,trigger:e}}(),f=function(a){"use strict";function c(a,c,d){for(var e,f=[],g=0,h=a.length;h>g;g++)f.push(b.escapeRegExChars(a[g]));return e=d?"\\b("+f.join("|")+")\\b":"("+f.join("|")+")",c?new RegExp(e):new RegExp(e,"i")}var d={node:null,pattern:null,tagName:"strong",className:null,wordsOnly:!1,caseSensitive:!1};return function(e){function f(b){var c,d,f;return(c=h.exec(b.data))&&(f=a.createElement(e.tagName),e.className&&(f.className=e.className),d=b.splitText(c.index),d.splitText(c[0].length),f.appendChild(d.cloneNode(!0)),b.parentNode.replaceChild(f,d)),!!c}function g(a,b){for(var c,d=3,e=0;e<a.childNodes.length;e++)c=a.childNodes[e],c.nodeType===d?e+=b(c)?1:0:g(c,b)}var h;e=b.mixin({},d,e),e.node&&e.pattern&&(e.pattern=b.isArray(e.pattern)?e.pattern:[e.pattern],h=c(e.pattern,e.caseSensitive,e.wordsOnly),g(e.node,f))}}(window.document),g=function(){"use strict";function c(c,e){c=c||{},c.input||a.error("input is missing"),e.mixin(this),this.$hint=a(c.hint),this.$input=a(c.input),this.query=this.$input.val(),this.queryWhenFocused=this.hasFocus()?this.query:null,this.$overflowHelper=d(this.$input),this._checkLanguageDirection(),0===this.$hint.length&&(this.setHint=this.getHint=this.clearHint=this.clearHintIfInvalid=b.noop)}function d(b){return a('<pre aria-hidden="true"></pre>').css({position:"absolute",visibility:"hidden",whiteSpace:"pre",fontFamily:b.css("font-family"),fontSize:b.css("font-size"),fontStyle:b.css("font-style"),fontVariant:b.css("font-variant"),fontWeight:b.css("font-weight"),wordSpacing:b.css("word-spacing"),letterSpacing:b.css("letter-spacing"),textIndent:b.css("text-indent"),textRendering:b.css("text-rendering"),textTransform:b.css("text-transform")}).insertAfter(b)}function f(a,b){return c.normalizeQuery(a)===c.normalizeQuery(b)}function g(a){return a.altKey||a.ctrlKey||a.metaKey||a.shiftKey}var h;return h={9:"tab",27:"esc",37:"left",39:"right",13:"enter",38:"up",40:"down"},c.normalizeQuery=function(a){return b.toStr(a).replace(/^\s*/g,"").replace(/\s{2,}/g," ")},b.mixin(c.prototype,e,{_onBlur:function(){this.resetInputValue(),this.trigger("blurred")},_onFocus:function(){this.queryWhenFocused=this.query,this.trigger("focused")},_onKeydown:function(a){var b=h[a.which||a.keyCode];this._managePreventDefault(b,a),b&&this._shouldTrigger(b,a)&&this.trigger(b+"Keyed",a)},_onInput:function(){this._setQuery(this.getInputValue()),this.clearHintIfInvalid(),this._checkLanguageDirection()},_managePreventDefault:function(a,b){var c;switch(a){case"up":case"down":c=!g(b);break;default:c=!1}c&&b.preventDefault()},_shouldTrigger:function(a,b){var c;switch(a){case"tab":c=!g(b);break;default:c=!0}return c},_checkLanguageDirection:function(){var a=(this.$input.css("direction")||"ltr").toLowerCase();this.dir!==a&&(this.dir=a,this.$hint.attr("dir",a),this.trigger("langDirChanged",a))},_setQuery:function(a,b){var c,d;c=f(a,this.query),d=c?this.query.length!==a.length:!1,this.query=a,b||c?!b&&d&&this.trigger("whitespaceChanged",this.query):this.trigger("queryChanged",this.query)},bind:function(){var a,c,d,e,f=this;return a=b.bind(this._onBlur,this),c=b.bind(this._onFocus,this),d=b.bind(this._onKeydown,this),e=b.bind(this._onInput,this),this.$input.on("blur.tt",a).on("focus.tt",c).on("keydown.tt",d),!b.isMsie()||b.isMsie()>9?this.$input.on("input.tt",e):this.$input.on("keydown.tt keypress.tt cut.tt paste.tt",function(a){h[a.which||a.keyCode]||b.defer(b.bind(f._onInput,f,a))}),this},focus:function(){this.$input.focus()},blur:function(){this.$input.blur()},getLangDir:function(){return this.dir},getQuery:function(){return this.query||""},setQuery:function(a,b){this.setInputValue(a),this._setQuery(a,b)},hasQueryChangedSinceLastFocus:function(){return this.query!==this.queryWhenFocused},getInputValue:function(){return this.$input.val()},setInputValue:function(a){this.$input.val(a),this.clearHintIfInvalid(),this._checkLanguageDirection()},resetInputValue:function(){this.setInputValue(this.query)},getHint:function(){return this.$hint.val()},setHint:function(a){this.$hint.val(a)},clearHint:function(){this.setHint("")},clearHintIfInvalid:function(){var a,b,c,d;a=this.getInputValue(),b=this.getHint(),c=a!==b&&0===b.indexOf(a),d=""!==a&&c&&!this.hasOverflow(),!d&&this.clearHint()},hasFocus:function(){return this.$input.is(":focus")},hasOverflow:function(){var a=this.$input.width()-2;return this.$overflowHelper.text(this.getInputValue()),this.$overflowHelper.width()>=a},isCursorAtEnd:function(){var a,c,d;return a=this.$input.val().length,c=this.$input[0].selectionStart,b.isNumber(c)?c===a:document.selection?(d=document.selection.createRange(),d.moveStart("character",-a),a===d.text.length):!0},destroy:function(){this.$hint.off(".tt"),this.$input.off(".tt"),this.$overflowHelper.remove(),this.$hint=this.$input=this.$overflowHelper=a("<div>")}}),c}(),h=function(){"use strict";function c(c,e){c=c||{},c.templates=c.templates||{},c.templates.notFound=c.templates.notFound||c.templates.empty,c.source||a.error("missing source"),c.node||a.error("missing node"),c.name&&!h(c.name)&&a.error("invalid dataset name: "+c.name),e.mixin(this),this.highlight=!!c.highlight,this.name=c.name||j(),this.limit=c.limit||5,this.displayFn=d(c.display||c.displayKey),this.templates=g(c.templates,this.displayFn),this.source=c.source.__ttAdapter?c.source.__ttAdapter():c.source,this.async=b.isUndefined(c.async)?this.source.length>2:!!c.async,this._resetLastSuggestion(),this.$el=a(c.node).addClass(this.classes.dataset).addClass(this.classes.dataset+"-"+this.name)}function d(a){function c(b){return b[a]}return a=a||b.stringify,b.isFunction(a)?a:c}function g(c,d){function e(b){return a("<div>").text(d(b))}return{notFound:c.notFound&&b.templatify(c.notFound),pending:c.pending&&b.templatify(c.pending),header:c.header&&b.templatify(c.header),footer:c.footer&&b.templatify(c.footer),suggestion:c.suggestion||e}}function h(a){return/^[_a-zA-Z0-9-]+$/.test(a)}var i,j;return i={val:"tt-selectable-display",obj:"tt-selectable-object"},j=b.getIdGenerator(),c.extractData=function(b){var c=a(b);return c.data(i.obj)?{val:c.data(i.val)||"",obj:c.data(i.obj)||null}:null},b.mixin(c.prototype,e,{_overwrite:function(a,b){b=b||[],b.length?this._renderSuggestions(a,b):this.async&&this.templates.pending?this._renderPending(a):!this.async&&this.templates.notFound?this._renderNotFound(a):this._empty(),this.trigger("rendered",this.name,b,!1)},_append:function(a,b){b=b||[],b.length&&this.$lastSuggestion.length?this._appendSuggestions(a,b):b.length?this._renderSuggestions(a,b):!this.$lastSuggestion.length&&this.templates.notFound&&this._renderNotFound(a),this.trigger("rendered",this.name,b,!0)},_renderSuggestions:function(a,b){var c;c=this._getSuggestionsFragment(a,b),this.$lastSuggestion=c.children().last(),this.$el.html(c).prepend(this._getHeader(a,b)).append(this._getFooter(a,b))},_appendSuggestions:function(a,b){var c,d;c=this._getSuggestionsFragment(a,b),d=c.children().last(),this.$lastSuggestion.after(c),this.$lastSuggestion=d},_renderPending:function(a){var b=this.templates.pending;this._resetLastSuggestion(),b&&this.$el.html(b({query:a,dataset:this.name}))},_renderNotFound:function(a){var b=this.templates.notFound;this._resetLastSuggestion(),b&&this.$el.html(b({query:a,dataset:this.name}))},_empty:function(){this.$el.empty(),this._resetLastSuggestion()},_getSuggestionsFragment:function(c,d){var e,g=this;return e=document.createDocumentFragment(),b.each(d,function(b){var d,f;f=g._injectQuery(c,b),d=a(g.templates.suggestion(f)).data(i.obj,b).data(i.val,g.displayFn(b)).addClass(g.classes.suggestion+" "+g.classes.selectable),e.appendChild(d[0])}),this.highlight&&f({className:this.classes.highlight,node:e,pattern:c}),a(e)},_getFooter:function(a,b){return this.templates.footer?this.templates.footer({query:a,suggestions:b,dataset:this.name}):null},_getHeader:function(a,b){return this.templates.header?this.templates.header({query:a,suggestions:b,dataset:this.name}):null},_resetLastSuggestion:function(){this.$lastSuggestion=a()},_injectQuery:function(a,c){return b.isObject(c)?b.mixin({_query:a},c):c},update:function(b){function c(a){g||(g=!0,a=(a||[]).slice(0,e.limit),h=a.length,e._overwrite(b,a),h<e.limit&&e.async&&e.trigger("asyncRequested",b))}function d(c){c=c||[],!f&&h<e.limit&&(e.cancel=a.noop,h+=c.length,e._append(b,c.slice(0,e.limit-h)),e.async&&e.trigger("asyncReceived",b))}var e=this,f=!1,g=!1,h=0;this.cancel(),this.cancel=function(){f=!0,e.cancel=a.noop,e.async&&e.trigger("asyncCanceled",b)},this.source(b,c,d),!g&&c([])},cancel:a.noop,clear:function(){this._empty(),this.cancel(),this.trigger("cleared")},isEmpty:function(){return this.$el.is(":empty")},destroy:function(){this.$el=a("<div>")}}),c}(),i=function(){"use strict";function c(c,d){function e(b){var c=f.$node.find(b.node).first();return b.node=c.length?c:a("<div>").appendTo(f.$node),new h(b,d)}var f=this;c=c||{},c.node||a.error("node is required"),d.mixin(this),this.$node=a(c.node),this.query=null,this.datasets=b.map(c.datasets,e)}return b.mixin(c.prototype,e,{_onSelectableClick:function(b){this.trigger("selectableClicked",a(b.currentTarget))},_onRendered:function(a,b,c,d){this.$node.toggleClass(this.classes.empty,this._allDatasetsEmpty()),this.trigger("datasetRendered",b,c,d)},_onCleared:function(){this.$node.toggleClass(this.classes.empty,this._allDatasetsEmpty()),this.trigger("datasetCleared")},_propagate:function(){this.trigger.apply(this,arguments)},_allDatasetsEmpty:function(){function a(a){return a.isEmpty()}return b.every(this.datasets,a)},_getSelectables:function(){return this.$node.find(this.selectors.selectable)},_removeCursor:function(){var a=this.getActiveSelectable();a&&a.removeClass(this.classes.cursor)},_ensureVisible:function(a){var b,c,d,e;b=a.position().top,c=b+a.outerHeight(!0),d=this.$node.scrollTop(),e=this.$node.height()+parseInt(this.$node.css("paddingTop"),10)+parseInt(this.$node.css("paddingBottom"),10),0>b?this.$node.scrollTop(d+b):c>e&&this.$node.scrollTop(d+(c-e))},bind:function(){var a,c=this;return a=b.bind(this._onSelectableClick,this),this.$node.on("click.tt",this.selectors.selectable,a),b.each(this.datasets,function(a){a.onSync("asyncRequested",c._propagate,c).onSync("asyncCanceled",c._propagate,c).onSync("asyncReceived",c._propagate,c).onSync("rendered",c._onRendered,c).onSync("cleared",c._onCleared,c)}),this},isOpen:function(){return this.$node.hasClass(this.classes.open)},open:function(){this.$node.addClass(this.classes.open)},close:function(){this.$node.removeClass(this.classes.open),this._removeCursor()},setLanguageDirection:function(a){this.$node.attr("dir",a)},selectableRelativeToCursor:function(a){var b,c,d,e;return c=this.getActiveSelectable(),b=this._getSelectables(),d=c?b.index(c):-1,e=d+a,e=(e+1)%(b.length+1)-1,e=-1>e?b.length-1:e,-1===e?null:b.eq(e)},setCursor:function(a){this._removeCursor(),(a=a&&a.first())&&(a.addClass(this.classes.cursor),this._ensureVisible(a))},getSelectableData:function(a){return a&&a.length?h.extractData(a):null},getActiveSelectable:function(){var a=this._getSelectables().filter(this.selectors.cursor).first();return a.length?a:null},getTopSelectable:function(){var a=this._getSelectables().first();return a.length?a:null},update:function(a){function c(b){b.update(a)}var d=a!==this.query;return d&&(this.query=a,b.each(this.datasets,c)),d},empty:function(){function a(a){a.clear()}b.each(this.datasets,a),this.query=null,this.$node.addClass(this.classes.empty)},destroy:function(){function c(a){a.destroy()}this.$node.off(".tt"),this.$node=a("<div>"),b.each(this.datasets,c)}}),c}(),j=function(){"use strict";function a(){i.apply(this,[].slice.call(arguments,0))}var c=i.prototype;return b.mixin(a.prototype,i.prototype,{open:function(){return!this._allDatasetsEmpty()&&this._show(),c.open.apply(this,[].slice.call(arguments,0))},close:function(){return this._hide(),c.close.apply(this,[].slice.call(arguments,0))},_onRendered:function(){return this._allDatasetsEmpty()?this._hide():this.isOpen()&&this._show(),c._onRendered.apply(this,[].slice.call(arguments,0))},_onCleared:function(){return this._allDatasetsEmpty()?this._hide():this.isOpen()&&this._show(),c._onCleared.apply(this,[].slice.call(arguments,0))},setLanguageDirection:function(a){return this.$node.css("ltr"===a?this.css.ltr:this.css.rtl),c.setLanguageDirection.apply(this,[].slice.call(arguments,0))},_hide:function(){this.$node.hide()},_show:function(){this.$node.css("display","block")}}),a}(),k=function(){"use strict";function c(c,e){var f,g,h,i,j,k,l,m,n,o,p;c=c||{},c.input||a.error("missing input"),c.menu||a.error("missing menu"),c.eventBus||a.error("missing event bus"),e.mixin(this),this.eventBus=c.eventBus,this.minLength=b.isNumber(c.minLength)?c.minLength:1,this.input=c.input,this.menu=c.menu,this.enabled=!0,this.active=!1,this.input.hasFocus()&&this.activate(),this.dir=this.input.getLangDir(),this._hacks(),this.menu.bind().onSync("selectableClicked",this._onSelectableClicked,this).onSync("asyncRequested",this._onAsyncRequested,this).onSync("asyncCanceled",this._onAsyncCanceled,this).onSync("asyncReceived",this._onAsyncReceived,this).onSync("datasetRendered",this._onDatasetRendered,this).onSync("datasetCleared",this._onDatasetCleared,this),f=d(this,"activate","open","_onFocused"),g=d(this,"deactivate","_onBlurred"),h=d(this,"isActive","isOpen","_onEnterKeyed"),i=d(this,"isActive","isOpen","_onTabKeyed"),j=d(this,"isActive","_onEscKeyed"),k=d(this,"isActive","open","_onUpKeyed"),l=d(this,"isActive","open","_onDownKeyed"),m=d(this,"isActive","isOpen","_onLeftKeyed"),n=d(this,"isActive","isOpen","_onRightKeyed"),o=d(this,"_openIfActive","_onQueryChanged"),p=d(this,"_openIfActive","_onWhitespaceChanged"),this.input.bind().onSync("focused",f,this).onSync("blurred",g,this).onSync("enterKeyed",h,this).onSync("tabKeyed",i,this).onSync("escKeyed",j,this).onSync("upKeyed",k,this).onSync("downKeyed",l,this).onSync("leftKeyed",m,this).onSync("rightKeyed",n,this).onSync("queryChanged",o,this).onSync("whitespaceChanged",p,this).onSync("langDirChanged",this._onLangDirChanged,this)}function d(a){var c=[].slice.call(arguments,1);return function(){var d=[].slice.call(arguments);b.each(c,function(b){return a[b].apply(a,d)})}}return b.mixin(c.prototype,{_hacks:function(){var c,d;c=this.input.$input||a("<div>"),d=this.menu.$node||a("<div>"),c.on("blur.tt",function(a){var e,f,g;
e=document.activeElement,f=d.is(e),g=d.has(e).length>0,b.isMsie()&&(f||g)&&(a.preventDefault(),a.stopImmediatePropagation(),b.defer(function(){c.focus()}))}),d.on("mousedown.tt",function(a){a.preventDefault()})},_onSelectableClicked:function(a,b){this.select(b)},_onDatasetCleared:function(){this._updateHint()},_onDatasetRendered:function(a,b,c,d){this._updateHint(),this.eventBus.trigger("render",c,d,b)},_onAsyncRequested:function(a,b,c){this.eventBus.trigger("asyncrequest",c,b)},_onAsyncCanceled:function(a,b,c){this.eventBus.trigger("asynccancel",c,b)},_onAsyncReceived:function(a,b,c){this.eventBus.trigger("asyncreceive",c,b)},_onFocused:function(){this._minLengthMet()&&this.menu.update(this.input.getQuery())},_onBlurred:function(){this.input.hasQueryChangedSinceLastFocus()&&this.eventBus.trigger("change",this.input.getQuery())},_onEnterKeyed:function(a,b){var c;(c=this.menu.getActiveSelectable())&&this.select(c)&&b.preventDefault()},_onTabKeyed:function(a,b){var c;(c=this.menu.getActiveSelectable())?this.select(c)&&b.preventDefault():(c=this.menu.getTopSelectable())&&this.autocomplete(c)&&b.preventDefault()},_onEscKeyed:function(){this.close()},_onUpKeyed:function(){this.moveCursor(-1)},_onDownKeyed:function(){this.moveCursor(1)},_onLeftKeyed:function(){"rtl"===this.dir&&this.input.isCursorAtEnd()&&this.autocomplete(this.menu.getTopSelectable())},_onRightKeyed:function(){"ltr"===this.dir&&this.input.isCursorAtEnd()&&this.autocomplete(this.menu.getTopSelectable())},_onQueryChanged:function(a,b){this._minLengthMet(b)?this.menu.update(b):this.menu.empty()},_onWhitespaceChanged:function(){this._updateHint()},_onLangDirChanged:function(a,b){this.dir!==b&&(this.dir=b,this.menu.setLanguageDirection(b))},_openIfActive:function(){this.isActive()&&this.open()},_minLengthMet:function(a){return a=b.isString(a)?a:this.input.getQuery()||"",a.length>=this.minLength},_updateHint:function(){var a,c,d,e,f,h,i;a=this.menu.getTopSelectable(),c=this.menu.getSelectableData(a),d=this.input.getInputValue(),!c||b.isBlankString(d)||this.input.hasOverflow()?this.input.clearHint():(e=g.normalizeQuery(d),f=b.escapeRegExChars(e),h=new RegExp("^(?:"+f+")(.+$)","i"),i=h.exec(c.val),i&&this.input.setHint(d+i[1]))},isEnabled:function(){return this.enabled},enable:function(){this.enabled=!0},disable:function(){this.enabled=!1},isActive:function(){return this.active},activate:function(){return this.isActive()?!0:!this.isEnabled()||this.eventBus.before("active")?!1:(this.active=!0,this.eventBus.trigger("active"),!0)},deactivate:function(){return this.isActive()?this.eventBus.before("idle")?!1:(this.active=!1,this.close(),this.eventBus.trigger("idle"),!0):!0},isOpen:function(){return this.menu.isOpen()},open:function(){return this.isOpen()||this.eventBus.before("open")||(this.menu.open(),this._updateHint(),this.eventBus.trigger("open")),this.isOpen()},close:function(){return this.isOpen()&&!this.eventBus.before("close")&&(this.menu.close(),this.input.clearHint(),this.input.resetInputValue(),this.eventBus.trigger("close")),!this.isOpen()},setVal:function(a){this.input.setQuery(b.toStr(a))},getVal:function(){return this.input.getQuery()},select:function(a){var b=this.menu.getSelectableData(a);return b&&!this.eventBus.before("select",b.obj)?(this.input.setQuery(b.val,!0),this.eventBus.trigger("select",b.obj),this.close(),!0):!1},autocomplete:function(a){var b,c,d;return b=this.input.getQuery(),c=this.menu.getSelectableData(a),d=c&&b!==c.val,d&&!this.eventBus.before("autocomplete",c.obj)?(this.input.setQuery(c.val),this.eventBus.trigger("autocomplete",c.obj),!0):!1},moveCursor:function(a){var b,c,d,e,f;return b=this.input.getQuery(),c=this.menu.selectableRelativeToCursor(a),d=this.menu.getSelectableData(c),e=d?d.obj:null,f=this._minLengthMet()&&this.menu.update(b),f||this.eventBus.before("cursorchange",e)?!1:(this.menu.setCursor(c),d?this.input.setInputValue(d.val):(this.input.resetInputValue(),this._updateHint()),this.eventBus.trigger("cursorchange",e),!0)},destroy:function(){this.input.destroy(),this.menu.destroy()}}),c}();!function(){"use strict";function e(b,c){b.each(function(){var b,d=a(this);(b=d.data(p.typeahead))&&c(b,d)})}function f(a,b){return a.clone().addClass(b.classes.hint).removeData().css(b.css.hint).css(l(a)).prop("readonly",!0).removeAttr("id name placeholder required").attr({autocomplete:"off",spellcheck:"false",tabindex:-1})}function h(a,b){a.data(p.attrs,{dir:a.attr("dir"),autocomplete:a.attr("autocomplete"),spellcheck:a.attr("spellcheck"),style:a.attr("style")}),a.addClass(b.classes.input).attr({autocomplete:"off",spellcheck:!1});try{!a.attr("dir")&&a.attr("dir","auto")}catch(c){}return a}function l(a){return{backgroundAttachment:a.css("background-attachment"),backgroundClip:a.css("background-clip"),backgroundColor:a.css("background-color"),backgroundImage:a.css("background-image"),backgroundOrigin:a.css("background-origin"),backgroundPosition:a.css("background-position"),backgroundRepeat:a.css("background-repeat"),backgroundSize:a.css("background-size")}}function m(a){var c,d;c=a.data(p.www),d=a.parent().filter(c.selectors.wrapper),b.each(a.data(p.attrs),function(c,d){b.isUndefined(c)?a.removeAttr(d):a.attr(d,c)}),a.removeData(p.typeahead).removeData(p.www).removeData(p.attr).removeClass(c.classes.input),d.length&&(a.detach().insertAfter(d),d.remove())}function n(c){var d,e;return d=b.isJQuery(c)||b.isElement(c),e=d?a(c).first():[],e.length?e:null}var o,p,q;o=a.fn.typeahead,p={www:"tt-www",attrs:"tt-attrs",typeahead:"tt-typeahead"},q={initialize:function(e,l){function m(){var c,m,q,r,s,t,u,v,w,x,y;b.each(l,function(a){a.highlight=!!e.highlight}),c=a(this),m=a(o.html.wrapper),q=n(e.hint),r=n(e.menu),s=e.hint!==!1&&!q,t=e.menu!==!1&&!r,s&&(q=f(c,o)),t&&(r=a(o.html.menu).css(o.css.menu)),q&&q.val(""),c=h(c,o),(s||t)&&(m.css(o.css.wrapper),c.css(s?o.css.input:o.css.inputWithNoHint),c.wrap(m).parent().prepend(s?q:null).append(t?r:null)),y=t?j:i,u=new d({el:c}),v=new g({hint:q,input:c},o),w=new y({node:r,datasets:l},o),x=new k({input:v,menu:w,eventBus:u,minLength:e.minLength},o),c.data(p.www,o),c.data(p.typeahead,x)}var o;return l=b.isArray(l)?l:[].slice.call(arguments,1),e=e||{},o=c(e.classNames),this.each(m)},isEnabled:function(){var a;return e(this.first(),function(b){a=b.isEnabled()}),a},enable:function(){return e(this,function(a){a.enable()}),this},disable:function(){return e(this,function(a){a.disable()}),this},isActive:function(){var a;return e(this.first(),function(b){a=b.isActive()}),a},activate:function(){return e(this,function(a){a.activate()}),this},deactivate:function(){return e(this,function(a){a.deactivate()}),this},isOpen:function(){var a;return e(this.first(),function(b){a=b.isOpen()}),a},open:function(){return e(this,function(a){a.open()}),this},close:function(){return e(this,function(a){a.close()}),this},select:function(b){var c=!1,d=a(b);return e(this.first(),function(a){c=a.select(d)}),c},autocomplete:function(b){var c=!1,d=a(b);return e(this.first(),function(a){c=a.autocomplete(d)}),c},moveCursor:function(a){var b=!1;return e(this.first(),function(c){b=c.moveCursor(a)}),b},val:function(a){var b;return arguments.length?(e(this,function(b){b.setVal(a)}),this):(e(this.first(),function(a){b=a.getVal()}),b)},destroy:function(){return e(this,function(a,b){m(b),a.destroy()}),this}},a.fn.typeahead=function(a){return q[a]?q[a].apply(this,[].slice.call(arguments,1)):q.initialize.apply(this,arguments)},a.fn.typeahead.noConflict=function(){return a.fn.typeahead=o,this}}()});</script>
    <script>require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var app_1 = require('../internal/app');
var rectangle_1 = require('../util/rectangle');
var audio_1 = require('../system/audio');
var json_1 = require('../internal/util/json');
var xml_1 = require('../internal/util/xml');
var internal_1 = require('../internal/internal');
var environment_1 = require('./environment');
var transition_1 = require('./transition');
var DEFAULT_SILENCE_DETECTION_THRESHOLD = 5;
var DEFAULT_SILENCE_DETECTION_PERIOD = 1000;
/**
 * The App Class provides you methods to get and set application-related
 * functionalities.
 *
 * ### Basic Usage
 *
 * ```javascript
 * var xjs = require('xjs');
 * var App = new xjs.App();
 *
 * App.getFrameTime().then(function(frametime) {
 *   window.frametime = frametime;
 * });
 * ```
 */
var App = (function () {
    function App() {
    }
    /**
     * return: Promise<number>
     *
     * Gets application's frame time (duration per frame in 100ns unit)
     *
     * #### Usage
     *
     * ```javascript
     * App.getFrameTime().then(function(res) {
     *   var frameTime = res;
     * });
     * ```
     */
    App.prototype.getFrametime = function () {
        return new Promise(function (resolve) {
            app_1.App.get('frametime').then(function (val) {
                resolve(Number(val));
            });
        });
    };
    /**
     * return: Promise<Rectangle>
     *
     * Gets application default output resolution.
     *
     * See also: {@link #util/Rectangle Util/Rectangle}
     *
     * #### Usage
     *
     * ```javascript
     * App.getResolution().then(function(res) {
     *   var height = res.getHeight();
     *   var width = res.getWidth();
     * });
     * ```
     */
    App.prototype.getResolution = function () {
        return new Promise(function (resolve) {
            app_1.App.get('resolution').then(function (val) {
                var dimensions = val.split(",");
                resolve(rectangle_1.Rectangle.fromDimensions(parseInt(dimensions[0]), parseInt(dimensions[1])));
            });
        });
    };
    /**
     * return: Promise<Rectangle>
     *
     * Gets application viewport display resolution
     *
     * See also: {@link #util/Rectangle Util/Rectangle}
     *
     * #### Usage
     *
     * ```javascript
     * App.getViewport().then(function(res) {
     *   var height = res.getHeight();
     *   var width = res.getWidth();
     * });
     * ```
     */
    App.prototype.getViewport = function () {
        return new Promise(function (resolve) {
            app_1.App.get('viewport').then(function (val) {
                var dimensions = val.split(",");
                resolve(rectangle_1.Rectangle.fromDimensions(parseInt(dimensions[0]), parseInt(dimensions[1])));
            });
        });
    };
    /**
     * return: Promise<string>
     *
     * Refers to XSplit Broadcaster DLL file version number
     *
     * #### Usage
     *
     * ```javascript
     * App.getVersion().then(function(res) {
     *   var version = res;
     * });
     * ```
     */
    App.prototype.getVersion = function () {
        return new Promise(function (resolve) {
            resolve(app_1.App.get('version'));
        });
    };
    /**
     * return: Promise<number>
     *
     * Gets the total number of frames rendered
     *
     * #### Usage
     *
     * ```javascript
     * App.getFramesRendered().then(function(res) {
     *   var framesrendered = res;
     * });
     * ```
     */
    App.prototype.getFramesRendered = function () {
        return new Promise(function (resolve) {
            app_1.App.get('framesrendered').then(function (val) {
                resolve(Number(val));
            });
        });
    };
    // Audio Services
    /**
     * return: Promise<AudioDevice[]>
     *
     * Gets the primary microphone device used in the application
     *
     * See also: {@link #system/AudioDevice System/AudioDevice}
     *
     * ### Usage
     *
     * ```javascript
     * App.getPrimaryMic().then(function(audioDevice) {
     *   var primaryMic = audioDevice;
     * });
     * ```
     */
    App.prototype.getPrimaryMic = function () {
        return new Promise(function (resolve) {
            app_1.App.getAsList('microphonedev2').then(function (arr) {
                var audioDevices = arr.map(function (val) {
                    return audio_1.AudioDevice.parse(val);
                });
                if (audioDevices.length && audioDevices.length > 0) {
                    resolve(audioDevices[0]);
                }
                else {
                    resolve(new audio_1.AudioDevice({ id: "empty" }));
                }
            });
        });
    };
    /**
     * return: Promise<AudioDevice[]>
     *
     * Gets the primary speaker/audio render device used in the application
     *
     * See also: {@link #system/AudioDevice System/AudioDevice}
     *
     * ### Usage
     *
     * ```javascript
     * App.getPrimarySpeaker().then(function(audioDevice) {
     *   var primarySpeaker = audioDevice;
     * });
     * ```
     */
    App.prototype.getPrimarySpeaker = function () {
        return new Promise(function (resolve) {
            app_1.App.getAsList('microphonedev2').then(function (arr) {
                var audioDevices = arr.map(function (val) {
                    return audio_1.AudioDevice.parse(val);
                });
                if (audioDevices.length && audioDevices.length > 1) {
                    resolve(audioDevices[1]);
                }
                else {
                    resolve(new audio_1.AudioDevice({ id: "empty" }));
                }
            });
        });
    };
    /**
     * param: (device: AudioDevice)
     * ```
     * return: Promise<boolean>
     * ```
     *
     * Sets the primary microphone device to be used in the application
     *
     * See also: {@link #system/AudioDevice System/AudioDevice}
     *
     * ### Usage
     *
     * ```javascript
     * App.setPrimaryMic(device).then(function(val) {
     *   var isSet = val;
     * });
     * ```
     */
    App.prototype.setPrimaryMic = function (device) {
        return new Promise(function (resolve) {
            app_1.App.getAsList('microphonedev2').then(function (arr) {
                var audioDevices = arr.map(function (val) {
                    return audio_1.AudioDevice.parse(val);
                });
                audioDevices[0] = device;
                var dev = '';
                if (Array.isArray(audioDevices)) {
                    for (var i = 0; i < audioDevices.length; ++i) {
                        dev += audioDevices[i].toString();
                    }
                }
                dev = '<devices>' + dev + '</devices>';
                app_1.App.set('microphonedev2', dev).then(function (setVal) {
                    resolve(setVal);
                });
            });
        });
    };
    /**
     * param: (device: AudioDevice)
     * ```
     * return: Promise<boolean>
     * ```
     *
     * Sets the primary speaker/audio render device to be used in the application
     *
     * See also: {@link #system/AudioDevice System/AudioDevice}
     *
     * ### Usage
     *
     * ```javascript
     * App.setPrimarySpeaker(device).then(function(val) {
     *   var isSet = val;
     * });
     * ```
     */
    App.prototype.setPrimarySpeaker = function (device) {
        return new Promise(function (resolve) {
            app_1.App.getAsList('microphonedev2').then(function (arr) {
                var audioDevices = arr.map(function (val) {
                    return audio_1.AudioDevice.parse(val);
                });
                audioDevices[1] = device;
                var dev = '';
                if (Array.isArray(audioDevices)) {
                    for (var i = 0; i < audioDevices.length; ++i) {
                        dev += audioDevices[i].toString();
                    }
                }
                dev = '<devices>' + dev + '</devices>';
                app_1.App.set('microphonedev2', dev).then(function (setVal) {
                    resolve(setVal);
                });
            });
        });
    };
    /**
     * return: Promise<boolean>
     *
     * Gets whether silence detection is enabled
     *
     * ### Usage
     *
     * ```javascript
     * App.isSilenceDetectionEnabled().then(function(val) {
     *   var isEnabled = val;
     * });
     * ```
     */
    App.prototype.isSilenceDetectionEnabled = function () {
        return new Promise(function (resolve) {
            app_1.App.get('microphonegain').then(function (val) {
                var micGainObj = json_1.JSON.parse(val);
                resolve(micGainObj['enable'] == '1');
            });
        });
    };
    /**
     * param: (enabled: boolean)
     * ```
     * return: Promise<boolean>
     * ```
     *
     * Enables or disables silence detection
     *
     * ### Usage
     *
     * ```javascript
     * App.enableSilenceDetection(enabled).then(function(val) {
     *   var isSet = val;
     * });
     * ```
     */
    App.prototype.enableSilenceDetection = function (enabled) {
        return new Promise(function (resolve) {
            app_1.App.get('microphonegain').then(function (val) {
                var silenceDetectionObj = json_1.JSON.parse(decodeURIComponent(val));
                silenceDetectionObj['enable'] = (enabled ? '1' : '0');
                app_1.App.set('microphonegain', xml_1.XML.parseJSON(silenceDetectionObj).toString())
                    .then(function (setVal) {
                    resolve(setVal);
                });
            });
        });
    };
    /**
     * return: Promise<number>
     *
     * Gets silence detection period,
     * the length of time after voice detection before silence is again detected
     *
     * ### Usage
     *
     * ```javascript
     * App.getSilenceDetectionPeriod().then(function(val) {
     *   var silenceDetectionPeriod = val;
     * });
     * ```
     */
    App.prototype.getSilenceDetectionPeriod = function () {
        return new Promise(function (resolve) {
            app_1.App.get('microphonegain').then(function (val) {
                var micGainObj = json_1.JSON.parse(val);
                resolve(micGainObj['latency'] !== undefined ?
                    Number(micGainObj['latency']) : DEFAULT_SILENCE_DETECTION_PERIOD);
            });
        });
    };
    /**
     * param: (sdPeriod: number)
     * ```
     * return: Promise<boolean>
     * ```
     *
     * Sets silence detection period (0-60000 ms),
     * the length of time after voice detection before silence is again detected
     *
     * ### Usage
     *
     * ```javascript
     * App.setSilenceDetectionPeriod(sdPeriod).then(function(val) {
     *   var isSet = val;
     * });
     * ```
     */
    App.prototype.setSilenceDetectionPeriod = function (sdPeriod) {
        return new Promise(function (resolve, reject) {
            if (typeof sdPeriod !== 'number') {
                reject(Error('Silence detection period must be a number'));
            }
            else if (sdPeriod % 1 != 0) {
                reject(Error('Silence detection period must be an integer'));
            }
            else if (sdPeriod < 0 || sdPeriod > 60000) {
                reject(Error('Silence detection must be in the range 0-60000.'));
            }
            app_1.App.get('microphonegain').then(function (val) {
                var silenceDetectionObj = json_1.JSON.parse(decodeURIComponent(val));
                silenceDetectionObj['latency'] = (sdPeriod.toString());
                app_1.App.set('microphonegain', xml_1.XML.parseJSON(silenceDetectionObj).toString())
                    .then(function (setVal) {
                    resolve(setVal);
                });
            });
        });
    };
    /**
     * return: Promise<number>
     *
     * Gets silence detection threshold/silence amplitude
     *
     * ### Usage
     *
     * ```javascript
     * App.getSilenceDetectionThreshold().then(function(val) {
     *   var silenceDetectionTfhreshold = val;
     * });
     * ```
     */
    App.prototype.getSilenceDetectionThreshold = function () {
        return new Promise(function (resolve) {
            app_1.App.get('microphonegain').then(function (val) {
                var micGainObj = json_1.JSON.parse(val);
                resolve(micGainObj['gain'] !== undefined ?
                    Number(micGainObj['gain']) : DEFAULT_SILENCE_DETECTION_THRESHOLD);
            });
        });
    };
    /**
     * param: (sdThreshold: number)
     * ```
     * return: Promise<boolean>
     * ```
     *
     * Sets silence detection threshold/silence amplitude (values from 0-128)
     *
     * ### Usage
     *
     * ```javascript
     * App.setSilenceDetectionThreshold(sdThreshold).then(function(val) {
     *   var isSet = val;
     * });
     * ```
     */
    App.prototype.setSilenceDetectionThreshold = function (sdThreshold) {
        return new Promise(function (resolve, reject) {
            if (typeof sdThreshold !== 'number') {
                reject(Error('Silence detection threshold must be a number'));
            }
            else if (sdThreshold % 1 != 0) {
                reject(Error('Silence detection threshold must be an integer'));
            }
            else if (sdThreshold < 0 || sdThreshold > 128) {
                reject(Error('Silence detection threshold must be in the range 0-128.'));
            }
            app_1.App.get('microphonegain').then(function (val) {
                var silenceDetectionObj = json_1.JSON.parse(decodeURIComponent(val));
                silenceDetectionObj['gain'] = (sdThreshold.toString());
                app_1.App.set('microphonegain', xml_1.XML.parseJSON(silenceDetectionObj).toString())
                    .then(function (setVal) {
                    resolve(setVal);
                });
            });
        });
    };
    /**
     * param: (url: string [, width: number = 300 [, height: number = 300 [, flags: number [, title: string ]]]])
     *
     * Creates a persistent modal dialog.
     * This method is not available for source
     *
     * #### Usage
     *
     * ```javascript
     * // you may use the following:
     * //     * App.BORDER_ENABLE (1)
     * //     * App.BORDER_ENABLE_CAPTION (2)
     * //     * App.BORDER_ENABLE_SIZING (4)
     * //     * App.BORDER_ENABLE_MINIMIZE (8)
     * //     * App.BORDER_ENABLE_MAXIMIZE (16)
     * App.newDialog(url, width, height, flags, title);
     * ```
     */
    App.prototype.newDialog = function (url, width, height, flags, title) {
        if (width === void 0) { width = 300; }
        if (height === void 0) { height = 300; }
        if (environment_1.Environment.isSourcePlugin()) {
            throw new TypeError('function is not available for source');
        }
        else if (url !== undefined && url !== '') {
            var params = ['NewDialog', url, '', width + ',' + height];
            for (var i = 3; i < arguments.length; i++) {
                if (arguments[i] !== undefined)
                    params.push(String(arguments[i]));
            }
            internal_1.exec.apply(this, params);
        }
        else {
            throw new Error('URL parameter expected');
        }
    };
    /**
     * param: (url: string [, width: number = 300 [, height: number = 300]])
     *
     * Creates a dialog that automatically closes on outside click
     *
     * #### Usage
     *
     * ```javascript
     * App.newAutoDialog(url, width, height);
     * ```
     */
    App.prototype.newAutoDialog = function (url, width, height) {
        if (width === void 0) { width = 300; }
        if (height === void 0) { height = 300; }
        if (environment_1.Environment.isSourcePlugin()) {
            throw new TypeError('function is not available for source');
        }
        else if (url !== undefined && url !== '') {
            internal_1.exec('NewAutoDialog', url, width + ',' + height);
        }
        else {
            throw new Error('URL parameter expected');
        }
    };
    /**
     * Close a created dialog
     */
    App.prototype.closeDialog = function () {
        if (environment_1.Environment.isSourcePlugin()) {
            throw new TypeError('function is not available for source');
        }
        else {
            internal_1.exec('CloseDialog');
        }
    };
    // Transition Services
    /**
     * return: Promise<Transition>
     *
     * Gets the transition for scene changes
     *
     * See also: {@link #core/Transition Core/Transition}
     *
     * #### Usage
     *
     * ```javascript
     * App.getTransition().then(function(res) {
     *   var transitionid = res;
     * });
     * ```
     */
    App.prototype.getTransition = function () {
        return new Promise(function (resolve) {
            app_1.App.get('transitionid').then(function (val) {
                if (val === '') {
                    resolve(transition_1.Transition.NONE);
                }
                else {
                    resolve(transition_1.Transition[val.toUpperCase()]);
                }
            });
        });
    };
    /**
     * param: (transition: Transition)
     * ```
     * return: Promise<boolean>
     * ```
     *
     * Sets the transition for scene changes
     *
     * See also: {@link #core/Transition Core/Transition}
     *
     * #### Usage
     *
     * ```javascript
     * var xjs = require('xjs'),
     *     Transition = xjs.Transition,
     *     App = new xjs.App();

     * App.setTransition(Transition.CLOCK).then(function(val) {
     *  var isSet = val;
     * });
     * ```
     */
    App.prototype.setTransition = function (transition) {
        return new Promise(function (resolve) {
            app_1.App.set('transitionid', transition.toString()).then(function (val) {
                resolve(val);
            });
        });
    };
    /**
     * return: Promise<number>
     *
     * Gets the scene transition duration in milliseconds
     *
     * #### Usage
     *
     * ```javascript
     * App.getTransitionTime().then(function(res) {
     *   var transitiontime = res;
     * });
     * ```
     */
    App.prototype.getTransitionTime = function () {
        return new Promise(function (resolve) {
            app_1.App.get('transitiontime').then(function (val) {
                resolve(Number(val));
            });
        });
    };
    /**
     * param: (time: number)
     * ```
     * return: Promise<boolean>
     * ```
     *
     * Sets the scene transition duration in milliseconds
     *
     * #### Usage
     *
     * ```javascript
     * App.setTransitionTime(time).then(function(val) {
     *  var isSet = val;
     * });
     * ```
     */
    App.prototype.setTransitionTime = function (time) {
        return new Promise(function (resolve) {
            app_1.App.set('transitiontime', time.toString()).then(function (val) {
                resolve(val);
            });
        });
    };
    // Dialog Services
    App.BORDER_ENABLE = 1;
    App.BORDER_ENABLE_CAPTION = 2;
    App.BORDER_ENABLE_SIZING = 4;
    App.BORDER_ENABLE_MINIMIZE = 8;
    App.BORDER_ENABLE_MAXIMIZE = 16;
    return App;
})();
exports.App = App;
},{"../internal/app":16,"../internal/internal":19,"../internal/util/json":21,"../internal/util/xml":23,"../system/audio":24,"../util/rectangle":33,"./environment":2,"./transition":15}],2:[function(require,module,exports){
/**
 * This class allows detection of the context in which the HTML is located.
 */
var Environment = (function () {
    function Environment() {
    }
    /**
     * This method is only used internally.
     */
    Environment.initialize = function () {
        if (Environment._initialized) {
            return;
        }
        Environment._isSourcePlugin = (window.external &&
            window.external['GetConfiguration'] !== undefined);
        Environment._isSourceConfig = (window.external &&
            window.external['GetConfiguration'] === undefined &&
            window.external['GetViewId'] !== undefined &&
            window.external['GetViewId']() !== undefined);
        Environment._isExtension = (window.external &&
            window.external['GetConfiguration'] === undefined &&
            window.external['GetViewId'] !== undefined &&
            window.external['GetViewId']() === undefined);
        Environment._initialized = true;
    };
    /**
     * return: boolean
     *
     * Determines if this HTML is running as a source.
     */
    Environment.isSourcePlugin = function () {
        return Environment._isSourcePlugin;
    };
    /**
     * return: boolean
     * Determines if this HTML is running within the source configuration window.
     */
    Environment.isSourceConfig = function () {
        return Environment._isSourceConfig;
    };
    /**
     * return: boolean
     *
     * Determines if this HTML is running as an extension plugin.
     */
    Environment.isExtension = function () {
        return Environment._isExtension;
    };
    return Environment;
})();
exports.Environment = Environment;
Environment.initialize();
},{}],3:[function(require,module,exports){
/// <reference path="../../../defs/es6-promise.d.ts" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var mixin_1 = require('../../internal/util/mixin');
var item_1 = require('../../internal/item');
var iaudio_1 = require('./iaudio');
var item_2 = require('./item');
var environment_1 = require('../environment');
/**
 * The AudioItem class represents an audio device that has been added
 * to the stage.
 */
var AudioItem = (function (_super) {
    __extends(AudioItem, _super);
    function AudioItem() {
        _super.apply(this, arguments);
    }
    AudioItem.prototype.isSilenceDetectionEnabled = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:AudioGainEnable', slot).then(function (val) {
                resolve(val === '1');
            });
        });
    };
    AudioItem.prototype.setSilenceDetectionEnabled = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isSourcePlugin()) {
                reject(Error('Source plugins cannot update audio sources properties'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:AudioGainEnable', (value ? '1' : '0'), slot)
                    .then(function (res) {
                    if (!res) {
                        reject(Error('Item set property failed'));
                    }
                    else {
                        resolve(_this);
                    }
                });
            }
        });
    };
    AudioItem.prototype.getSilenceThreshold = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:AudioGain', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    AudioItem.prototype.setSilenceThreshold = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isSourcePlugin()) {
                reject(Error('Source plugins cannot update audio sources properties'));
            }
            else if (typeof value !== 'number') {
                reject(Error('Only numbers are acceptable values for threshold'));
            }
            else if (value % 1 !== 0 || value < 0 || value > 128) {
                reject(Error('Only integers in the range 0-128 are acceptable for threshold'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:AudioGain', String(value), slot).then(function (res) {
                    if (!res) {
                        reject(Error('Item set property failed'));
                    }
                    else {
                        resolve(_this);
                    }
                });
            }
        });
    };
    AudioItem.prototype.getSilencePeriod = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:AudioGainLatency', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    AudioItem.prototype.setSilencePeriod = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isSourcePlugin()) {
                reject(Error('Source plugins cannot update audio sources properties'));
            }
            else if (typeof value !== 'number') {
                reject(Error('Only numbers are acceptable values for period'));
            }
            else if (value % 1 !== 0 || value < 0 || value > 10000) {
                reject(Error('Only integers in the range 0-10000 are acceptable for period'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:AudioGainLatency', String(value), slot).then(function (res) {
                    if (!res) {
                        reject(Error('Item set property failed'));
                    }
                    else {
                        resolve(_this);
                    }
                });
            }
        });
    };
    return AudioItem;
})(item_2.Item);
exports.AudioItem = AudioItem;
mixin_1.applyMixins(item_2.Item, [iaudio_1.ItemAudio]);
},{"../../internal/item":20,"../../internal/util/mixin":22,"../environment":2,"./iaudio":7,"./item":12}],4:[function(require,module,exports){
/// <reference path="../../../defs/es6-promise.d.ts" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var mixin_1 = require('../../internal/util/mixin');
var item_1 = require('../../internal/item');
var ilayout_1 = require('./ilayout');
var icolor_1 = require('./icolor');
var ichroma_1 = require('./ichroma');
var itransition_1 = require('./itransition');
var item_2 = require('./item');
/**
 * The CameraItem Class provides methods specifically used for camera items and
 * also methods that are shared between Item Classes. The
 * {@link #core/Scene Scene} class' getItems method would automatically return a
 * CameraItem object if there's a camera item on the specified scene.
 *
 * ### Basic Usage
 *
 * ```javascript
 * var XJS = require('xjs');
 *
 * XJS.Scene.getActiveScene().then(function(scene) {
 *   scene.getItems().then(function(items) {
 *     for (var i in items) {
 *       if (items[i] instanceof XJS.CameraItem) {
 *         // Manipulate your camera item here
 *         items[i].getDeviceId().then(function(id) {
 *           // Do something with the id
 *         });
 *       }
 *     }
 *   });
 * });
 * ```
 */
var CameraItem = (function (_super) {
    __extends(CameraItem, _super);
    function CameraItem() {
        _super.apply(this, arguments);
    }
    /**
     * return: Promise<string>
     *
     * Gets the device ID of the underlying camera deviec.
     */
    CameraItem.prototype.getDeviceId = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:item', slot).then(function (val) {
                resolve(val);
            });
        });
    };
    // special color options pinning
    /**
     * param: value<boolean>
     *
     * Set this to true to share color settings across all instances of this
     * camera device on the stage.
     */
    CameraItem.prototype.setColorOptionsPinned = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.set('prop:cc_pin', value ? '1' : '0', slot).then(function () {
                resolve(_this);
            });
        });
    };
    /**
     * return: Promise<boolean>
     *
     * Checks whether color settings are shared across all instances of
     * this camera device on the stage.
     */
    CameraItem.prototype.getColorOptionsPinned = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:cc_pin', slot).then(function (val) {
                resolve(val === '1' ? true : false);
            });
        });
    };
    // special chroma options pinning
    /**
     * param: (value: boolean)
     *
     * Set this to true to share chroma keying settings across all instances of
     * this camera device on the stage.
     */
    CameraItem.prototype.setKeyingOptionsPinned = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.set('prop:key_pin', value ? '1' : '0', slot).then(function () {
                resolve(_this);
            });
        });
    };
    /**
     * return: Promise<boolean>
     *
     * Checks whether chroma keying settings are shared across all instances of
     * this camera device on the stage.
     */
    CameraItem.prototype.getKeyingOptionsPinned = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_pin', slot).then(function (val) {
                resolve(val === '1' ? true : false);
            });
        });
    };
    return CameraItem;
})(item_2.Item);
exports.CameraItem = CameraItem;
mixin_1.applyMixins(CameraItem, [ilayout_1.ItemLayout, icolor_1.ItemColor, ichroma_1.ItemChroma, itransition_1.ItemTransition]);
},{"../../internal/item":20,"../../internal/util/mixin":22,"./ichroma":8,"./icolor":9,"./ilayout":11,"./item":12,"./itransition":13}],5:[function(require,module,exports){
/// <reference path="../../../defs/es6-promise.d.ts" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var mixin_1 = require('../../internal/util/mixin');
var item_1 = require('../../internal/item');
var ilayout_1 = require('./ilayout');
var icolor_1 = require('./icolor');
var ichroma_1 = require('./ichroma');
var itransition_1 = require('./itransition');
var item_2 = require('./item');
var json_1 = require('../../internal/util/json');
var xml_1 = require('../../internal/util/xml');
var item_3 = require('./item');
var environment_1 = require('../environment');
/**
 * The GameItem Class provides methods specifically used for game items and
 * also methods that is shared between Item Classes. The
 * {@link #core/Scene Scene} class' getItems method would automatically return a
 * GameItem object if there's a game item on the specified scene.
 *
 * ### Basic Usage
 *
 * ```javascript
 * var XJS = require('xjs');
 *
 * XJS.Scene.getActiveScene().then(function(scene) {
 *   scene.getItems().then(function(items) {
 *     for (var i in items) {
 *       if (items[i] instanceof XJS.GameItem) {
 *         // Manipulate your game item here
 *         items[i].setOfflineImage(path); // just an example here
 *       }
 *     }
 *   });
 * });
 * ```
 */
var GameItem = (function (_super) {
    __extends(GameItem, _super);
    function GameItem() {
        _super.apply(this, arguments);
    }
    /**
     * return: Promise<boolean>
     *
     * Check if Game Special Optimization is currently enabled or not
     */
    GameItem.prototype.isSpecialOptimizationEnabled = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('GameCapSurfSharing').then(function (res) {
                resolve(res === '1');
            });
        });
    };
    /**
     * param: Promise<boolean>
     *
     * Set Game Special Optimization to on or off
     */
    GameItem.prototype.setSpecialOptimizationEnabled = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.set('GameCapSurfSharing', (value ? '1' : '0'), slot).then(function () {
                resolve(_this);
            });
        });
    };
    /**
     * return: Promise<boolean>
     *
     * Check if Show Mouse is currently enabled or not
     */
    GameItem.prototype.isShowMouseEnabled = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('GameCapShowMouse').then(function (res) {
                resolve(res === '1');
            });
        });
    };
    /**
     * param: value<boolean>
     *
     * Set Show Mouse in game to on or off
     */
    GameItem.prototype.setShowMouseEnabled = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.set('GameCapShowMouse', (value ? '1' : '0'), slot).then(function () {
                resolve(_this);
            });
        });
    };
    /**
     * param: path<string>
     *
     * Set the offline image of a game source
     */
    GameItem.prototype.setOfflineImage = function (path) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this._type !== item_3.ItemTypes.GAMESOURCE) {
                reject(Error('Current item should be a game source'));
            }
            else if (environment_1.Environment.isSourcePlugin()) {
                reject(Error('Source plugins cannot update offline images of other sources'));
            }
            else if (!(_this._value instanceof xml_1.XML)) {
                _this.getValue().then(function () {
                    _this.setOfflineImage(path).then(function (itemObj) {
                        resolve(itemObj);
                    });
                });
            }
            else {
                var regExp = new RegExp('^(([A-Z|a-z]:\\\\[^*|"<>?\n]*)|(\\\\\\\\.*?' +
                    '\\\\.*)|([A-Za-z]+\\\\[^*|"<>?\\n]*))\.(png|gif|jpg|jpeg|tif)$');
                if (regExp.test(path) || path === '') {
                    var valueObj = json_1.JSON.parse(_this._value.toString());
                    valueObj['replace'] = path;
                    _this.setValue(xml_1.XML.parseJSON(valueObj)).then(function () {
                        resolve(_this);
                    });
                }
            }
        });
    };
    /**
     * return: Promise<string>
     *
     * Get the offline image of a game source
     */
    GameItem.prototype.getOfflineImage = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this._type !== item_3.ItemTypes.GAMESOURCE) {
                reject(Error('Current item should be a game source'));
            }
            else {
                _this.getValue().then(function () {
                    var valueObj = json_1.JSON.parse(_this._value.toString());
                    resolve(valueObj['replace'] ? valueObj['replace'] : '');
                });
            }
        });
    };
    return GameItem;
})(item_2.Item);
exports.GameItem = GameItem;
mixin_1.applyMixins(GameItem, [ilayout_1.ItemLayout, icolor_1.ItemColor, ichroma_1.ItemChroma, itransition_1.ItemTransition]);
},{"../../internal/item":20,"../../internal/util/json":21,"../../internal/util/mixin":22,"../../internal/util/xml":23,"../environment":2,"./ichroma":8,"./icolor":9,"./ilayout":11,"./item":12,"./itransition":13}],6:[function(require,module,exports){
/// <reference path="../../../defs/es6-promise.d.ts" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var mixin_1 = require('../../internal/util/mixin');
var item_1 = require('../../internal/item');
var ilayout_1 = require('./ilayout');
var icolor_1 = require('./icolor');
var ichroma_1 = require('./ichroma');
var itransition_1 = require('./itransition');
var iconfig_1 = require('./iconfig');
var item_2 = require('./item');
var HTMLItem = (function (_super) {
    __extends(HTMLItem, _super);
    function HTMLItem() {
        _super.apply(this, arguments);
    }
    /**
     * return: Promise<string>
     *
     * Gets the URL of this webpage source.
     */
    HTMLItem.prototype.getURL = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:item', slot).then(function (url) {
                resolve(url);
            });
        });
    };
    /**
     * param: value<string>
     *
     * Sets the URL of this webpage source.
     */
    HTMLItem.prototype.setURL = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.set('prop:item', value, slot).then(function (code) {
                if (code) {
                    resolve(_this);
                }
                else {
                    reject('Invalid value');
                }
            });
        });
    };
    return HTMLItem;
})(item_2.Item);
exports.HTMLItem = HTMLItem;
mixin_1.applyMixins(HTMLItem, [ilayout_1.ItemLayout, icolor_1.ItemColor, ichroma_1.ItemChroma, itransition_1.ItemTransition, iconfig_1.ItemConfigurable]);
},{"../../internal/item":20,"../../internal/util/mixin":22,"./ichroma":8,"./icolor":9,"./iconfig":10,"./ilayout":11,"./item":12,"./itransition":13}],7:[function(require,module,exports){
/// <reference path="../../../defs/es6-promise.d.ts" />
var item_1 = require('../../internal/item');
var environment_1 = require('../environment');
var ItemAudio = (function () {
    function ItemAudio() {
    }
    ItemAudio.prototype.getVolume = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:volume', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemAudio.prototype.setVolume = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isSourcePlugin()) {
                reject(Error('Source plugins cannot update audio source properties.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                value = value < 0 ? 0 : value > 100 ? 100 : value;
                item_1.Item.set('prop:volume', String(value), slot).then(function (res) {
                    if (!res) {
                        reject(Error('Item set property failed'));
                    }
                    else {
                        resolve(_this);
                    }
                });
            }
        });
    };
    ItemAudio.prototype.isMute = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:mute', slot).then(function (val) {
                resolve(val === '1');
            });
        });
    };
    ItemAudio.prototype.setMute = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isSourcePlugin()) {
                reject(Error('Source plugins cannot update audio sources properties'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:mute', (value ? '1' : '0'), slot).then(function (res) {
                    if (!res) {
                        reject(Error('Item set property failed'));
                    }
                    else {
                        resolve(_this);
                    }
                });
            }
        });
    };
    ItemAudio.prototype.getAudioOffset = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:AudioDelay', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemAudio.prototype.setAudioOffset = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isSourcePlugin()) {
                reject(Error('Source plugins cannot update audio sources properties'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:AudioDelay', String(value), slot).then(function (res) {
                    if (!res) {
                        reject(Error('Item set property failed'));
                    }
                    else {
                        resolve(_this);
                    }
                });
            }
        });
    };
    ItemAudio.prototype.isStreamOnlyEnabled = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:sounddev', slot).then(function (val) {
                resolve(val === '1');
            });
        });
    };
    ItemAudio.prototype.setStreamOnlyEnabled = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isSourcePlugin()) {
                reject(Error('Source plugins cannot update audio sources properties'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:sounddev', (value ? '1' : '0'), slot).then(function (res) {
                    if (!res) {
                        reject(Error('Item set property failed'));
                    }
                    else {
                        resolve(_this);
                    }
                });
            }
        });
    };
    return ItemAudio;
})();
exports.ItemAudio = ItemAudio;
},{"../../internal/item":20,"../environment":2}],8:[function(require,module,exports){
/// <reference path="../../../defs/es6-promise.d.ts" />
var item_1 = require('../../internal/item');
var color_1 = require('../../util/color');
(function (KeyingType) {
    KeyingType[KeyingType["LEGACY"] = 0] = "LEGACY";
    KeyingType[KeyingType["COLORKEY"] = 1] = "COLORKEY";
    KeyingType[KeyingType["RGBKEY"] = 2] = "RGBKEY"; // Chroma Key RGB Mode
})(exports.KeyingType || (exports.KeyingType = {}));
var KeyingType = exports.KeyingType;
(function (ChromaPrimaryColors) {
    ChromaPrimaryColors[ChromaPrimaryColors["RED"] = 0] = "RED";
    ChromaPrimaryColors[ChromaPrimaryColors["GREEN"] = 1] = "GREEN";
    ChromaPrimaryColors[ChromaPrimaryColors["BLUE"] = 2] = "BLUE";
})(exports.ChromaPrimaryColors || (exports.ChromaPrimaryColors = {}));
var ChromaPrimaryColors = exports.ChromaPrimaryColors;
(function (ChromaAntiAliasLevel) {
    ChromaAntiAliasLevel[ChromaAntiAliasLevel["NONE"] = 0] = "NONE";
    ChromaAntiAliasLevel[ChromaAntiAliasLevel["LOW"] = 1] = "LOW";
    ChromaAntiAliasLevel[ChromaAntiAliasLevel["HIGH"] = 2] = "HIGH";
})(exports.ChromaAntiAliasLevel || (exports.ChromaAntiAliasLevel = {}));
var ChromaAntiAliasLevel = exports.ChromaAntiAliasLevel;
var ItemChroma = (function () {
    function ItemChroma() {
    }
    ItemChroma.prototype.isChromaEnabled = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_chromakey', slot).then(function (val) {
                resolve(val === '1');
            });
        });
    };
    ItemChroma.prototype.setChromaEnabled = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof value !== 'boolean') {
                reject(TypeError('Parameter should be boolean.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:key_chromakey', (value ? '1' : '0'), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemChroma.prototype.getKeyingType = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_chromakeytype', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemChroma.prototype.setKeyingType = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof value !== 'number') {
                reject(TypeError('Use a KeyingType value as the parameter.'));
            }
            else if (value < 0 || value > 2) {
                reject(RangeError('Use a KeyingType value as the parameter.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:key_chromakeytype', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemChroma.prototype.getChromaAntiAliasLevel = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_antialiasing', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemChroma.prototype.setChromaAntiAliasLevel = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof value !== 'number') {
                reject(TypeError('Use a ChromaAntiAliasLevel value as the parameter.'));
            }
            else if (value < 0 || value > 2) {
                reject(RangeError('Use a ChromaAntiAliasLevel value as the parameter.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:key_antialiasing', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    // CHROMA LEGACY MODE FUNCTIONS
    ItemChroma.prototype.getChromaLegacyBrightness = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_chromabr', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemChroma.prototype.setChromaLegacyBrightness = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof value !== 'number') {
                reject(TypeError('Use an integer as the parameter.'));
            }
            else if (value < 0 || value > 255) {
                reject(RangeError('Valid value is an integer from 0-255.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:key_chromabr', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemChroma.prototype.getChromaLegacySaturation = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_chromasat', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemChroma.prototype.setChromaLegacySaturation = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof value !== 'number') {
                reject(TypeError('Use an integer as the parameter.'));
            }
            else if (value < 0 || value > 255) {
                reject(RangeError('Valid value is an integer from 0-255.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:key_chromasat', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemChroma.prototype.getChromaLegacyHue = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_chromahue', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemChroma.prototype.setChromaLegacyHue = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof value !== 'number') {
                reject(TypeError('Use an integer as the parameter.'));
            }
            else if (value < 0 || value > 180) {
                reject(RangeError('Valid value is an integer from 0-180.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:key_chromahue', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemChroma.prototype.getChromaLegacyThreshold = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_chromarang', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemChroma.prototype.setChromaLegacyThreshold = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof value !== 'number') {
                reject(TypeError('Use an integer as the parameter.'));
            }
            else if (value < 0 || value > 255) {
                reject(RangeError('Valid value is an integer from 0-255.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:key_chromarang', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemChroma.prototype.getChromaLegacyAlphaSmoothing = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_chromaranga', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemChroma.prototype.setChromaLegacyAlphaSmoothing = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof value !== 'number') {
                reject(TypeError('Use an integer as the parameter.'));
            }
            else if (value < 0 || value > 255) {
                reject(RangeError('Valid value is an integer from 0-255.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:key_chromaranga', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    // CHROMA RGB KEY FUNCTIONS
    ItemChroma.prototype.getChromaRGBKeyPrimaryColor = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_chromargbkeyprimary', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemChroma.prototype.setChromaRGBKeyPrimaryColor = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof value !== 'number') {
                reject(TypeError('Use a ChromaPrimaryColors value as the parameter.'));
            }
            else if (value < 0 || value > 2) {
                reject(RangeError('Use a ChromaPrimaryColors value as the parameter.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:key_chromargbkeyprimary', String(value), slot)
                    .then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemChroma.prototype.getChromaRGBKeyThreshold = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_chromargbkeythresh', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemChroma.prototype.setChromaRGBKeyThreshold = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof value !== 'number') {
                reject(TypeError('Use an integer as the parameter.'));
            }
            else if (value < 0 || value > 255) {
                reject(RangeError('Valid value is an integer from 0-255.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:key_chromargbkeythresh', String(value), slot)
                    .then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemChroma.prototype.getChromaRGBKeyExposure = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_chromargbkeybalance', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemChroma.prototype.setChromaRGBKeyExposure = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof value !== 'number') {
                reject(TypeError('Use an integer as the parameter.'));
            }
            else if (value < 0 || value > 255) {
                reject(RangeError('Valid value is an integer from 0-255.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:key_chromargbkeybalance', String(value), slot)
                    .then(function () {
                    resolve(_this);
                });
            }
        });
    };
    // CHROMA COLOR KEY FUNCTIONS
    ItemChroma.prototype.getChromaColorKeyThreshold = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_colorrang', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemChroma.prototype.setChromaColorKeyThreshold = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof value !== 'number') {
                reject(TypeError('Use an integer as the parameter.'));
            }
            else if (value < 0 || value > 255) {
                reject(RangeError('Valid value is an integer from 0-255.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:key_colorrang', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemChroma.prototype.getChromaColorKeyExposure = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_colorranga', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemChroma.prototype.setChromaColorKeyExposure = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof value !== 'number') {
                reject(TypeError('Use an integer as the parameter.'));
            }
            else if (value < 0 || value > 255) {
                reject(RangeError('Valid value is an integer from 0-255.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:key_colorranga', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemChroma.prototype.getChromaColorKeyColor = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:key_colorrgb', slot).then(function (val) {
                var color = color_1.Color.fromBGRString(val);
                resolve(color);
            });
        });
    };
    ItemChroma.prototype.setChromaColorKeyColor = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.set('prop:key_colorrgb', String(value.getIbgr()), slot).then(function () {
                resolve(_this);
            });
        });
    };
    return ItemChroma;
})();
exports.ItemChroma = ItemChroma;
},{"../../internal/item":20,"../../util/color":29}],9:[function(require,module,exports){
/// <reference path="../../../defs/es6-promise.d.ts" />
var item_1 = require('../../internal/item');
var color_1 = require('../../util/color');
var ItemColor = (function () {
    function ItemColor() {
    }
    ItemColor.prototype.getTransparency = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:alpha', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemColor.prototype.setTransparency = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (value < 0 || value > 255) {
                reject(RangeError('Transparency may only be in the range 0 to 255.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:alpha', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemColor.prototype.getBrightness = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:cc_brightness', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemColor.prototype.setBrightness = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (value < -100 || value > 100) {
                reject(RangeError('Brightness may only be in the range -100 to 100.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:cc_brightness', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemColor.prototype.getContrast = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:cc_contrast', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemColor.prototype.setContrast = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (value < -100 || value > 100) {
                reject(RangeError('Contrast may only be in the range -100 to 100.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:cc_contrast', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemColor.prototype.getHue = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:cc_hue', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemColor.prototype.setHue = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (value < -180 || value > 180) {
                reject(RangeError('Contrast may only be in the range -180 to 180.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:cc_hue', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemColor.prototype.getSaturation = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:cc_saturation', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemColor.prototype.setSaturation = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (value < -100 || value > 100) {
                reject(RangeError('Saturation may only be in the range -100 to 100'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:cc_saturation', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemColor.prototype.getBorderColor = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:border', slot).then(function (val) {
                var bgr = Number(val) - 0x80000000;
                var color = color_1.Color.fromBGRInt(bgr);
                resolve(color);
            });
        });
    };
    ItemColor.prototype.setBorderColor = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.set('prop:border', String(value.getIbgr() - 0x80000000), slot).then(function () {
                resolve(_this);
            });
        });
    };
    return ItemColor;
})();
exports.ItemColor = ItemColor;
},{"../../internal/item":20,"../../util/color":29}],10:[function(require,module,exports){
/// <reference path="../../../defs/es6-promise.d.ts" />
var item_1 = require('../../internal/item');
var global_1 = require('../../internal/global');
var internal_1 = require('../../internal/internal');
var environment_1 = require('../environment');
var ItemConfigurable = (function () {
    function ItemConfigurable() {
    }
    ItemConfigurable.prototype.loadConfig = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:BrowserConfiguration', slot).then(function (config) {
                var configObj = config === 'null' ? {} : JSON.parse(config);
                var persist = global_1.Global.getPersistentConfig();
                for (var key in persist) {
                    delete configObj[key];
                }
                resolve(configObj);
            });
        });
    };
    ItemConfigurable.prototype.saveConfig = function (configObj) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isSourcePlugin) {
                var slot = item_1.Item.attach(_this._id);
                // only allow direct saving for self
                if (slot === 0) {
                    // check for valid object
                    if ({}.toString.call(configObj) === '[object Object]') {
                        // add persisted configuration if available
                        // currently only top level merging is available
                        var persist = global_1.Global.getPersistentConfig();
                        for (var key in persist) {
                            configObj[key] = persist[key];
                        }
                        internal_1.exec('SetBrowserProperty', 'Configuration', JSON.stringify(configObj));
                        resolve(_this);
                    }
                    else {
                        reject(Error('Configuration object should be ' +
                            'in JSON format.'));
                    }
                }
                else {
                    reject(Error('Sources may only request other ' +
                        'sources to save a configuration. Consider ' +
                        'calling requestSaveConfig() on this Item ' +
                        'instance instead.'));
                }
            }
            else {
                reject(Error('Extensions and source configuration windows are ' +
                    'not allowed to directly save configuration objects. ' +
                    'Call requestSaveConfig() instead.'));
            }
        });
    };
    ItemConfigurable.prototype.requestSaveConfig = function (configObj) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            internal_1.exec('CallInner' + (slot === 0 ? '' : (slot + 1)), 'MessageSource', JSON.stringify({
                'request': 'saveConfig',
                'data': configObj
            }));
            resolve(_this);
        });
    };
    ItemConfigurable.prototype.applyConfig = function (configObj) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            internal_1.exec('CallInner' + (slot === 0 ? '' : (slot + 1)), 'MessageSource', JSON.stringify({
                'request': 'applyConfig',
                'data': configObj
            }));
            resolve(_this);
        });
    };
    return ItemConfigurable;
})();
exports.ItemConfigurable = ItemConfigurable;
},{"../../internal/global":17,"../../internal/internal":19,"../../internal/item":20,"../environment":2}],11:[function(require,module,exports){
/// <reference path="../../../defs/es6-promise.d.ts" />
var item_1 = require('../../internal/item');
var rectangle_1 = require('../../util/rectangle');
var ItemLayout = (function () {
    function ItemLayout() {
    }
    ItemLayout.prototype.isKeepAspectRatio = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:keep_ar', slot).then(function (val) {
                resolve(val === '1');
            });
        });
    };
    ItemLayout.prototype.setKeepAspectRatio = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.set('prop:keep_ar', value ? '1' : '0', slot).then(function () {
                resolve(_this);
            });
        });
    };
    ItemLayout.prototype.isPositionLocked = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:lockmove', slot).then(function (val) {
                resolve(val === '1');
            });
        });
    };
    ItemLayout.prototype.setPositionLocked = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.set('prop:lockmove', value ? '1' : '0', slot).then(function () {
                resolve(_this);
            });
        });
    };
    ItemLayout.prototype.isEnhancedResizeEnabled = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:mipmaps', slot).then(function (val) {
                resolve(val === '1');
            });
        });
    };
    ItemLayout.prototype.setEnhancedResizeEnabled = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.set('prop:mipmaps', value ? '1' : '0', slot).then(function () {
                resolve(_this);
            });
        });
    };
    ItemLayout.prototype.getPosition = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:pos', slot).then(function (val) {
                var _a = decodeURIComponent(val).split(','), left = _a[0], top = _a[1], right = _a[2], bottom = _a[3];
                _this.position = rectangle_1.Rectangle.fromCoordinates(Number(top), Number(left), Number(right), Number(bottom));
                resolve(_this.position);
            });
        });
    };
    ItemLayout.prototype.setPosition = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            _this.position = value;
            item_1.Item.set('prop:pos', value.toCoordinateString(), slot).then(function () {
                resolve(_this);
            });
        });
    };
    ItemLayout.prototype.getRotateY = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:rotate_y', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemLayout.prototype.setRotateY = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (value < -360 || value > 360) {
                reject(Error('Invalid value. Min: -360, Max: 360'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:rotate_y', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemLayout.prototype.getRotateX = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:rotate_x', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemLayout.prototype.setRotateX = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (value < -360 || value > 360) {
                reject(Error('Invalid value. Min: -360, Max: 360'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:rotate_x', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    ItemLayout.prototype.getRotateZ = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:rotate_z', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemLayout.prototype.setRotateZ = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (value < -360 || value > 360) {
                reject(Error('Invalid value. Min: -360, Max: 360'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:rotate_z', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    return ItemLayout;
})();
exports.ItemLayout = ItemLayout;
},{"../../internal/item":20,"../../util/rectangle":33}],12:[function(require,module,exports){
/// <reference path="../../../defs/es6-promise.d.ts" />
var mixin_1 = require('../../internal/util/mixin');
var item_1 = require('../../internal/item');
var environment_1 = require('../environment');
var json_1 = require('../../internal/util/json');
var xml_1 = require('../../internal/util/xml');
var scene_1 = require('../scene');
var ilayout_1 = require('./ilayout');
(function (ItemTypes) {
    ItemTypes[ItemTypes["UNDEFINED"] = 0] = "UNDEFINED";
    ItemTypes[ItemTypes["FILE"] = 1] = "FILE";
    ItemTypes[ItemTypes["LIVE"] = 2] = "LIVE";
    ItemTypes[ItemTypes["TEXT"] = 3] = "TEXT";
    ItemTypes[ItemTypes["BITMAP"] = 4] = "BITMAP";
    ItemTypes[ItemTypes["SCREEN"] = 5] = "SCREEN";
    ItemTypes[ItemTypes["FLASHFILE"] = 6] = "FLASHFILE";
    ItemTypes[ItemTypes["GAMESOURCE"] = 7] = "GAMESOURCE";
    ItemTypes[ItemTypes["HTML"] = 8] = "HTML";
})(exports.ItemTypes || (exports.ItemTypes = {}));
var ItemTypes = exports.ItemTypes;
/**
 * An Item represents an object that is used as a source on the stage.
 * Some possible sources are games, microphones, or a webpage.
 *
 * ### Basic Usage
 *
 * ```javascript
 * var xjs = require('xjs');
 * var Scene = xjs.Scene.getById(0);
 *
 * Scene.getItems().then(function(items) {
 *   if (items.length === 0) return;
 *
 *   // There's a valid item, let's use that
 *   var item = items[items.length - 1];
 *   return item.setCustomName('ItemTesting');
 * }).then(function(item) {
 *   // Do something else here
 * });
 * ```
 */
var Item = (function () {
    function Item(props) {
        props = props ? props : {};
        this._name = props['name'];
        this._cname = props['cname'];
        this._id = props['id'];
        this._sceneID = props['sceneID'];
        this._value = props['value'];
        this._keepLoaded = props['keeploaded'];
        this._type = Number(props['type']);
        this._xmlparams = props;
    }
    /**
     * param: (value: string)
     * ```
     * return: Promise<Item>
     * ```
     *
     * Sets the name of the item. This method also returns the current item instance,
     * which could be used to execute functionality that requires setName to resolve
     * first.
     *
     * #### Usage
     *
     * ```javascript
     * item.setName('newNameHere').then(function(item) {
     *   // Promise would resolve current item instance, which would allow us
     *   // to execute other methods only after we're sure that setName is
     *   // done with setting the prop:name to XSplit
     *   return item.getName();
     * }).then(function(name) {
     *   // 'name' should be the updated value by now.
     * });
     * ```
     */
    Item.prototype.setName = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            _this._name = value;
            item_1.Item.set('prop:name', _this._name, slot).then(function () {
                resolve(_this);
            });
        });
    };
    /**
     * return: Promise<string>
     *
     * Gets the current name of the item.
     *
     * #### Usage
     *
     * ```javascript
     * item.getName().then(function(name) {
     *   // Do something with the name
     * });
     * ```
     */
    Item.prototype.getName = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:name', slot).then(function (val) {
                _this._name = val;
                resolve(val);
            });
        });
    };
    /**
     * param: (value: string)
     * ```
     * return: Promise<Item>
     * ```
     *
     * Sets the custom name of the item. This method also returns the current item
     * instance, which could be used to execute functionality that requires setName
     * to resolve first.
     *
     * The main difference between `setName` and `setCustomName` is that the CustomName
     * can be edited by the end users using XBC through the bottom panel. `setName` on
     * the other hand would update the item's `prop:name`, which cannot be edited by the
     * end users using XBC through the bottom panel.
     *
     * #### Usage
     *
     * ```javascript
     * item.setCustomName('newNameHere').then(function(item) {
     *   // Promise would resolve current item instance, which would allow us
     *   // to execute other methods only after we're sure that setCustomName is
     *   // done with setting the prop:cname to XSplit
     *   return item.getCustomName();
     * }).then(function(name) {
     *   // 'name' should be the updated value by now.
     * });
     * ```
     */
    Item.prototype.setCustomName = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            _this._cname = value;
            item_1.Item.set('prop:cname', _this._cname, slot).then(function () {
                resolve(_this);
            });
        });
    };
    /**
     * return: Promise<string>
     *
     * Gets the current custom name of the item.
     *
     * #### Usage
     *
     * ```javascript
     * item.getCustomName().then(function(name) {
     *   // Do something with the name
     * });
     * ```
     */
    Item.prototype.getCustomName = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:cname', slot).then(function (val) {
                _this._cname = val;
                resolve(val);
            });
        });
    };
    /**
     * return: Promise<string|XML>
     *
     * Gets the current custom name of the item.
     *
     * This method has the possibility to return an XML object, which is an object
     * generated by the framework. Call `toString()` to transform into an XML String.
     *
     * #### Usage
     *
     * ```javascript
     * item.getCustomName().then(function(name) {
     *   // Do something with the name
     * });
     * ```
     */
    Item.prototype.getValue = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:item', slot).then(function (val) {
                val = (val === 'null') ? '' : val;
                if (val === '') {
                    _this._value = '';
                    resolve(val);
                }
                else {
                    try {
                        _this._value = xml_1.XML.parseJSON(json_1.JSON.parse(val));
                        resolve(_this._value);
                    }
                    catch (e) {
                        // value is not valid XML (it is a string instead)
                        _this._value = val;
                        resolve(val);
                    }
                }
            });
        });
    };
    /**
     * param: (value: string)
     * ```
     * return: Promise<Item>
     * ```
     *
     * Set the video item's main definition. This method also returns the current item
     * instance, which could be used to execute functionality that requires setName
     * to resolve first.
     *
     * **WARNING:**
     * Please do note that using this method COULD break the current item, possibly modifying
     * its type IF you set an invalid string for the current item.
     *
     * #### Possible values by item type
     * - FILE - path/URL
     * - LIVE - Device ID
     * - BITMAP - path
     * - SCREEN - XML string
     * - FLASHFILE - path
     * - GAMESOURCE - XML string
     * - HTML - path/URL or html:<plugin>*
     * #### Usage
     *
     * ```javascript
     * item.setValue('@DEVICE:PNP:\\?\USB#VID_046D&amp;PID_082C&amp;MI_02#6&amp;16FD2F8D&amp;0&amp;0002#{65E8773D-8F56-11D0-A3B9-00A0C9223196}\GLOBAL')
     *   .then(function(item) {
     *   // Promise would resolve current item instance, which would allow us
     *   // to execute other methods only after we're sure that setCustomName
     *   // is done with setting the prop:item to XSplit
     * });
     * ```
     */
    Item.prototype.setValue = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            var val = (typeof value === 'string') ?
                value : value.toString();
            if (typeof value !== 'string') {
                _this._value = json_1.JSON.parse(val);
            }
            else {
                _this._value = val;
            }
            item_1.Item.set('prop:item', val, slot).then(function () {
                resolve(_this);
            });
        });
    };
    /**
     * return: Promise<boolean>
     *
     * Check if item is kept loaded in memory
     *
     * #### Usage
     *
     * ```javascript
     * item.getKeepLoaded().then(function(isLoaded) {
     *   // The rest of your code here
     * });
     * ```
     */
    Item.prototype.getKeepLoaded = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:keeploaded', slot).then(function (val) {
                _this._keepLoaded = (val === '1');
                resolve(_this._keepLoaded);
            });
        });
    };
    /**
     * param: (value: boolean)
     * ```
     * return: Promise<Item>
     * ```
     *
     * Set Keep loaded option to ON or OFF
     *
     * #### Usage
     *
     * ```javascript
     * item.setKeepLoaded(true).then(function(item) {
     *   // Promise would resolve current item instance, which would allow us
     *   // to execute other methods only after we're sure that setKeepLoaded is
     *   // done with setting the prop:keeploaded to XSplit
     * });
     * ```
     */
    Item.prototype.setKeepLoaded = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            _this._keepLoaded = value;
            item_1.Item.set('prop:keeploaded', (_this._keepLoaded ? '1' : '0'), slot)
                .then(function () {
                resolve(_this);
            });
        });
    };
    /**
     * return: Promise<ItemTypes>
     *
     * Get the type of the item
     *
     * #### Usage
     *
     * ```javascript
     * item.getType().then(function(type) {
     *   // The rest of your code here
     * });
     * ```
     */
    Item.prototype.getType = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:type', slot).then(function (val) {
                _this._type = ItemTypes[ItemTypes[Number(val)]];
                resolve(_this._type);
            });
        });
    };
    /**
     * return: Promise<string>
     *
     * Get the ID of the item
     *
     * #### Usage
     *
     * ```javascript
     * item.getID().then(function(id) {
     *   // The rest of your code here
     * });
     * ```
     */
    Item.prototype.getID = function () {
        var _this = this;
        return new Promise(function (resolve) {
            resolve(_this._id);
        });
    };
    /**
     * return: Promise<number>
     *
     * Get (1-indexed) Scene ID where the item is loaded
     *
     * #### Usage
     *
     * ```javascript
     * item.getSceneID().then(function(id) {
     *   // The rest of your code here
     * });
     * ```
     */
    Item.prototype.getSceneID = function () {
        var _this = this;
        return new Promise(function (resolve) {
            resolve(Number(_this._sceneID) + 1);
        });
    };
    /** Convert the Item object to an XML string */
    /**
     * return: XML
     *
     * Convert the Item object to an XML object. Please use `toString()` method to get the
     * XML String.
     *
     * #### Usage
     *
     * ```javascript
     * var xml = item.toXML();
     * ```
     */
    Item.prototype.toXML = function () {
        var item = new json_1.JSON();
        item['tag'] = 'item';
        item['name'] = this._name;
        item['item'] = this._value;
        item['type'] = this._type;
        item['selfclosing'] = true;
        if (this._cname) {
            item['cname'] = this._cname;
        }
        return xml_1.XML.parseJSON(item);
    };
    /**
     * return: Promise<Item>
     *
     * Get the current source (when function is called by sources), or the source
     * that was right-clicked to open the config window (when function is called
     * from the config window)
     *
     * #### Usage
     *
     * ```javascript
     * xjs.Item.getCurrentSource().then(function(item) {
     *   // This will fetch the current item (the plugin)
     * }).catch(function(err) {
     *   // Handle the error here. Errors would only occur
     *   // if we try to execute this method on Extension plugins
     * });
     * ```
     */
    Item.getCurrentSource = function () {
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isExtension()) {
                reject(Error('Extensions do not have sources ' +
                    'associated with them.'));
            }
            else if (environment_1.Environment.isSourcePlugin() || environment_1.Environment.isSourceConfig()) {
                scene_1.Scene.searchAllForItemId(item_1.Item.getBaseID()).then(function (item) {
                    resolve(item); // this should always exist
                });
            }
        });
    };
    return Item;
})();
exports.Item = Item;
mixin_1.applyMixins(Item, [ilayout_1.ItemLayout]);
},{"../../internal/item":20,"../../internal/util/json":21,"../../internal/util/mixin":22,"../../internal/util/xml":23,"../environment":2,"../scene":14,"./ilayout":11}],13:[function(require,module,exports){
/// <reference path="../../../defs/es6-promise.d.ts" />
var item_1 = require('../../internal/item');
var transition_1 = require('../transition');
var ItemTransition = (function () {
    function ItemTransition() {
    }
    ItemTransition.prototype.isVisible = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:visible', slot).then(function (val) {
                resolve(val === '1' ? true : false);
            });
        });
    };
    ItemTransition.prototype.setVisible = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.set('prop:visible', value ? '1' : '0', slot).then(function () {
                resolve(_this);
            });
        });
    };
    ItemTransition.prototype.getTransition = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:transitionid', slot).then(function (val) {
                if (val === '') {
                    resolve(transition_1.Transition.NONE);
                }
                else {
                    resolve(transition_1.Transition[val.toUpperCase()]);
                }
            });
        });
    };
    ItemTransition.prototype.setTransition = function (value) {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.set('prop:transitionid', value.toString(), slot).then(function () {
                resolve(_this);
            });
        });
    };
    ItemTransition.prototype.getTransitionTime = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var slot = item_1.Item.attach(_this._id);
            item_1.Item.get('prop:transitiontime', slot).then(function (val) {
                resolve(Number(val));
            });
        });
    };
    ItemTransition.prototype.setTransitionTime = function (value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (value < 0 || value > 60000) {
                reject(RangeError('Transparency may only be in the range 0 to 60000.'));
            }
            else {
                var slot = item_1.Item.attach(_this._id);
                item_1.Item.set('prop:transitiontime', String(value), slot).then(function () {
                    resolve(_this);
                });
            }
        });
    };
    return ItemTransition;
})();
exports.ItemTransition = ItemTransition;
},{"../../internal/item":20,"../transition":15}],14:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var json_1 = require('../internal/util/json');
var xml_1 = require('../internal/util/xml');
var app_1 = require('../internal/app');
var internal_1 = require('../internal/internal');
var environment_1 = require('./environment');
var item_1 = require('./item/item');
var game_1 = require('./item/game');
var camera_1 = require('./item/camera');
var audio_1 = require('./item/audio');
var html_1 = require('./item/html');
var Scene = (function () {
    function Scene(sceneNum) {
        this._id = sceneNum - 1;
    }
    ;
    Scene._initializeScenePool = function () {
        if (Scene._scenePool.length === 0) {
            for (var i = 0; i < Scene._maxScenes; i++) {
                Scene._scenePool[i] = new Scene(i + 1);
            }
        }
    };
    /**
     * return: Scene
     *
     * Get a specific scene object given the scene number.
     *
     *
     * #### Usage
     *
     * ```javascript
     * var scene1 = Scene.getById(1);
     * ```
     */
    Scene.getById = function (sceneNum) {
        // initialize if necessary
        Scene._initializeScenePool();
        return Scene._scenePool[sceneNum - 1];
    };
    /**
     * return: Promise<Scene[]>
     *
     * Asynchronous functon to get a list of scene objects with a specific name.
     *
     *
     * #### Usage
     *
     * ```javascript
     * var scenes = Scene.getByName('Game').then(function(scenes) {
     *    // manipulate scenes
     * });
     * ```
     */
    Scene.getByName = function (sceneName) {
        // initialize if necessary
        Scene._initializeScenePool();
        var namePromise = Promise.all(Scene._scenePool.map(function (scene, index) {
            return app_1.App.get('presetname:' + index).then(function (name) {
                if (sceneName === name) {
                    return Scene._scenePool[index];
                }
                else {
                    return null;
                }
            });
        }));
        return new Promise(function (resolve) {
            namePromise.then(function (results) {
                var returnArray = [];
                for (var j = 0; j < results.length; ++j) {
                    if (results[j] !== null) {
                        returnArray.push(results[j]);
                    }
                }
                ;
                resolve(returnArray);
            });
        });
    };
    /**
     * return: Promise<Scene>
     *
     * Get the currently active scene.
     *
     *
     * #### Usage
     *
     * ```javascript
     * var myScene = Scene.getActiveScene();
     * ```
     */
    Scene.getActiveScene = function () {
        return new Promise(function (resolve) {
            if (environment_1.Environment.isSourcePlugin()) {
                app_1.App.get('presetconfig:-1').then(function (sceneString) {
                    var curScene = json_1.JSON.parse(sceneString);
                    if (curScene.children.length > 0) {
                        resolve(Scene.searchSceneWithItemId(curScene.children[0]['id']));
                    }
                    else {
                        throw new Error('presetconfig cannot fetch current scene');
                    }
                });
            }
            else {
                app_1.App.get('preset:0').then(function (id) {
                    resolve(Scene.getById(Number(id) + 1));
                });
            }
        });
    };
    /**
     * param: scene<number|Scene>
     * ```
     * return: Promise<boolean>
     * ```
     *
     * Change active scene. Does not work on source plugins.
     */
    Scene.setActiveScene = function (scene) {
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isSourcePlugin()) {
                reject(Error('Not supported on source plugins'));
            }
            else {
                if (scene instanceof Scene) {
                    scene.getID().then(function (id) {
                        app_1.App.set('preset', String(id)).then(function (res) {
                            resolve(res);
                        });
                    });
                }
                else if (typeof scene === 'number') {
                    if (scene < 1 || scene > 12) {
                        reject(Error('Invalid parameters. Valid range is 1 to 12.'));
                    }
                    else {
                        app_1.App.set('preset', String(scene - 1)).then(function (res) {
                            resolve(res);
                        });
                    }
                }
                else {
                    reject(Error('Invalid parameters'));
                }
            }
        });
    };
    /**
     *
     * Searches all scenes for an item by ID. ID search will return exactly 1 result (IDs are unique) or null.
     * See also: Core/Item
     * #Return
     * ```
     * Item
     * ```
     *
     * #### Usage
     *
     * ```javascript
     * Scene.searchAllForItemId('{10F04AE-6215-3A88-7899-950B12186359}').then(function(item) {
     *   // item is either an Item or null
     * });
     * ```
     *
     */
    Scene.searchAllForItemId = function (id) {
        var isID = /^{[A-F0-9-]*}$/i.test(id);
        if (!isID) {
            throw new Error('Not a valid ID format for items');
        }
        else {
            Scene._initializeScenePool();
            return new Promise(function (resolve) {
                var match = null;
                var found = false;
                Scene._scenePool.forEach(function (scene, idx, arr) {
                    if (match === null) {
                        scene.getItems().then((function (items) {
                            found = items.some(function (item) {
                                if (item['_id'] === id) {
                                    match = item;
                                    return true;
                                }
                                else {
                                    return false;
                                }
                            });
                            if (found ||
                                Number(this) === arr.length - 1) {
                                resolve(match);
                            }
                        }).bind(idx));
                    }
                });
            });
        }
    };
    ;
    /**
     * return: Promise<Scene>
     *
     * Searches all scenes for one that contains the given item ID.
     *
     *
     * #### Usage
     *
     * ```javascript
     * Scene.searchSceneWithItemId('{10F04AE-6215-3A88-7899-950B12186359}').then(function(scene) {
     *   // scene contains the item
     * });
     * ```
     *
     */
    Scene.searchSceneWithItemId = function (id) {
        var isID = /^{[A-F0-9-]*}$/i.test(id);
        if (!isID) {
            throw new Error('Not a valid ID format for items');
        }
        else {
            Scene._initializeScenePool();
            return new Promise(function (resolve) {
                var match = null;
                var found = false;
                Scene._scenePool.forEach(function (scene, idx, arr) {
                    if (match === null) {
                        scene.getItems().then(function (items) {
                            found = items.some(function (item) {
                                if (item['_id'] === id) {
                                    match = Scene.getById(idx + 1);
                                    return true;
                                }
                                else {
                                    return false;
                                }
                            });
                            if (found ||
                                idx === arr.length - 1) {
                                resolve(match);
                            }
                        });
                    }
                });
            });
        }
    };
    ;
    /**
     * return: Promise<Item[]>
     *
     * Searches all scenes for an item by name substring.
     *
     *
     * #### Usage
     *
     * ```javascript
     * Scene.searchAllForItemName('camera').then(function(items) {
     *   // do something to each item in items array
     * });
     * ```
     *
     */
    Scene.searchAllForItemName = function (param) {
        Scene._initializeScenePool();
        var matches = [];
        return new Promise(function (resolve) {
            return Promise.all(Scene._scenePool.map(function (scene) {
                return new Promise(function (resolveScene) {
                    scene.getItems().then(function (items) {
                        if (items.length === 0) {
                            resolveScene();
                        }
                        else {
                            return Promise.all(items.map(function (item) {
                                return new Promise(function (resolveItem) {
                                    item.getName().then(function (name) {
                                        if (name.match(param)) {
                                            matches.push(item);
                                            return '';
                                        }
                                        else {
                                            return item.getValue();
                                        }
                                    }).then(function (value) {
                                        if (value.toString().match(param)) {
                                            matches.push(item);
                                        }
                                        resolveItem();
                                    });
                                });
                            })).then(function () {
                                resolveScene();
                            });
                        }
                    });
                });
            })).then(function () {
                resolve(matches);
            });
        });
    };
    ;
    /**
     * return: Promise<boolean>

     * Load scenes that are not yet initialized in XSplit Broadcaster.
     *
     * Note: For memory saving purposes, this is not called automatically.
     * If your extension wants to manipulate multiple scenes, it is imperative that you call this function.
     * This function is only available to extensions.
     *
     * #### Usage
     *
     * ```javascript
     * Scene.initializeScenes().then(function(val) {
     *   if (val === true) {
     *     // Now you know that all scenes are loaded :)
     *   }
     * })
     * ```
     */
    Scene.initializeScenes = function () {
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isSourcePlugin()) {
                reject(Error('function is not available for source'));
            }
            app_1.App.get('presetcount').then(function (cnt) {
                if (Number(cnt) !== 12) {
                    // Insert an empty scene for scene #12
                    app_1.App
                        .set('presetconfig:11', '<placement name="Scene 12" defpos="0" />')
                        .then(function (res) {
                        resolve(res);
                    });
                }
                else {
                    resolve(true);
                }
            });
        });
    };
    /**
     * return: number
     *
     * Get the 1-indexed scene number of this scene object.
     *
     *
     * #### Usage
     *
     * ```javascript
     * myScene.getSceneNumber().then(function(num) {
     *  console.log('My scene is scene number ' + num);
     * });
     * ```
     */
    Scene.prototype.getSceneNumber = function () {
        var _this = this;
        return new Promise(function (resolve) {
            resolve(_this._id + 1);
        });
    };
    /**
     * return: number
     *
     * Get the name of this scene object.
     *
     *
     * #### Usage
     *
     * ```javascript
     * myScene.getSceneName().then(function(name) {
     *  console.log('My scene is named ' + name);
     * });
     * ```
     */
    Scene.prototype.getName = function () {
        var _this = this;
        return new Promise(function (resolve) {
            app_1.App.get('presetname:' + _this._id).then(function (val) {
                resolve(val);
            });
        });
    };
    /**
     *
     * Set the name of this scene object. Cannot be set by source plugins.
     *
     * #### Usage
     *
     * ```javascript
     * myScene.setName('Gameplay');
     * ```
     */
    Scene.prototype.setName = function (name) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isSourcePlugin()) {
                reject(Error('Scene names are readonly for source plugins.'));
            }
            else {
                app_1.App.set('presetname:' + _this._id, name).then(function (value) {
                    resolve(value);
                });
            }
        });
    };
    /**
     * return: Promise<Item[]>
     *
     * Gets all the items (sources) in a specific scene.
     * See also: Core/Item
     *
     * #### Usage
     *
     * ```javascript
     * myScene.getItems().then(function(items) {
     *  // do something to each item in items array
     * });
     * ```
     */
    Scene.prototype.getItems = function () {
        var _this = this;
        return new Promise(function (resolve) {
            app_1.App.getAsList('presetconfig:' + _this._id).then(function (jsonArr) {
                var promiseArray = [];
                // type checking to return correct Item subtype
                var typePromise = function (index) { return new Promise(function (typeResolve) {
                    var item = jsonArr[index];
                    var type = Number(item['type']);
                    if (type === item_1.ItemTypes.GAMESOURCE) {
                        typeResolve(new game_1.GameItem(item));
                    }
                    else if (type === item_1.ItemTypes.HTML) {
                        typeResolve(new html_1.HTMLItem(item));
                    }
                    else if (Number(jsonArr[index]['type']) === item_1.ItemTypes.LIVE &&
                        jsonArr[index]['item'].indexOf('{33D9A762-90C8-11D0-BD43-00A0C911CE86}') === -1) {
                        typeResolve(new camera_1.CameraItem(jsonArr[index]));
                    }
                    else if (Number(jsonArr[index]['type']) === item_1.ItemTypes.LIVE &&
                        jsonArr[index]['item'].indexOf('{33D9A762-90C8-11D0-BD43-00A0C911CE86}') !== -1) {
                        typeResolve(new audio_1.AudioItem(jsonArr[index]));
                    }
                    else {
                        typeResolve(new item_1.Item(jsonArr[index]));
                    }
                }); };
                if (Array.isArray(jsonArr)) {
                    for (var i = 0; i < jsonArr.length; i++) {
                        jsonArr[i]['sceneID'] = _this._id;
                        promiseArray.push(typePromise(i));
                    }
                }
                Promise.all(promiseArray).then(function (results) {
                    resolve(results);
                });
            });
        });
    };
    /**
     * Checks if a scene is empty.
     *
     * #### Usage
     *
     * ```javascript
     * myScene.isEmpty().then(function(empty) {
     *   if (empty === true) {
     *     console.log("My scene is empty.");
     *   }
     * });
     * ```
     */
    Scene.prototype.isEmpty = function () {
        var _this = this;
        return new Promise(function (resolve) {
            app_1.App.get('presetisempty:' + _this._id).then(function (val) {
                resolve(val === '1');
            });
        });
    };
    /**
     * param: Array<Item> | Array<string>
     * ```
     * return: Promise<Scene>
     * ```
     *
     * Sets the item order of the current scene. It is ordered as bottom to top.
     */
    Scene.prototype.setItemOrder = function (items) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isSourcePlugin()) {
                reject(Error('not available for source plugins'));
            }
            else {
                var ids = [];
                Scene.getActiveScene().then(function (scene) {
                    if (items.every(function (el) { return el instanceof item_1.Item; })) {
                        return new Promise(function (resolve) {
                            var promises = [];
                            for (var i in items) {
                                promises.push((function (_i) {
                                    return new Promise(function (resolve) {
                                        items[_i].getID().then(function (id) {
                                            ids[_i] = id;
                                            resolve(_this);
                                        });
                                    });
                                })(i));
                            }
                            Promise.all(promises).then(function () {
                                return scene.getSceneNumber();
                            }).then(function (id) {
                                resolve(id);
                            });
                        });
                    }
                    else {
                        ids = items;
                        return scene.getSceneNumber();
                    }
                }).then(function (id) {
                    if ((Number(id) - 1) === _this._id && environment_1.Environment.isSourceConfig()) {
                        internal_1.exec('SourcesListOrderSave', ids.join(','));
                        resolve(_this);
                    }
                    else {
                        var sceneName;
                        _this.getName().then(function (name) {
                            sceneName = name;
                            return app_1.App.getAsList('presetconfig:' + _this._id);
                        }).then(function (jsonArr) {
                            var newOrder = new json_1.JSON();
                            newOrder.children = [];
                            newOrder['tag'] = 'placement';
                            newOrder['name'] = sceneName;
                            if (Array.isArray(jsonArr)) {
                                var attrs = ['name', 'cname', 'item'];
                                for (var i = 0; i < jsonArr.length; i++) {
                                    for (var a = 0; a < attrs.length; a++) {
                                        jsonArr[i][attrs[a]] = jsonArr[i][attrs[a]]
                                            .replace(/([^\\])(\\)([^\\])/g, '$1\\\\$3');
                                        jsonArr[i][attrs[a]] = jsonArr[i][attrs[a]]
                                            .replace(/"/g, '&quot;');
                                    }
                                    newOrder.children[ids.indexOf(jsonArr[i]['id'])] = jsonArr[i];
                                }
                                app_1.App.set('presetconfig:' + _this._id, xml_1.XML.parseJSON(newOrder).toString()).then(function () {
                                    resolve(_this);
                                });
                            }
                            else {
                                reject(Error('Scene does not have any items'));
                            }
                        });
                    }
                });
            }
        });
    };
    Scene._maxScenes = 12;
    Scene._scenePool = [];
    return Scene;
})();
exports.Scene = Scene;
},{"../internal/app":16,"../internal/internal":19,"../internal/util/json":21,"../internal/util/xml":23,"./environment":2,"./item/audio":3,"./item/camera":4,"./item/game":5,"./item/html":6,"./item/item":12}],15:[function(require,module,exports){
/**
 * The Transition class represents a preset transition within XSplit Broadcaster.
 * This may be used to set the application's transition scheme when switching scenes,
 * or to set an individual source's transition when its visibility changes.
 *
 * Simply use one of the available Transition objects such as Transition.FAN or
 * Transition.COLLAPSE as the parameter to the setTransition method of an App
 * or Item instance.
 */
var Transition = (function () {
    function Transition(key) {
        this._key = key; // retain key so that NONE is readable
        this._value = Transition._transitionMap[key];
    }
    /**
     * Converts this transition object to the underlying string representation to be read by XSplit Broadcaster.
     */
    Transition.prototype.toString = function () {
        return this._value;
    };
    /**
     * Converts this transition object to a easily identifiable string such as 'NONE'.
     */
    Transition.prototype.toTransitionKey = function () {
        return this._key;
    };
    Transition._transitionMap = {
        NONE: '',
        CLOCK: 'clock',
        COLLAPSE: 'collapse',
        FADE: 'fade',
        FAN: 'fan',
        HOLE: 'hole',
        MOVE_BOTTOM: 'move_bottom',
        MOVE_LEFT: 'move_left',
        MOVE_LEFT_RIGHT: 'move_left_right',
        MOVE_RIGHT: 'move_right',
        MOVE_TOP: 'move_top',
        MOVE_TOP_BOTTOM: 'move_top_bottom',
        WAVE: 'wave'
    };
    Transition.NONE = new Transition('NONE');
    Transition.CLOCK = new Transition('CLOCK');
    Transition.COLLAPSE = new Transition('COLLAPSE');
    Transition.FADE = new Transition('FADE');
    Transition.FAN = new Transition('FAN');
    Transition.HOLE = new Transition('HOLE');
    Transition.MOVE_BOTTOM = new Transition('MOVE_BOTTOM');
    Transition.MOVE_LEFT = new Transition('MOVE_LEFT');
    Transition.MOVE_LEFT_RIGHT = new Transition('MOVE_LEFT_RIGHT');
    Transition.MOVE_RIGHT = new Transition('MOVE_RIGHT');
    Transition.MOVE_TOP = new Transition('MOVE_TOP');
    Transition.MOVE_TOP_BOTTOM = new Transition('MOVE_TOP_BOTTOM');
    Transition.WAVE = new Transition('WAVE');
    return Transition;
})();
exports.Transition = Transition;
},{}],16:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var internal_1 = require('./internal');
var json_1 = require('./util/json');
var POSTMESSAGE_CLOSE = '1';
var POSTMESSAGE_SIZE = '2';
var App = (function () {
    function App() {
    }
    /** Get the value of the given property */
    App.get = function (name) {
        return new Promise(function (resolve) {
            internal_1.exec('AppGetPropertyAsync', name, resolve);
        });
    };
    /** Sets the value of a property */
    App.set = function (name, value) {
        return new Promise(function (resolve) {
            internal_1.exec('AppSetPropertyAsync', name, value, function (ret) {
                resolve(Number(ret) < 0 ? false : true);
            });
        });
    };
    /** Gets the value of the given property as list */
    App.getAsList = function (name) {
        return new Promise(function (resolve) {
            App.get(name).then(function (xml) {
                var propsJSON = json_1.JSON.parse(xml), propsArr = [];
                if (propsJSON.children && propsJSON.children.length > 0) {
                    propsArr = propsJSON.children;
                }
                resolve(propsArr);
            });
        });
    };
    /** Get the value of the given global property */
    App.getGlobalProperty = function (name) {
        return internal_1.exec('GetGlobalProperty', name);
    };
    /** Calls a DLL function synchronously */
    App.callDll = function (func) {
        var arg = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            arg[_i - 1] = arguments[_i];
        }
        var args = [].slice.call(arguments);
        args.unshift('CallDll');
        return internal_1.exec.apply(this, args);
    };
    /** Calls an application method asynchronously */
    App.callFunc = function (func, arg) {
        return new Promise(function (resolve) {
            internal_1.exec('AppCallFuncAsync', func, arg, function (ret) {
                resolve(ret);
            });
        });
    };
    App.postMessage = function (key) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return new Promise(function (resolve) {
            args.unshift(key);
            args.unshift('PostMessageToParent');
            args.push(function (val) {
                resolve(val);
            });
            internal_1.exec.apply(_this, args);
        });
    };
    return App;
})();
exports.App = App;
},{"./internal":19,"./util/json":21}],17:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var Global = (function () {
    function Global() {
    }
    Global.addInitializationPromise = function (promise) {
        Global.initialPromises.push(promise);
    };
    Global.getInitializationPromises = function () {
        return Global.initialPromises;
    };
    Global.setPersistentConfig = function (config) {
        Global.persistedConfig = config;
    };
    Global.getPersistentConfig = function () {
        return Global.persistedConfig;
    };
    Global.persistedConfig = {};
    Global.initialPromises = [];
    return Global;
})();
exports.Global = Global;
},{}],18:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var environment_1 = require('../core/environment');
var item_1 = require('./item');
var internal_1 = require('./internal');
var global_1 = require('./global');
var config_1 = require('../window/config');
function resolveRelativePath(path, base) {
    // ABSOLUTE PATHS
    if (path.substring(0, 7) === 'http://' ||
        path.substring(0, 8) === 'https://') {
        return path;
    }
    else if (path.substring(0, 2) === '//') {
        // get current protocol
        return base.split('://')[0] + ':' + path;
    }
    else if (path.substring(0, 3) === '../') {
        // RELATIVE PATHS
        var upDirectoryCount = 0;
        // count ../ segments
        while (path.substring(0, 3) === '../') {
            path = path.substring(3);
            ++upDirectoryCount;
        }
        var baseDirectories = base.split('/');
        baseDirectories = baseDirectories.slice(0, length - 1 - upDirectoryCount);
        baseDirectories.push(path);
        return baseDirectories.join('/');
    }
    else {
        if (path.substring(0, 2) === './') {
            path = path.substring(2);
        }
        var baseSegments = base.split('/');
        baseSegments[baseSegments.length - 1] = path;
        return baseSegments.join('/');
    }
}
function readMetaConfigUrl() {
    return new Promise(function (resolve) {
        if (environment_1.Environment.isSourcePlugin()) {
            var configObj = {};
            // initialize config URL if necessary
            try {
                var config = internal_1.exec('GetConfiguration');
                configObj = JSON.parse(config);
            }
            catch (e) {
            }
            finally {
                var metas = document.getElementsByTagName("meta");
                for (var i = metas.length - 1; i >= 0; i--) {
                    if (metas[i].name === 'xsplit:config-url') {
                        var url = resolveRelativePath(metas[i].content, window.location.href);
                        configObj['configUrl'] = url;
                        var persist = {
                            configUrl: url
                        };
                        global_1.Global.setPersistentConfig(persist);
                        break;
                    }
                }
                internal_1.exec('SetBrowserProperty', 'Configuration', JSON.stringify(configObj));
                resolve();
            }
        }
        else {
            resolve();
        }
    });
}
function getCurrentSourceID() {
    return new Promise(function (resolve) {
        if (environment_1.Environment.isSourcePlugin() || environment_1.Environment.isSourceConfig()) {
            // initialize Item.getSource() functions
            internal_1.exec('GetLocalPropertyAsync', 'prop:id', function (result) {
                var id = decodeURIComponent(result);
                item_1.Item.setBaseID(id);
                if (environment_1.Environment.isSourcePlugin()) {
                    item_1.Item.lockSourceSlot(id);
                }
                resolve();
            });
        }
        else {
            resolve();
        }
    });
}
function informWhenConfigLoaded() {
    return new Promise(function (resolve) {
        if (environment_1.Environment.isSourceConfig()) {
            window.addEventListener('load', function () {
                config_1.SourceConfigWindow.getInstance().emit('config-load');
                resolve();
            });
        }
        else {
            resolve(); // other environments don't care if config iframe has loaded
        }
    });
}
function init() {
    global_1.Global.addInitializationPromise(readMetaConfigUrl());
    global_1.Global.addInitializationPromise(getCurrentSourceID());
    global_1.Global.addInitializationPromise(informWhenConfigLoaded());
    Promise.all(global_1.Global.getInitializationPromises()).then(function () {
        document.dispatchEvent(new CustomEvent('xsplit-js-ready', {
            bubbles: true
        }));
    });
}
init();
},{"../core/environment":2,"../window/config":34,"./global":17,"./internal":19,"./item":20}],19:[function(require,module,exports){
/// <reference path="../../defs/window.d.ts" />
exports.DEBUG = false;
var _callbacks = {};
/**
* Executes an external function
*/
function exec(funcName) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var callback = null, ret = false;
    if (args.length > 0) {
        callback = args[args.length - 1];
        if (callback instanceof Function) {
            args.pop();
        }
        else {
            callback = null;
        }
    }
    if (exports.DEBUG) {
        console.log([
            'internal.exec("', funcName, '") ', JSON.stringify(args)
        ].join(' '));
    }
    if (window.external &&
        window.external[funcName] &&
        window.external[funcName] instanceof Function) {
        ret = window.external[funcName].apply(this, args);
    }
    // register callback if present
    if (callback !== null) {
        _callbacks[ret] = callback;
    }
    return ret;
}
exports.exec = exec;
window.OnAsyncCallback = function (asyncID, result) {
    var callback = _callbacks[asyncID];
    if (callback instanceof Function) {
        callback.call(this, decodeURIComponent(result));
    }
};
window.OnSceneLoad = function (view, scene) {
    document.dispatchEvent(new CustomEvent('scene-load', { detail: { view: view, scene: scene } }));
};
window.SetConfiguration = function (config) {
    document.dispatchEvent(new CustomEvent('set-configuration', { config: config }));
};
window.SetBackGroundColor = function (color) {
    document.dispatchEvent(new CustomEvent('set-background-color', { color: color }));
};
window.SetVolume = function (volume) {
    document.dispatchEvent(new CustomEvent('set-volume', { volume: volume }));
};
window.OnDialogResult = function (result) {
    document.dispatchEvent(new CustomEvent('dialog-result', { detail: { result: result } }));
};
},{}],20:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var internal_1 = require('./internal');
var environment_1 = require('../core/environment');
var Item = (function () {
    function Item() {
    }
    /** Prepare an item for manipulation */
    Item.attach = function (itemID) {
        var slot = Item.itemSlotMap.indexOf(itemID);
        if (slot === -1) {
            slot = ++Item.lastSlot % Item.MAX_SLOTS;
            if (Item.islockedSourceSlot && slot === 0) {
                ++slot; // source cannot attach to first slot
            }
            Item.lastSlot = slot;
            Item.itemSlotMap[slot] = itemID;
            if (environment_1.Environment.isExtension()) {
                internal_1.exec('SearchVideoItem' +
                    (String(slot) === '0' ? '' : (slot + 1)), itemID);
            }
            else {
                internal_1.exec('AttachVideoItem' +
                    (String(slot) === '0' ? '' : (slot + 1)), itemID);
            }
        }
        return slot;
    };
    /** used for source plugins. lock an id to slot 0 */
    Item.lockSourceSlot = function (itemID) {
        if (itemID !== undefined) {
            Item.islockedSourceSlot = true;
            Item.itemSlotMap[0] = itemID;
        }
        else {
            Item.islockedSourceSlot = false;
            Item.itemSlotMap[0] = '';
        }
    };
    /** Get an item's local property asynchronously */
    Item.get = function (name, slot) {
        if (slot === void 0) { slot = 0; }
        return new Promise(function (resolve) {
            internal_1.exec('GetLocalPropertyAsync' +
                (String(slot) === '0' ? '' : slot + 1), name, function (val) {
                resolve(val);
            });
        });
    };
    /** Sets an item's local property */
    Item.set = function (name, value, slot) {
        if (slot === void 0) { slot = 0; }
        return new Promise(function (resolve) {
            internal_1.exec('SetLocalPropertyAsync' +
                (String(slot) === '0' ? '' : slot + 1), name, value, function (val) {
                resolve(!(Number(val) < 0));
            });
        });
    };
    /** Calls a function defined in an item/source */
    Item.callFunc = function (func, arg) {
        internal_1.exec('CallInner', func, arg);
    };
    /** helper function to get current source on init */
    Item.setBaseID = function (id) {
        Item.baseID = id;
    };
    /** helper function for Item.getCurrentSource() */
    Item.getBaseID = function () {
        return Item.baseID;
    };
    Item.MAX_SLOTS = 2;
    Item.lastSlot = Item.MAX_SLOTS - 1;
    Item.itemSlotMap = [];
    Item.islockedSourceSlot = false;
    return Item;
})();
exports.Item = Item;
},{"../core/environment":2,"./internal":19}],21:[function(require,module,exports){
var xml_1 = require('./xml');
var JSON = (function () {
    function JSON(xml) {
        if (xml === undefined || xml === '') {
            return;
        }
        var sxml = xml;
        if (xml instanceof xml_1.XML) {
            sxml = xml.toString();
        }
        var openingRegex = /<([^\s>\/]+)/g;
        var selfCloseRegex = /(\/>)/g;
        var openResult = openingRegex.exec(sxml);
        var selfCloseResult = selfCloseRegex.exec(sxml);
        var xmlDocument = (new DOMParser()).parseFromString(sxml, 'application/xml');
        if (xmlDocument.getElementsByTagName('parsererror').length > 0) {
            throw new Error('XML parsing error. Invalid XML string');
        }
        var processNode = function (node) {
            var obj = new JSON();
            obj.tag = node.tagName;
            // FIXME: optimize complex condition
            // every time we process a new node, we advance the opening tag regex
            openResult = openingRegex.exec(sxml);
            if (openResult === null && selfCloseRegex.lastIndex === 0) {
            }
            else if (openResult === null && selfCloseRegex.lastIndex > 0) {
                // no more opening tags, so by default the self-closing belongs to this
                obj.selfclosing = true;
                selfCloseResult = selfCloseRegex.exec(sxml);
            }
            else if (openResult !== null &&
                selfCloseRegex.lastIndex > openingRegex.lastIndex) {
            }
            else if (openResult !== null &&
                selfCloseRegex.lastIndex < openingRegex.lastIndex &&
                selfCloseRegex.lastIndex === openingRegex.lastIndex -
                    openResult[0].length // make sure self-closing pattern belongs to
            ) {
                obj.selfclosing = true;
                selfCloseResult = selfCloseRegex.exec(sxml);
            }
            for (var i = 0; i < node.attributes.length; i++) {
                var att = node.attributes[i];
                obj[att.name] = att.value;
            }
            obj.children = [];
            // FIXME: self-closing nodes do not have children, maybe optimize then?
            for (var j = 0; j < node.childNodes.length; j++) {
                var child = node.childNodes[j];
                if (child instanceof Element) {
                    obj.children.push(processNode(child));
                }
            }
            // process text value
            if (obj.value === undefined && obj.children.length === 0) {
                delete obj.children;
                obj.value = node.textContent;
            }
            return obj;
        };
        return processNode(xmlDocument.childNodes[0]);
    }
    JSON.parse = function (xml) {
        return new JSON(xml);
    };
    return JSON;
})();
exports.JSON = JSON;
},{"./xml":23}],22:[function(require,module,exports){
function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(function (baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
            if (name === 'constructor') {
                return;
            }
            derivedCtor.prototype[name] = baseCtor.prototype[name];
        });
    });
}
exports.applyMixins = applyMixins;
},{}],23:[function(require,module,exports){
var XML = (function () {
    function XML(json) {
        var attributes = '';
        var value = '';
        if (json.value === undefined) {
            json.value = '';
        }
        for (var key in json) {
            if (!XML.RESERVED_ATTRIBUTES.test(key) &&
                json[key] !== undefined) {
                attributes += [' ', key, '="', json[key], '"'].join('');
            }
        }
        if (json.children === undefined) {
            json.children = [];
        }
        for (var _i = 0, _a = json.children; _i < _a.length; _i++) {
            var child = _a[_i];
            json.value += new XML(child).toString();
        }
        if (json.selfclosing === true) {
            this.xml = ['<', json.tag, attributes, '/>'].join('');
        }
        else if (value !== '') {
            this.xml = ['<', json.tag, attributes, '>',
                value, '</', json.tag, '>'].join('');
        }
        else {
            // json actually contains text content
            this.xml = ['<', json.tag, attributes, '>',
                json.value, '</', json.tag, '>'].join('');
        }
    }
    XML.prototype.toString = function () {
        return this.xml;
    };
    XML.parseJSON = function (json) {
        return new XML(json);
    };
    XML.encode = function (str) {
        return str.replace(/[&<>'']/g, function ($0) {
            return '&' + {
                '&': 'amp',
                '<': 'lt',
                '>': 'gt',
                '\'': 'quot',
                '"': '#39'
            }[$0] + ';';
        });
    };
    XML.RESERVED_ATTRIBUTES = /^(children|tag|value|selfclosing)$/i;
    return XML;
})();
exports.XML = XML;
},{}],24:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var json_1 = require('../internal/util/json');
var xml_1 = require('../internal/util/xml');
/**
 * The AudioDevice Class is the object returned by
 * {@link #system/System System Class'} getAudioDevices method. It provides you
 * with methods to fetch the audio device object's attributes, and also provides
 * methods to convert it back to an XML object that is compatible with XBC
 *
 * ### Basic Usage
 *
 * ```javascript
 * var XJS = require('xjs');
 * var System = XJS.System;
 *
 * System.getAudioDevices().then(function(audios) {
 *   for (var i in audios) {
 *     // Do not include the imaginary xsplit audio device if that ever exist
 *     if (audios[i].getName().indexOf('xsplit') === -1) {
 *       xml = audios[i].toXML();
 *       // do something with the XML here
 *     }
 *   }
 * });
 * ```
 */
var AudioDevice = (function () {
    function AudioDevice(props) {
        this._defaultConsole = false;
        this._defaultMultimedia = false;
        this._defaultCommunication = false;
        props = props || {};
        this._id = props['id'];
        this._name = props['name'];
        this._adapter = props['adapter'];
        this._adapterdev = props['adapterdev'];
        this._dSoundGuid = props['dSoundGuid'];
        this._dataFlow = props['dataFlow'];
        this._state = props['state'];
        this._defaultConsole = props['defaultConsole'];
        this._defaultMultimedia = props['defaultMultimedia'];
        this._defaultCommunication = props['defaultCommunication'];
        this._level = props['level'] !== undefined ? props['level'] : 1.000000;
        this._enable = props['enable'] !== undefined ? props['enable'] : true;
        this._hwlevel = props['hwlevel'] !== undefined ? props['hwlevel'] : -1.000000;
        this._hwenable = props['hwenable'] !== undefined ? props['hwenable'] : 255;
        this._delay = props['delay'] !== undefined ? props['delay'] : 0;
        this._mix = props['mix'] !== undefined ? props['mix'] : 0;
    }
    /**
     * return: string
     *
     * Gets the device ID
     *
     * #### Usage
     *
     * ```javascript
     * var audioDeviceID = device.getID();
     * ```
     */
    AudioDevice.prototype.getId = function () {
        return this._id;
    };
    /**
     * return: string
     *
     * Gets the device name
     *
     * #### Usage
     *
     * ```javascript
     * var audioDeviceName = device.getName();
     * ```
     */
    AudioDevice.prototype.getName = function () {
        return this._name;
    };
    /**
     * return: string
     *
     * Gets whether device is capturing or rendering audio
     *
     * #### Usage
     *
     * ```javascript
     * var audioDataFlow = device.getDataFlow();
     *   //where possible values are "render" or "capture"
     * ```
     */
    AudioDevice.prototype.getDataFlow = function () {
        return this._dataFlow;
    };
    /**
     * return: boolean
     *
     * Gets whether audio device is the system default
     *
     * #### Usage
     *
     * ```javascript
     * var audioIsDefaultDevice = audioDevice.isDefaultDevice();
     * ```
     */
    AudioDevice.prototype.isDefaultDevice = function () {
        return (this._defaultConsole && this._defaultMultimedia);
    };
    /**
     * return: number
     *
     * Gets the device audio level in the application
     *
     * #### Usage
     *
     * ```javascript
     * var audioDeviceVolumeLevel = audioDevice.getLevel();
     * ```
     */
    AudioDevice.prototype.getLevel = function () {
        return this._level;
    };
    /**
     * param: level<number>
     * ```
     * return: AudioDevice (used for chaining)
     * ```
     *
     * Sets the device audio level in the application
     *
     * #### Usage
     *
     * ```javascript
     * audioDevice.setLevel(100);
     * ```
     */
    AudioDevice.prototype.setLevel = function (level) {
        this._level = level;
        return this;
    };
    /**
     * return: boolean
     *
     * Gets whether audio device is the system default
     *
     * #### Usage
     *
     * ```javascript
     * var isAudioDeviceEnabled = audioDevice.isEnabled();
     * ```
     */
    AudioDevice.prototype.isEnabled = function () {
        return this._enable;
    };
    /**
     * param: enabled<boolean>
     * ```
     * return: AudioDevice (used for chaining)
     * ```
     *
     * Enables audio device/sets software mute
     *
     * #### Usage
     *
     * ```javascript
     * audioDevice.setEnabled(true);
     * ```
     */
    AudioDevice.prototype.setEnabled = function (enabled) {
        this._enable = enabled;
        return this;
    };
    /**
     * return: number
     *
     * Gets the device system volume
     *
     * #### Usage
     *
     * ```javascript
     * var systemVolumeLevel = audioDevice.getSystemLevel();
     * ```
     */
    AudioDevice.prototype.getSystemLevel = function () {
        return this._hwlevel;
    };
    /**
     * param: volume<number>
     * ```
     * return: AudioDevice (used for chaining)
     * ```
     *
     * Sets the device system volume
     *
     * #### Usage
     *
     * ```javascript
     * audioDevice.setSystemLevel(100);
     * ```
     */
    AudioDevice.prototype.setSystemLevel = function (hwlevel) {
        this._hwlevel = hwlevel;
        return this;
    };
    /**
     * return: number
     *
     * Gets whether audio device is enabled/muted in the system
     *
     * #### Usage
     *
     * ```javascript
     * var systemAudioDeviceEnabled = audioDevice.getSystemEnabled();
     * ```
     */
    AudioDevice.prototype.getSystemEnabled = function () {
        return this._hwenable;
    };
    /**
     * param: systemEnabled<number>
     * ```
     * return: AudioDevice (used for chaining)
     * ```
     *
     * Enables audio device/sets software mute
     *
     * #### Usage
     *
     * ```javascript
     * // you may use the following:
     * //     * AudioDevice.SYSTEM_LEVEL_MUTE (0)
     * //     * AudioDevice.SYSTEM_LEVEL_ENABLE (1)
     * //     * AudioDevice.SYSTEM_MUTE_CHANGE_NOT_ALLOWED (255)
     * audioDevice.setSystemEnabled(AudioDevice.SYSTEM_LEVEL_MUTE);
     * ```
     */
    AudioDevice.prototype.setSystemEnabled = function (hwenabled) {
        this._hwenable = hwenabled;
        return this;
    };
    /**
     * return: number (100 nanoseconds in units)
     *
     * Get the loopback capture delay value
     *
     * #### Usage
     *
     * ```javascript
     * var audioDelay = audioDevice.getDelay();
     * ```
     */
    AudioDevice.prototype.getDelay = function () {
        return this._delay;
    };
    /**
     * param: delay<number> (100 nanoseconds in units)
     * ```
     * return: AudioDevice (used for chaining)
     * ```
     *
     * Sets the loopback capture delay value
     *
     * #### Usage
     *
     * ```javascript
     * audioDevice.setDelay(100);
     * ```
     */
    AudioDevice.prototype.setDelay = function (delay) {
        this._delay = delay;
        return this;
    };
    /**
     * return: string
     *
     * Converts the AudioDevice item to XML-formatted string
     *
     * #### Usage
     *
     * ```javascript
     * var audioDeviceXMLString = AudioDevice.toString();
     * ```
     */
    AudioDevice.prototype.toString = function () {
        var device = new json_1.JSON();
        device.tag = 'dev';
        device.selfclosing = true;
        device['id'] = this.getId();
        device['level'] = this.getLevel().toFixed(6);
        device['enable'] = this.isEnabled() ? 1 : 0;
        device['hwlevel'] = this.getSystemLevel().toFixed(6);
        device['hwenable'] = this.getSystemEnabled();
        device['delay'] = this.getDelay();
        device['mix'] = this._mix;
        return xml_1.XML.parseJSON(device).toString();
    };
    /**
     * param: deviceJXON<JSON>
     * ```
     * return: AudioDevice
     * ```
     *
     * Converts a JSON object into an AudioDevice object
     *
     * #### Usage
     *
     * ```javascript
     * var newAudioDevice = AudioDevice.parse(deviceJSONObj);
     * ```
     */
    AudioDevice.parse = function (deviceJXON) {
        var audio = new AudioDevice({
            id: deviceJXON['id'],
            name: deviceJXON['name'],
            adapter: deviceJXON['adapter'],
            adapterdev: deviceJXON['adapterdev'],
            dataFlow: deviceJXON['DataFlow'],
            state: deviceJXON['State'],
            dSoundGuid: deviceJXON['DSoundGuid'],
            defaultCommunication: (deviceJXON['DefaultCommunication'] === '1'),
            defaultConsole: (deviceJXON['DefaultConsole'] === '1'),
            defaultMultimedia: (deviceJXON['DefaultMultimedia'] === '1')
        });
        audio.setLevel(Number(deviceJXON['level'] !== undefined ? deviceJXON['level'] : 1))
            .setEnabled(deviceJXON['enable'] !== undefined ? deviceJXON['enable'] === '1' : true)
            .setSystemLevel(Number(deviceJXON['hwlevel'] !== undefined ? deviceJXON['hwlevel'] : -1))
            .setSystemEnabled(deviceJXON['hwenable'] !== undefined ? deviceJXON['hwenable'] : 255)
            .setDelay(Number(deviceJXON['delay'] !== undefined ? deviceJXON['delay'] : 0));
        return audio;
    };
    AudioDevice.STATE_ACTIVE = 'Active';
    AudioDevice.DATAFLOW_RENDER = 'Render';
    AudioDevice.DATAFLOW_CAPTURE = 'Capture';
    AudioDevice.SYSTEM_LEVEL_MUTE = 0;
    AudioDevice.SYSTEM_LEVEL_ENABLE = 1;
    AudioDevice.SYSTEM_MUTE_CHANGE_NOT_ALLOWED = 255;
    return AudioDevice;
})();
exports.AudioDevice = AudioDevice;
},{"../internal/util/json":21,"../internal/util/xml":23}],25:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var json_1 = require('../internal/util/json');
var xml_1 = require('../internal/util/xml');
var app_1 = require('../internal/app');
/**
 * The CameraDevice Class is the object returned by
 * {@link #system/System System Class'} getCameraDevices method. It provides
 * you with methods to fetch the Camera Device's id, name, and convert it to
 * an XML object that is compatible with XBC
 *
 * ### Basic Usage
 *
 * ```javascript
 * var XJS = require('xjs');
 * var System = XJS.System;
 *
 * System.getCameraDevices().then(function(cameras) {
 *   for (var i in cameras) {
 *     // Do not include the imaginary xsplit camera if that ever exist
 *     if (cameras[i].getName().indexOf('xsplit') === -1) {
 *       xml = cameras[i].toXML();
 *       // do something with the XML here
 *     }
 *   }
 * });
 * ```
 */
var CameraDevice = (function () {
    function CameraDevice(props) {
        this._id = props['id'];
        this._name = props['name'];
    }
    /**
     * return: string
     *
     * Get the ID of the device. The ID of the device is based on the `disp`
     * attribute of the devices XML
     *
     * #### Usage
     *
     * ```javascript
     * var cameraID = device.getID();
     * ```
     */
    CameraDevice.prototype.getId = function () {
        return this._id;
    };
    /**
     * return: string
     *
     * Get the Name of the device.
     *
     * #### Usage
     *
     * ```javascript
     * var cameraName = device.getName();
     * ```
     */
    CameraDevice.prototype.getName = function () {
        return this._name;
    };
    /**
     * return: XML
     *
     * Convert the current CameraDevice object to XML
     *
     * #### Usage
     *
     * ```javascript
     * var xml = device.toXML();
     * ```
     */
    CameraDevice.prototype.toXML = function () {
        var json = new json_1.JSON();
        json['disp'] = this._id;
        json['name'] = this._name;
        return xml_1.XML.parseJSON(json);
    };
    /**
     * param: deviceJSON<JXON>
     * ```
     * return: CameraDevice
     * ```
     *
     * Create a CameraDevice object based on a JXON object
     *
     * #### Usage
     *
     * ```javascript
     * var camera = CameraDevice.parse(JSONObj);
     * ```
     */
    CameraDevice.parse = function (deviceJSON) {
        var cam = new CameraDevice({
            id: deviceJSON['disp'],
            name: deviceJSON['name']
        });
        return cam;
    };
    /**
     *  Adds this camera device to the current scene.
     */
    CameraDevice.prototype.addToScene = function () {
        var _this = this;
        return new Promise(function (resolve) {
            app_1.App.callFunc('addcamera', 'dev:' + _this._id).then(function () {
                resolve(true);
            });
        });
    };
    return CameraDevice;
})();
exports.CameraDevice = CameraDevice;
},{"../internal/app":16,"../internal/util/json":21,"../internal/util/xml":23}],26:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var rectangle_1 = require('../util/rectangle');
var json_1 = require('../internal/util/json');
var xml_1 = require('../internal/util/xml');
var app_1 = require('../internal/app');
/**
 * The Game Class is the object returned by {@link #system/System System Class'}
 * getGames method. It provides you with methods to fetch the game object's
 * attributes, and also provides methods to convert it back to an XML object
 * that is compatible with XBC
 *
 * ### Basic Usage
 *
 * ```javascript
 * var XJS = require('xjs');
 * var System = XJS.System;
 * var xml;
 *
 * System.getGames().then(function(games) {
 * 	for (var i in games) {
 * 		if(games[i].isFullscreen()) {
 * 			xml = games[i].toXML();
 * 			// Do something with the xml here. Probably add it to the current scene
 * 		}
 * 	}
 * });
 * ```
 */
var Game = (function () {
    function Game() {
    }
    /**
     * return: number
     *
     * Gets the game's process ID.
     *
     * #### Usage
     *
     * ```javascript
     * var processId = game.getPid();
     * ```
     */
    Game.prototype.getPid = function () {
        return this._pid;
    };
    /**
     * return: number
     *
     * Gets the Graphics API handle.
     *
     * #### Usage
     *
     * ```javascript
     * var handle = game.getHandle();
     * ```
     */
    Game.prototype.getHandle = function () {
        return this._handle;
    };
    /**
     * return: number
     *
     * Gets the window handle.
     *
     * #### Usage
     *
     * ```javascript
     * var windowHandle = game.getWindowHandle();
     * ```
     */
    Game.prototype.getWindowHandle = function () {
        return this._hwnd;
    };
    /**
     * return: string
     *
     * Gets the Graphics API type.
     *
     * #### Usage
     *
     * ```javascript
     * var gApiType = game.getGapiType();
     * ```
     *
     * #### Possible Values
     *
     * ```
     * OGL, DX8, DX8_SwapChain, DX9, DX9Ex, DX9_SwapChain,
     * DX9_PresentEx, DX10, DX11, DX11.1, DX11.1_Present1
     * ```
     */
    Game.prototype.getGapiType = function () {
        return this._gapitype;
    };
    /**
     * return: Rectangle
     *
     * Gets the game resolution.
     *
     * #### Usage
     *
     * ```javascript
     * var resolution = game.getResolution();
     * ```
     */
    Game.prototype.getResolution = function () {
        return rectangle_1.Rectangle.fromDimensions(this._width, this._height);
    };
    /**
     * return: boolean
     *
     * Checks if game has exclusive full screen.
     *
     * #### Usage
     *
     * ```javascript
     * var isFullscreen = game.isFullscreen();
     * ```
     */
    Game.prototype.isFullscreen = function () {
        return this._flags === 1 ? true : false;
    };
    /**
     * return: string
     *
     * Gets the window title
     *
     * #### Usage
     *
     * ```javascript
     * var windowName = game.getWindowName();
     * ```
     */
    Game.prototype.getWindowName = function () {
        return this._wndname;
    };
    /**
     * return: number
     *
     * Gets timestamp of last frame in milliseconds.
     *
     * #### Usage
     *
     * ```javascript
     * var lastFrameTimestamp = game.getLastFrameTimestamp();
     * ```
     */
    Game.prototype.getLastFrameTimestamp = function () {
        return this._lastframets;
    };
    /**
     * Get the FPS Render of the game
     */
    Game.prototype.getFpsRender = function () {
        return this._fpsRender;
    };
    /**
     * Get the Captured FPS of the game
     */
    Game.prototype.getFpsCapture = function () {
        return this._fpsCapture;
    };
    /**
     * Get the image name of the game
     */
    Game.prototype.getImageName = function () {
        return this._imagename;
    };
    /**
     * Get the replace image value of the game
     */
    Game.prototype.getReplace = function () {
        return this._replace;
    };
    /**
     * param: gameJSON<JXON>
     * ```
     * return: Game
     * ```
     *
     * Converts a JSON object into a Game object
     *
     * #### Usage
     *
     * ```javascript
     * var XJS = require('xjs');
     * var game = XJS.Game.parse(jsonObj);
     * ```
     */
    Game.parse = function (jxon) {
        var g = new Game();
        g._pid = jxon['pid'] !== undefined ? parseInt(jxon['pid']) : undefined;
        g._handle = jxon['handle'] !== undefined ? parseInt(jxon['handle']) :
            undefined;
        g._hwnd = jxon['hwnd'] !== undefined ? parseInt(jxon['hwnd']) : undefined;
        g._gapitype = jxon['GapiType'];
        g._width = jxon['width'] !== undefined ? parseInt(jxon['width']) :
            undefined;
        g._height = jxon['height'] !== undefined ? parseInt(jxon['height']) :
            undefined;
        g._flags = jxon['flags'] !== undefined ? parseInt(jxon['flags']) :
            undefined;
        g._wndname = jxon['wndname'];
        g._lastframets = jxon['lastframets'] !== undefined ?
            parseInt(jxon['lastframets']) : undefined;
        g._fpsRender = jxon['fpsRender'] !== undefined ? Number(jxon['fpsRender']) :
            undefined;
        g._fpsCapture = jxon['fpsCapture'] !== undefined ?
            Number(jxon['fpsCapture']) : undefined;
        g._imagename = jxon['imagename'];
        g._replace = jxon['replace'];
        return g;
    };
    /**
     * return: XML
     *
     * Converts Game object into an XML object
     *
     * #### Usage
     *
     * ```javascript
     * var gameXML = game.toXML();
     * ```
     */
    Game.prototype.toXML = function () {
        var gamesource = new json_1.JSON();
        gamesource.tag = 'src';
        gamesource['pid'] = this._pid;
        gamesource['handle'] = this._handle;
        gamesource['hwnd'] = this._hwnd;
        gamesource['gapitype'] = this._gapitype;
        gamesource['width'] = this._width;
        gamesource['height'] = this._height;
        gamesource['flags'] = this._flags;
        gamesource['wndname'] = this._wndname;
        gamesource['lastframets'] = this._lastframets;
        gamesource['selfclosing'] = true;
        return xml_1.XML.parseJSON(gamesource);
    };
    /**
     *  Adds this game to the current scene.
     */
    Game.prototype.addToScene = function () {
        var _this = this;
        return new Promise(function (resolve) {
            app_1.App.callFunc('addgamesource', 'dev:' + _this.toXML()).then(function () {
                resolve(true);
            });
        });
    };
    return Game;
})();
exports.Game = Game;
},{"../internal/app":16,"../internal/util/json":21,"../internal/util/xml":23,"../util/rectangle":33}],27:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var json_1 = require('../internal/util/json');
var xml_1 = require('../internal/util/xml');
var app_1 = require('../internal/app');
var MicrophoneDevice = (function () {
    function MicrophoneDevice() {
    }
    MicrophoneDevice.parse = function (jxon) {
        var m = new MicrophoneDevice();
        m._disp = jxon['disp'];
        m._name = jxon['name'];
        return m;
    };
    /**
     * return: XML
     *
     * Converts Microphone object into an XML object
     *
     * #### Usage
     *
     * ```javascript
     * var microphoneXML = microphone.toXML();
     * ```
     */
    MicrophoneDevice.prototype.toXML = function () {
        var microphone = new json_1.JSON();
        microphone.tag = 'item';
        microphone['item'] = this._disp;
        microphone['name'] = this._name;
        microphone['type'] = '2'; // type LIVE
        microphone['selfclosing'] = true;
        return xml_1.XML.parseJSON(microphone);
    };
    /**
     *  Adds this microphone device to the current scene.
     */
    MicrophoneDevice.prototype.addToScene = function () {
        var _this = this;
        return new Promise(function (resolve) {
            app_1.App.callFunc('additem', _this.toXML().toString()).then(function () {
                resolve(true);
            });
        });
    };
    return MicrophoneDevice;
})();
exports.MicrophoneDevice = MicrophoneDevice;
},{"../internal/app":16,"../internal/util/json":21,"../internal/util/xml":23}],28:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var app_1 = require('../internal/app');
var audio_1 = require('./audio');
var microphone_1 = require('./microphone');
var camera_1 = require('./camera');
var game_1 = require('./game');
var environment_1 = require('../core/environment');
var internal_1 = require('../internal/internal');
/**
 * This enum is used for {@link #system/System System Class'} getAudioDevices
 * method's first parameter.
 *
 * ### Basic Usage
 *
 * ```javascript
 * var XJS = require('xjs');
 * XJS.System.getAudioDevices(XJS.AudioDeviceDataflow.CAPTURE, ...);
 * ```
 */
(function (AudioDeviceDataflow) {
    AudioDeviceDataflow[AudioDeviceDataflow["RENDER"] = 1] = "RENDER";
    AudioDeviceDataflow[AudioDeviceDataflow["CAPTURE"] = 2] = "CAPTURE";
    AudioDeviceDataflow[AudioDeviceDataflow["ALL"] = 3] = "ALL";
})(exports.AudioDeviceDataflow || (exports.AudioDeviceDataflow = {}));
var AudioDeviceDataflow = exports.AudioDeviceDataflow;
/**
 * This enum is used for {@link #system/System System Class'} getAudioDevices
 * method's second parameter.
 *
 * ### Basic Usage
 *
 * ```javascript
 * var XJS = require('xjs');
 * XJS.System.getAudioDevices(..., XJS.AudioDeviceState.ACTIVE);
 * ```
 */
(function (AudioDeviceState) {
    AudioDeviceState[AudioDeviceState["ACTIVE"] = 1] = "ACTIVE";
    AudioDeviceState[AudioDeviceState["DISABLED"] = 2] = "DISABLED";
    AudioDeviceState[AudioDeviceState["UNPLUGGED"] = 4] = "UNPLUGGED";
    AudioDeviceState[AudioDeviceState["NOTPRESENT"] = 8] = "NOTPRESENT";
    AudioDeviceState[AudioDeviceState["ALL"] = 15] = "ALL";
})(exports.AudioDeviceState || (exports.AudioDeviceState = {}));
var AudioDeviceState = exports.AudioDeviceState;
/**
 * The System class provides you methods to fetch audio devices to manipulate
 * the application's audio settings. It also allows you to fetch games,
 * microphone devices and camera devices to add to scenes. Finally, some
 * system-level functionality such as cursor position is exposed.
 *
 * ### Basic Usage
 *
 * ```javascript
 * var XJS = require('xjs');
 * var System = XJS.System;
 *
 * System.getCameraDevices().then(function(cameras) {
 *   window.cameras = cameras;
 * });
 * ```
 */
var System = (function () {
    function System() {
    }
    /**
     * return: Promise<AudioDevice[]>
     *
     * Gets audio devices, both input and output
     * See also: System/AudioDevice
     *
     * #### Usage
     *
     * ```javascript
     * System.getAudioDevices(
     *   XML.AudioDeviceDataflow.ALL,
     *   XML.AudioDeviceState.ACTIVE
     * ).then(function(devices) {
     *   // devices is an array of AudioDevice object
     *   window.audios = devices;
     * });
     * ```
     */
    System.getAudioDevices = function (dataflow, state) {
        if (dataflow === void 0) { dataflow = AudioDeviceDataflow.ALL; }
        if (state === void 0) { state = AudioDeviceState.ACTIVE; }
        return new Promise(function (resolve) {
            app_1.App.getAsList('wasapienum').then(function (devicesJXON) {
                var devices = [];
                if (devicesJXON !== undefined) {
                    var devicesJXONLength = devicesJXON.length;
                    for (var i = 0; i < devicesJXONLength; ++i) {
                        var device = devicesJXON[i];
                        var bitsState = AudioDeviceState[String(device['State'])
                            .toUpperCase().replace(/\s+/g, '')];
                        if ((bitsState & state) !== bitsState) {
                            continue;
                        }
                        var bitsFlow = AudioDeviceDataflow[String(device['DataFlow'])
                            .toUpperCase()];
                        if ((bitsFlow & dataflow) !== bitsFlow) {
                            continue;
                        }
                        if (device['name'].toLowerCase().indexOf('xsplit') > -1) {
                            continue;
                        }
                        devices.push(audio_1.AudioDevice.parse(device));
                    }
                }
                resolve(devices);
            });
        });
    };
    /**
     * return: Promise<CameraDevice[]>
     *
     * Gets all camera devices
     * See also: System/CameraDevice
     *
     * #### Usage
     *
     * ```javascript
     * System.getCameraDevices().then(function(devices) {
     *   // devices is an array of CameraDevice object
     *   window.cameras = devices;
     * });
     * ```
     */
    System.getCameraDevices = function () {
        return new Promise(function (resolve) {
            app_1.App.getAsList('dshowenum:vsrc').then(function (devicesJSON) {
                var devices = [];
                if (devicesJSON !== undefined) {
                    for (var _i = 0; _i < devicesJSON.length; _i++) {
                        var device = devicesJSON[_i];
                        if (String(device['disp']).toLowerCase().indexOf('xsplit') === -1 &&
                            String(device['disp']).toLowerCase() !==
                                ("@DEVICE:SW:{860BB310-5D01-11D0-BD3B-00A0C911CE86}\\" +
                                    "{778abfb2-e87b-48a2-8d33-675150fcf8a2}").toLowerCase()) {
                            devices.push(camera_1.CameraDevice.parse(device));
                        }
                    }
                    resolve(devices);
                }
            });
        });
    };
    /**
     * return: Promise<Game[]>
     *
     * Gets all currently running games
     * See also: System/Game
     *
     * #### Usage
     *
     * ```javascript
     * System.getGames().then(function(games) {
     *   // games is an array of Game object
     *   window.games = games;
     * });
     * ```
     */
    System.getGames = function () {
        return new Promise(function (resolve) {
            app_1.App.getAsList('gsenum').then(function (gamesJXON) {
                var games = [];
                if (gamesJXON !== undefined) {
                    var gamesJXONLength = gamesJXON.length;
                    for (var i = 0; i < gamesJXONLength; ++i) {
                        games.push(game_1.Game.parse(gamesJXON[i]));
                    }
                }
                resolve(games);
            });
        });
    };
    /**
     * return: Promise<MicrophoneDevice[]>
     *
     * Gets all audio capture devices that may be added to the stage
     * See also: System/MicrophoneDevice
     *
     * #### Usage
     *
     * ```javascript
     * System.getMicrophones().then(function(microphones) {
     *   microphones[0].addToScene(); // add first microphone to stage
     * });
     * ```
     */
    System.getMicrophones = function () {
        return new Promise(function (resolve) {
            app_1.App.getAsList('dshowenum:asrc').then(function (micsJXON) {
                var mics = [];
                if (micsJXON !== undefined) {
                    var micsJXONLength = micsJXON.length;
                    for (var i = 0; i < micsJXONLength; ++i) {
                        mics.push(microphone_1.MicrophoneDevice.parse(micsJXON[i]));
                    }
                }
                resolve(mics);
            });
        });
    };
    /**
     * return: Promise<JSON>
     *
     * Gets the position of the cursor. Does not work on Source Plugins.
     *
     * #### Usage
     *
     * ```javascript
     * System.getCursorPosition().then(function(pos) {
     *   var x = pos.x; // X Axis
     *   var y = pos.y; // Y Axis
     * });
     * ```
     */
    System.getCursorPosition = function () {
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isSourcePlugin()) {
                reject(Error('function is not available for source'));
            }
            else {
                var res = internal_1.exec('GetCursorPos');
                if (typeof res === 'string') {
                    var posArr = res.split(',');
                    var pos = {};
                    pos['x'] = Number(posArr[0]);
                    pos['y'] = Number(posArr[1]);
                    resolve(pos);
                }
                else {
                    reject(Error('cannot fetch current cursor position'));
                }
            }
        });
    };
    /**
     * param: JSON: {x: number, y: number}
     *
     * Sets the position of the cursor. Does not work on Source Plugins.
     *
     * #### Usage
     *
     * ```javascript
     * System.setCursorPosition({x:0, y:0});
     * ```
     */
    System.setCursorPosition = function (pos) {
        return new Promise(function (resolve, reject) {
            if (environment_1.Environment.isSourcePlugin()) {
                reject(Error('function is not available for source'));
            }
            else if (typeof pos.x !== 'number' || typeof pos.y !== 'number') {
                reject(Error('invalid parameters'));
            }
            else {
                internal_1.exec('SetCursorPos', String(pos.x), String(pos.y));
                resolve(true);
            }
        });
    };
    return System;
})();
exports.System = System;
},{"../core/environment":2,"../internal/app":16,"../internal/internal":19,"./audio":24,"./camera":25,"./game":26,"./microphone":27}],29:[function(require,module,exports){
var Color = (function () {
    function Color(props) {
        if (props['rgb'] !== undefined) {
            this.setRgb(props['rgb']);
        }
        else if (props['irgb'] !== undefined) {
            this.setIrgb(props['irgb']);
        }
        else if (props['bgr'] !== undefined) {
            this.setBgr(props['bgr']);
        }
        else if (props['ibgr'] !== undefined) {
            this.setIbgr(props['ibgr']);
        }
        else {
            throw new Error('Do not call Color constructor without parameters.');
        }
    }
    Color.fromRGBString = function (rgb) {
        return new Color({ rgb: rgb });
    };
    Color.fromRGBInt = function (irgb) {
        return new Color({ irgb: irgb });
    };
    Color.fromBGRString = function (bgr) {
        return new Color({ bgr: bgr });
    };
    Color.fromBGRInt = function (ibgr) {
        return new Color({ ibgr: ibgr });
    };
    Color.prototype.getRgb = function () {
        return this._rgb;
    };
    Color.prototype.setRgb = function (rgb) {
        this._rgb = rgb.replace(/^#/, '');
        this._irgb = parseInt(this._rgb, 16);
        this._bgr = [this._rgb.substring(4, 6), this._rgb.substring(2, 4),
            this._rgb.substring(0, 2)].join('');
        this._ibgr = parseInt(this._bgr, 16);
        return this;
    };
    Color.prototype.getBgr = function () {
        return this._bgr;
    };
    Color.prototype.setBgr = function (bgr) {
        this.setRgb([bgr.substring(4, 6), bgr.substring(2, 4),
            bgr.substring(0, 2)
        ].join(''));
        return this;
    };
    Color.prototype.getIrgb = function () {
        return this._irgb;
    };
    Color.prototype.setIrgb = function (irgb) {
        var rgb = irgb.toString(16);
        while (rgb.length < 6) {
            rgb = '0' + rgb;
        }
        this.setRgb(rgb);
        return this;
    };
    Color.prototype.getIbgr = function () {
        return this._ibgr;
    };
    Color.prototype.setIbgr = function (ibgr) {
        var bgr = ibgr.toString(16);
        while (bgr.length < 6) {
            bgr = '0' + bgr;
        }
        this.setBgr(bgr);
        return this;
    };
    return Color;
})();
exports.Color = Color;
},{}],30:[function(require,module,exports){
// simple event emitter
var EventEmitter = (function () {
    function EventEmitter() {
        this._handlers = {};
    }
    /** This function attaches a handler to an event. Duplicate handlers are allowed. */
    EventEmitter.prototype.on = function (event, handler) {
        if (this._handlers[event] === undefined) {
            this._handlers[event] = [];
        }
        this._handlers[event].push(handler);
    };
    /** This function lets an event trigger with any number of supplied parameters. */
    EventEmitter.prototype.emit = function (event) {
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        if (this._handlers[event] === undefined) {
            return;
        }
        for (var _a = 0, _b = this._handlers[event]; _a < _b.length; _a++) {
            var handler = _b[_a];
            handler.apply(this, params);
        }
    };
    return EventEmitter;
})();
exports.EventEmitter = EventEmitter;
},{}],31:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var internal_1 = require('../internal/internal');
var IO = (function () {
    function IO() {
    }
    /**
     * Returns a base-64 encoded string of the target file's contents.
     * UTF-8 encoded files may be decoded through:
     * ```javascript
     * var decodedContent = decodeURIComponent(escape(window.atob(base64Content));
     * ```
     */
    IO.getFileContent = function (path) {
        return new Promise(function (resolve) {
            resolve(internal_1.exec('GetFileContent', path));
        });
    };
    /**
     * Returns a base-64 encoded string of the target endpoint's contents.
     * Redirects are resolved, and this bypasses access-control-allow-origin.
     *
     * UTF-8 encoded content may be decoded through:
     * ```javascript
     * var decodedContent = decodeURIComponent(escape(window.atob(base64Content));
     * ```
     */
    IO.getWebContent = function (url) {
        return new Promise(function (resolve) {
            internal_1.exec('GetWebContent', url, function (encoded) {
                resolve(encoded);
            });
        });
    };
    /** Opens a URL in the user's default browser. URLs need to
     *
     */
    IO.openUrl = function (url) {
        internal_1.exec('OpenUrl', url);
    };
    /**
     * Opens a file dialog for the user to select a file (or multiple files).
     * Returns an array of strings, each of which contains the full path
     * and filename of a selected file. Rejects when the dialog is canceled.
     *
     * The first (optional) argument is a JSON object that can be used to indicate
     * that certain flags should be true. These are documented as follows:
     * - `allowMultiSelect`: allows users to select multiple files.
     * - `fileMustExist`: prevents users from typing a name of a nonexistent file
     * - `forceShowHidden`: lets the dialog show files marked as System or Hidden
     *  (but not both)
     *
     * The second argument (also optional) is a JSON object used to specify the
     * filter for items to be displayed. It takes two members:
     * - `name`: the description of the filter (for example: Image Files)
     * - `extensions`: an array of file extensions (for example: `['jpg','bmp']`);
     */
    IO.openFileDialog = function (optionBag, filter) {
        return new Promise(function (resolve, reject) {
            var flags = 0;
            if (optionBag !== undefined && optionBag !== null) {
                if (optionBag.allowMultiSelect === true) {
                    flags = flags | IO._ALLOW_MULTI_SELECT;
                }
                if (optionBag.fileMustExist === true) {
                    flags = flags | IO._FILE_MUST_EXIST;
                }
                if (optionBag.forceShowHidden === true) {
                    flags = flags | IO._FORCE_SHOW_HIDDEN;
                }
            }
            var filterString = '';
            if (filter !== undefined && filter !== null &&
                filter.name !== undefined && filter.extensions !== undefined) {
                filterString = filter.name + '|';
                filterString += (filter.extensions.map(function (val) {
                    return '*.' + val;
                })).join(';');
                filterString += '||';
            }
            internal_1.exec('OpenFileDialogAsync', null, null, String(flags), filterString, function (path) {
                if (path !== "null") {
                    resolve(path.split('|'));
                }
                else {
                    reject(Error('File selection cancelled.'));
                }
            });
        });
    };
    IO._ALLOW_MULTI_SELECT = 0x200;
    IO._FILE_MUST_EXIST = 0x1000;
    IO._FORCE_SHOW_HIDDEN = 0x10000000;
    return IO;
})();
exports.IO = IO;
},{"../internal/internal":19}],32:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var isReady = false;
var readyPromise = new Promise(function (resolve) {
    document.addEventListener('xsplit-js-ready', function () {
        resolve();
    });
    if (isReady) {
        resolve();
    }
});
function ready() {
    return readyPromise;
}
exports.ready = ready;
function setReady() {
    isReady = true;
}
exports.setReady = setReady;
},{}],33:[function(require,module,exports){
var Rectangle = (function () {
    function Rectangle() {
    }
    /** Gets the top value */
    Rectangle.prototype.getTop = function () {
        return this._top;
    };
    /** Sets the top value */
    Rectangle.prototype.setTop = function (top) {
        this._top = top;
        if (this._bottom !== undefined &&
            this._height !== (this._top - this._bottom)) {
            this.setHeight(Math.abs(this._top - this._bottom));
        }
        else if (this._height !== undefined &&
            this._bottom !== (this._top + this._height)) {
            this.setBottom(this._top + this._height);
        }
        return this;
    };
    /** Gets the left value */
    Rectangle.prototype.getLeft = function () {
        return this._left;
    };
    /** Sets the left value */
    Rectangle.prototype.setLeft = function (left) {
        this._left = left;
        if (this._right !== undefined &&
            this._width !== Math.abs(this._right - this._left)) {
            this.setWidth(Math.abs(this._right - this._left));
        }
        else if (this._width !== undefined &&
            this._height !== (this._left + this._width)) {
            this.setRight(this._left + this._width);
        }
        return this;
    };
    /** Gets the right value */
    Rectangle.prototype.getRight = function () {
        return this._right;
    };
    /** Sets the right value */
    Rectangle.prototype.setRight = function (right) {
        this._right = right;
        if (this._left !== undefined &&
            this._width !== Math.abs(this._right - this._left)) {
            this.setWidth(Math.abs(this._right - this._left));
        }
        else if (this._width !== undefined &&
            this._left !== (this._right - this._width)) {
            this.setLeft(this._right - this._width);
        }
        return this;
    };
    /** Gets the bottom value */
    Rectangle.prototype.getBottom = function () {
        return this._bottom;
    };
    /** Sets the bottom value */
    Rectangle.prototype.setBottom = function (bottom) {
        this._bottom = bottom;
        if (this._top !== undefined &&
            this._height !== Math.abs(this._top - this._bottom)) {
            this.setHeight(Math.abs(this._top - this._bottom));
        }
        else if (this._height !== undefined &&
            this._top !== (this._bottom - this._height)) {
            this.setTop(this._bottom - this._height);
        }
        return this;
    };
    /** Gets the width value */
    Rectangle.prototype.getWidth = function () {
        return this._width;
    };
    /** Sets the width value */
    Rectangle.prototype.setWidth = function (width) {
        this._width = width;
        if (this._right !== undefined &&
            this._left !== (this._right - this._width)) {
            this.setLeft(this._right - this._width);
        }
        else if (this._left !== undefined &&
            this._right !== (this._left + this._width)) {
            this.setRight(this._left + this._width);
        }
        return this;
    };
    /** Gets the height value */
    Rectangle.prototype.getHeight = function () {
        return this._height;
    };
    /** Sets the height value */
    Rectangle.prototype.setHeight = function (height) {
        this._height = height;
        if (this._top !== undefined &&
            this._bottom !== (this._top + this._height)) {
            this.setBottom(this._top + this._height);
        }
        else if (this._bottom !== undefined &&
            this._top !== (this._bottom - this._height)) {
            this.setTop(this._bottom - this._height);
        }
        return this;
    };
    Rectangle.fromDimensions = function (width, height) {
        if (width < 0 || height < 0) {
            throw new Error('Rectangle dimensions cannot be negative.');
        }
        var rect = new Rectangle();
        rect._width = width;
        rect._height = height;
        return rect;
    };
    Rectangle.fromCoordinates = function (top, left, right, bottom) {
        if (top > bottom) {
            throw new Error('Top coordinate must be smaller than bottom.');
        }
        else if (left > right) {
            throw new Error('Right coordinate must be smaller than left.');
        }
        var rect = new Rectangle();
        rect._top = top;
        rect._left = left;
        rect.setRight(right); // calculates width
        rect.setBottom(bottom); // calculates height
        return rect;
    };
    Rectangle.prototype.toDimensionString = function () {
        return this._width + ',' + this._height;
    };
    Rectangle.prototype.toCoordinateString = function () {
        if (this._left === undefined) {
            throw new Error('This Rectangle instance does not have coordinates.');
        }
        else {
            return this._left + ',' + this._top + ',' + this._right + ',' + this._bottom;
        }
    };
    Rectangle.prototype.toString = function (value) {
        if (value === undefined) {
            return this.toDimensionString(); // all rectangles have dimensions
        }
        else {
            var format = value;
            format = format.replace(':left', String(this._left));
            format = format.replace(':top', String(this._top));
            format = format.replace(':right', String(this._right));
            format = format.replace(':bottom', String(this._bottom));
            format = format.replace(':width', String(this._width));
            format = format.replace(':height', String(this._height));
            return format;
        }
    };
    return Rectangle;
})();
exports.Rectangle = Rectangle;
},{}],34:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var eventemitter_1 = require('../util/eventemitter');
var internal_1 = require('../internal/internal');
/** This utility class exposes functionality for source plugin developers to
 *  handle the configuration window for their source plugins. The framework also
 *  uses this class for its own internal purposes.
 *
 *  Developers can use this class to specify how their configuration HTML
 *  should be rendered within the built-in window in XSplit Broadcaster.
 *  This class also serves as an event emitter for specific important events.
 *
 *  At the moment, the only relevant event for developers is:
 *  - ```set-selected-tab```: used when using Tabbed mode. Passes the name of the selected tab so configuration window can update itself accordingly.
 *
 *  Use the ```on(event: string, handler: Function)``` function to listen to an event.
 */
var SourceConfigWindow = (function (_super) {
    __extends(SourceConfigWindow, _super);
    function SourceConfigWindow() {
        var _this = this;
        _super.call(this);
        window.addEventListener('message', function (event) {
            try {
                var data = JSON.parse(event.data);
            }
            catch (e) {
                // syntax error probably happened, exit gracefully
                return;
            }
            switch (data.event) {
                // currently, restrict messages to selected set
                case 'set-selected-tab':
                    this.emit(data.event, data.value);
                    break;
                case 'async-callback':
                    this.emit(data.event, {
                        asyncId: data.value.asyncId,
                        result: data.value.result
                    });
                    break;
            }
        }.bind(this));
        this.on('config-load', function () {
            _this._informConfigLoaded();
        });
        SourceConfigWindow._instance = this;
    }
    SourceConfigWindow.getInstance = function () {
        if (SourceConfigWindow._instance === undefined) {
            SourceConfigWindow._instance = new SourceConfigWindow();
        }
        return SourceConfigWindow._instance;
    };
    // helper function to communicate with built-in container
    SourceConfigWindow.prototype._notify = function (obj) {
        window.parent.postMessage(JSON.stringify(obj), '*');
    };
    SourceConfigWindow.prototype.useFullWindow = function () {
        this._setRenderMode(SourceConfigWindow._MODE_FULL);
    };
    SourceConfigWindow.prototype.useTabbedWindow = function (config) {
        this._setRenderMode(SourceConfigWindow._MODE_TABBED);
        this._declareCustomTabs(config.customTabs);
        this._setTabOrder(config.tabOrder);
    };
    SourceConfigWindow.prototype._setRenderMode = function (renderMode) {
        this._mode = renderMode;
        this._notify({
            event: 'set-mode',
            value: renderMode
        });
    };
    ;
    SourceConfigWindow.prototype._setTabOrder = function (tabArray) {
        this._notify({
            event: 'set-tab-order',
            value: JSON.stringify(tabArray)
        });
    };
    ;
    SourceConfigWindow.prototype._declareCustomTabs = function (tabArray) {
        this._notify({
            event: 'set-custom-tabs',
            value: JSON.stringify(tabArray)
        });
    };
    ;
    SourceConfigWindow.prototype._informConfigLoaded = function () {
        this._notify({ event: 'load' });
    };
    /**
     *  param: width<number>, height<number>
     *
     *  Resizes the configuration window.
     */
    SourceConfigWindow.prototype.resizeConfig = function (width, height) {
        if (this._mode === 'full') {
            this._notify({
                event: 'resize',
                value: JSON.stringify({
                    width: width,
                    height: height
                })
            });
        }
        else if (this._mode !== 'embedded') {
            internal_1.exec('SetDialogSize', String(width), String(height));
        }
    };
    ;
    /** Closes the configuration window. */
    SourceConfigWindow.prototype.closeConfig = function () {
        internal_1.exec('Close');
    };
    ;
    SourceConfigWindow._MODE_FULL = 'full';
    SourceConfigWindow._MODE_TABBED = 'embedded';
    return SourceConfigWindow;
})(eventemitter_1.EventEmitter);
exports.SourceConfigWindow = SourceConfigWindow;
},{"../internal/internal":19,"../util/eventemitter":30}],35:[function(require,module,exports){
/// <reference path="../../defs/es6-promise.d.ts" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var eventemitter_1 = require('../util/eventemitter');
/** This utility class is used internally by the framework for certain important
 *  processes. This class also exposes certain important events that the source
 *  plugin may emit.
 *
 *  Currently there are only two events:
 *  - ```save-config```: signals the source that it should save the configuration object. Handler is a function f(config: JSON)
 *  - ```apply-config```: signals the source that it should apply the changes that this configuration object describes. Handler is a function f(config: JSON)
 *
 *  Use the ```on(event: string, handler: Function)``` function to listen to an event.
 */
var SourcePluginWindow = (function (_super) {
    __extends(SourcePluginWindow, _super);
    /**
     *  Use getInstance() instead.
     */
    function SourcePluginWindow() {
        _super.call(this);
        this.on('message-source', function (message) {
            if (message.request !== undefined) {
                if (message.request === 'saveConfig') {
                    this.emit('save-config', message.data);
                }
                else if (message.request === 'applyConfig') {
                    this.emit('apply-config', message.data);
                }
            }
        });
        SourcePluginWindow._instance = this;
    }
    SourcePluginWindow.getInstance = function () {
        if (SourcePluginWindow._instance === undefined) {
            SourcePluginWindow._instance = new SourcePluginWindow();
        }
        return SourcePluginWindow._instance;
    };
    return SourcePluginWindow;
})(eventemitter_1.EventEmitter);
exports.SourcePluginWindow = SourcePluginWindow;
window['MessageSource'] = function (message) {
    SourcePluginWindow.getInstance().emit("message-source", JSON.parse(message));
};
window['SetConfiguration'] = function (configObj) {
    try {
        var data = JSON.parse(configObj);
        var source = SourcePluginWindow.getInstance();
        source.emit("apply-config", data);
        source.emit("save-config", data);
    }
    catch (e) {
        // syntax error probably happened, exit gracefully
        return;
    }
};
},{"../util/eventemitter":30}],"xjs":[function(require,module,exports){
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
require('./internal/init');
__export(require('./util/color'));
__export(require('./util/rectangle'));
__export(require('./util/io'));
__export(require('./core/environment'));
__export(require('./core/app'));
__export(require('./core/scene'));
__export(require('./core/transition'));
__export(require('./core/item/item'));
__export(require('./core/item/camera'));
__export(require('./core/item/game'));
__export(require('./core/item/audio'));
__export(require('./core/item/html'));
var ichroma_1 = require('./core/item/ichroma');
exports.KeyingType = ichroma_1.KeyingType;
exports.ChromaPrimaryColors = ichroma_1.ChromaPrimaryColors;
exports.ChromaAntiAliasLevel = ichroma_1.ChromaAntiAliasLevel;
__export(require('./system/system'));
__export(require('./system/audio'));
__export(require('./system/game'));
__export(require('./system/camera'));
__export(require('./system/microphone'));
__export(require('./window/config'));
__export(require('./window/source'));
var ready_1 = require('./util/ready');
exports.ready = ready_1.ready;
},{"./core/app":1,"./core/environment":2,"./core/item/audio":3,"./core/item/camera":4,"./core/item/game":5,"./core/item/html":6,"./core/item/ichroma":8,"./core/item/item":12,"./core/scene":14,"./core/transition":15,"./internal/init":18,"./system/audio":24,"./system/camera":25,"./system/game":26,"./system/microphone":27,"./system/system":28,"./util/color":29,"./util/io":31,"./util/ready":32,"./util/rectangle":33,"./window/config":34,"./window/source":35}]},{},["xjs"]);
</script>

    <script>/* globals Bloodhound, Promise, watcher */
(function() {
  'use strict';

  var TRACKTL_URL = 'http://api.tracktl.com/api/party/';
  var watcher = window.watcher;

  /**
   * All necessary methods that the plugin needs to
   * fetch data from TrackTL.
   *
   * Most methods, if not all, are promise based methods
   */
  function TrackTL(id) {
    this.id = id;
  }

  /**
   * Connect to TrackTL's websockets
   */
  TrackTL.prototype.connect = function(id) {
    var _this = this;
    this.id = id !== undefined ? id : this.id;

    return new Promise(function(resolve, reject) {
      if (!isNaN(_this.id)) {
        watcher.connect(_this.id).then(function() {
          resolve(watcher);
        });
      } else {
        reject(new Error('No Valid ID Supplied'));
      }
    });
  }

  /**
   * This method is made to be used on Twitter's typeahead.
   *
   * ```
   * var party = new TrackTL();
   * typeahead({}, { name: '', source: party.searchParty });
   * ```
   */
  TrackTL.prototype.searchParty = function(query, sync, async) {
    var remote = { wildcard: '%QUERY' };
    var isPartyUrl = /[a-z0-9\.]+\.track\.tl/ig.test(query);

    if (isPartyUrl) {
      query = /([a-z0-9\.]+)\.track\.tl/ig.exec(query);
      query = query[query.length - 1];
    }

    remote.url = TRACKTL_URL +
      ((isNaN(query) || query.trim() === '') && !isPartyUrl ?
      '?query={"search":"%QUERY"}&order_on=nom' : '%QUERY');

    if ((!isNaN(query) && query.trim() !== '') || isPartyUrl) {
      remote.transform = function(ret) {
        return [ret];
      };
    }

    return new Bloodhound({
      datumTokenizer: Bloodhound.tokenizers.obj.whitespace('nom'),
      queryTokenizer: Bloodhound.tokenizers.whitespace,
      remote: remote
    }).search(query, sync, async);
  };

  /**
   * Fetches the party details
   *
   * return: Promise<TrackTL>
   *
   * ```
   * party.getDetails().then(function(_party) {
   *   var name   = _party.name;
   *   var domain = _party.domain;
   *   var host   = _party.host_name;
   * });
   * ```
   */
  TrackTL.prototype.getDetails = function() {
    var _this = this;

    return new Promise(function(resolve, reject) {
      var client = new XMLHttpRequest();
      client.open('GET', TRACKTL_URL + _this.id);
      client.send();

      client.onload = function() {
        if (this.status === 200) {
          try {
            var details  = JSON.parse(this.response);
            _this.name   = details.nom;
            _this.domain = details.domain + '.track.tl';
            _this.host   = details.host_name;

            resolve(_this);
          } catch(err) {
            reject(err);
          }
        } else {
          reject(this.statusText);
        }
      }
    });
  };

  /**
   * Fetches the current song details
   *
   * return: Promise<{title:string, artist:string, vote:string}>
   *
   * ```
   * party.getCurrentSong().then(function(_song) {
   *   var date     = _song.added_date;
   *   var adder    = _song.adder; // { id:number, name:string, pic:string }
   *   var album    = _song.album;
   *   var artist   = _song.artist;
   *   var coverArt = _song.coverArt;
   *   var duration = _song.duration;
   *   var id       = _song.id;
   *   var priority = _song.priority;
   *   var provider = _song.provider;
   *   var title    = _song.title;
   *   var uri      = _song.uri;
   *   var vote     = _song.vote;
   *   var voted    = _song.voted;
   * });
   * ```
   */
  TrackTL.prototype.getCurrentSong = function() {
    return new Promise(function(resolve, reject) {
      var selected = watcher.trackStore.getSelected();
      if (selected === undefined) {
        reject(new Error('No Current Song'));
      } else {
        resolve(selected);
      }
    });
  };

  /**
   * Fetches the next song details
   *
   * return: Promise<{title:string, artist:string, vote:string}>
   *
   * ```
   * party.getNextSong().then(function(_song) {
   *   var date     = _song.added_date;
   *   var adder    = _song.adder; // { id:number, name:string, pic:string }
   *   var album    = _song.album;
   *   var artist   = _song.artist;
   *   var coverArt = _song.coverArt;
   *   var duration = _song.duration;
   *   var id       = _song.id;
   *   var priority = _song.priority;
   *   var provider = _song.provider;
   *   var title    = _song.title;
   *   var uri      = _song.uri;
   *   var vote     = _song.vote;
   *   var voted    = _song.voted;
   * });
   * ```
   */
  TrackTL.prototype.getNextSong = function() {
    return new Promise(function(resolve, reject) {
      var queue = watcher.trackStore.getFullQueue();

      if (queue.length > 0) {
        resolve(queue[0]);
      } else {
        reject(new Error('No songs in queue'));
      }
    });
  };

  /**
   * Fetches the queue
   *
   * return: Promise<{title:string, artist:string, vote:string}>
   *
   * ```
   * party.getFullQueue().then(function(_queue) {
   *   var _song;
   *   for (var i in _queue) {
   *     _song = _queue[i];
   *     // _song has the same json structure as getNextSong
   *   }
   * });
   * ```
   */
  TrackTL.prototype.getFullQueue = function() {
    return new Promise(function(resolve) {
      resolve(watcher.trackStore.getFullQueue());
    });
  };

  /**
   * Wrapper for watcher.trackStore
   *
   * Available functions/attributes:
   *
   * ```
   * getBackPlaying()
   * getFullQueue()
   * getNext()
   * getPassed()
   * getQueue()
   * getSelected()
   * getTrack()
   * on('change', _callback) // queue change
   * ```
   */
  TrackTL.prototype.getTrackStore = function() {
    return watcher.trackStore;
  };

  /**
   * Wrapper for watcher.trackStore
   *
   * Available functions/attributes:
   *
   * ```
   * getBuffering()
   * getDuration()
   * getPlaying()
   * getPosition()
   * getTrackState()
   * on('change', _callback) // play state change
   * ```
   */
  TrackTL.prototype.getMainPlayer = function() {
    return watcher.mainPlayer;
  };

  window.TrackTL = TrackTL;
})();</script>
    <script>/* globals TrackTL, $ */
(function() {
  'use strict';

  var xjs = require('xjs');

  document.body.addEventListener('contextmenu', function(e) {
    e.preventDefault();
  });

  window.addEventListener('polymer-ready', function() {
    xjs.ready().then(function() {
      // Set config window settings
      var config = xjs.SourceConfigWindow.getInstance();
      config.useFullWindow();
      config.resizeConfig(354, 390);

      var $theme  = $('xui-radio-group');
      var $ok     = $('#ok-button');
      var $cancel = $('#cancel-button');
      var $search = $('#party-search');

      var party = new TrackTL();
      var partyID = '';

      var _toggleOK = function() {
        $ok.prop('disabled', (String($search.val()).trim() === ''));
      };

      var _fetchPartyID = function() {
        var _el = $search.parent().find('.tt-suggestion')[0];

        return _el.querySelector('[name=id]').textContent;
      };

      $search.typeahead({
        hint: false
      }, {
        name:    'party-search',
        display: 'nom',
        source: party.searchParty,
        templates: {
          empty: ['<div class="empty-message">',
            'We can\'t find that trackparty. Please search again.',
          '</div>'].join('\n'),
          suggestion: function(obj) {
            return '<div><strong>' + obj.nom + '</strong> - ' +
              obj.domain + '.track.tl<span name ="id" hidden>' +
              obj.id + '</span></div>';
          }
        }
      }).on('typeahead:asyncrequest', function() {
        $('.tt-loader').attr('show', true);
      }).on('typeahead:asynccancel typeahead:asyncreceive', function() {
        $('.tt-loader').removeAttr('show');
      }).on('typeahead:select', function(jqr, obj) {
        partyID = obj.id ? obj.id : partyID;
      });

      xjs.Item.getCurrentSource().then(function(item) {
        return item.loadConfig();
      }).then(function(conf) {
        $search.typeahead('val', (conf.name !== undefined) ? conf.name : '');

        partyID = (conf.partyID !== undefined) ? conf.partyID : '';

        $theme.val((conf.theme !== undefined) ? conf.theme : 'light');

        _toggleOK();
      });

      $search.on('keyup', function(e) {
        if (e.which !== 13 && partyID !== '') {
          partyID = '';
        }
        _toggleOK();
      });

      $ok.on('click', function() {
        partyID = isNaN(Number(partyID)) || String(partyID).trim() === '' ?
          _fetchPartyID() : partyID;

        xjs.Item.getCurrentSource().then(function(item) {
          item.requestSaveConfig({
            partyID : partyID,
            name    : $search.typeahead('val'),
            theme   : $theme.val()
          });

          config.closeConfig();
        });
      });

      $cancel.on('click', function() {
        config.closeConfig();
      });
    });
  });
})();</script>
  </body>
</html>
</plugin>